<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FCC 成都社区</title>
  <icon>https://fcc-cd.dev/images/FCC-CDC-v1-1.png</icon>
  <subtitle>freeCodeCamp 成都社区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fcc-cd.dev/"/>
  <updated>2025-11-11T17:23:22.026Z</updated>
  <id>https://fcc-cd.dev/</id>
  
  <author>
    <name>freeCodeCamp ChengDu community</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fCC 成都社区 Coffee &amp; Code 周末编程自习室 2025年11月16日</title>
    <link href="https://fcc-cd.dev/activity/workshop/fcc-chengdu-coffee-and-code-2025-11-16/"/>
    <id>https://fcc-cd.dev/activity/workshop/fcc-chengdu-coffee-and-code-2025-11-16/</id>
    <published>2025-11-08T03:23:00.000Z</published>
    <updated>2025-11-11T17:23:22.026Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>周末不想卷，但手又痒？来【开源市集】周末编程自习室写点真代码。11月16日 14:00 漫咖啡·红唐店，面向 Web 前端、全栈、AI 开发者：React 19 升级坑点复盘、GitHub Actions 多分支部署流水线、社区官网性能优化、理财 PWA 现写现跑。带上电脑与在研 repo，结对调试、代码评审、现场提 PR；遇到卡点有导师当面支援，线上也可远程加入。不讲空话不放 PPT，只有 commit、issue 和结果。不限语言与工具，欢迎新人与老手同桌切磋。少点焦虑，多点提交；咖啡在线，Bug 离线。免费参与，名额有限，先到先写。</p><h2 id="活动信息"><a href="#活动信息" class="headerlink" title="活动信息"></a>活动信息</h2><ul><li>时间：2025-11-16 14:00~18:00</li><li>地点：漫咖啡MAAN COFFEE(红唐店)，四川省成都市武侯区天府大道中段中1388号红唐购物中心1层LA104</li><li>人群：编程初学者、开源爱好者、公益志愿者、AI 从业者</li><li>费用：参会免费、餐饮自费</li><li>文档：<a href="https://open-source-bazaar.feishu.cn/wiki/Mi5pwfoE6ijJEokVRLkccOvJnRc" target="_blank" rel="noopener">https://open-source-bazaar.feishu.cn/wiki/Mi5pwfoE6ijJEokVRLkccOvJnRc</a></li><li>直播：<a href="https://vc.feishu.cn/j/288361973" target="_blank" rel="noopener">https://vc.feishu.cn/j/288361973</a></li><li>群聊：<a href="https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=0dcqe9e3-5f27-4d5d-a30c-0477b64c828b" target="_blank" rel="noopener">https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=0dcqe9e3-5f27-4d5d-a30c-0477b64c828b</a></li></ul><a id="more"></a><h2 id="开源分享"><a href="#开源分享" class="headerlink" title="开源分享"></a>开源分享</h2><ol><li><p>💡<a href="https://www.codetoinspire.org/" target="_blank" rel="noopener">灵感代码 —— 阿富汗首个女子编程学校</a> @水歌</p></li><li><p>🤝开源市集·编程自习室 x 疯狂星期四（成都站）@水歌 @彭雪梅</p><ol><li>框架研讨：<a href="https://open-source-bazaar.feishu.cn/wiki/VBT9wevpvimaPmkMBF0cVILdnqc" target="_blank" rel="noopener">智能纪要：编程学习及开源社区建设研讨 2025年11月6日</a></li><li><a href="https://github.com/FreeCodeCamp-Chengdu/Wiki/issues/223#issuecomment-3515510873" target="_blank" rel="noopener">活动立牌制作</a> @yiwei @廖彬彬</li></ol></li><li><p>🛠️JavaScript 中文兴趣组官网</p></li><li><p>✅<a href="https://github.com/JSCIG/jscig.github.io/pull/15" target="_blank" rel="noopener">合并前端部署的多分支 GitHub actions，并升级上游库，更新公共 CDN</a> @水歌</p></li><li><p>🛠️fCC 成都社区官网（试验版）</p><ol><li>✅<a href="https://github.com/FreeCodeCamp-Chengdu/fcc.chengdu/pull/32" target="_blank" rel="noopener">升级至 React 19、React Chrono 3、PNPM 10、LESS 4 等上游库</a> @水歌</li></ol></li><li><p>🚧fCC 中文社区官网</p><ol><li>✅<a href="https://github.com/freeCodeCamp-China/Web-site/pull/55" target="_blank" rel="noopener">新增课程列表页</a> @水歌 @🤖copilot</li><li>✅<a href="https://github.com/freeCodeCamp-China/Web-site/pull/57" target="_blank" rel="noopener">新增用户详情页</a> @水歌 @🤖copilot</li></ol></li></ol><h2 id="动手训练"><a href="#动手训练" class="headerlink" title="动手训练"></a>动手训练</h2><blockquote><ul><li>周末编程自习室 Workshop 是一个开放式学习空间，适合想提升编程技能的同学自由学习与交流。我们将提供学习指导与项目实践分享，帮助大家巩固知识、解决疑难。</li><li>请自备笔记本电脑，并确保网络连接畅通。</li></ul></blockquote><ol><li>🚧理财入门 PWA @水歌 @dethan3 现场一起用 AI 开发一个<a href="https://github.com/FreeCodeCamp-Chengdu/Wiki/issues/10" target="_blank" rel="noopener">单页理财应用</a></li></ol></body></html>]]></content>
    
    <summary type="html">
    
      面向 Web 前端、全栈、AI 开发者：React 19 升级坑点复盘、GitHub Actions 多分支部署流水线、社区官网性能优化、理财 PWA 现写现跑。
    
    </summary>
    
    
      <category term="Activity" scheme="https://fcc-cd.dev/categories/Activity/"/>
    
      <category term="Workshop" scheme="https://fcc-cd.dev/categories/Activity/Workshop/"/>
    
    
      <category term="online" scheme="https://fcc-cd.dev/tags/online/"/>
    
      <category term="offline" scheme="https://fcc-cd.dev/tags/offline/"/>
    
      <category term="AI" scheme="https://fcc-cd.dev/tags/AI/"/>
    
      <category term="Vibe Coding" scheme="https://fcc-cd.dev/tags/Vibe-Coding/"/>
    
      <category term="理财" scheme="https://fcc-cd.dev/tags/%E7%90%86%E8%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>fCC 成都社区 Coffee &amp; Code 周末编程自习室 2025年10月19日</title>
    <link href="https://fcc-cd.dev/activity/salon/fcc-chengdu-coffee-and-code-2025-10-19/"/>
    <id>https://fcc-cd.dev/activity/salon/fcc-chengdu-coffee-and-code-2025-10-19/</id>
    <published>2025-09-12T10:27:00.000Z</published>
    <updated>2025-11-11T17:23:20.526Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>近一个多月真的是中国人的爱国教育月 —— 九三抗战胜利日、九一八国耻日、十一国庆节。吾等平民百姓虽无力左右宏大叙事，但可以从身边小事做起，用开源代码助力公益事业，为爱国尽绵薄之力！  本期 fCC Coffee &amp; Code 将主要分享【开源市集】社区的【开源公益】计划，同时现场展示、演练如何用 AI agent 加速公益 IT 基础设施的建设。</p><h2 id="活动信息"><a href="#活动信息" class="headerlink" title="活动信息"></a>活动信息</h2><ul><li>时间：2025-10-19 14:00~18:00</li><li>地点：漫咖啡MAAN COFFEE(红唐店)，四川省成都市武侯区天府大道中段中1388号红唐购物中心1层LA104</li><li>人群：编程初学者、开源爱好者、公益志愿者、AI 从业者</li><li>费用：参会免费、餐饮自费</li><li>文档：<a href="https://open-source-bazaar.feishu.cn/wiki/L1UqwHif2i4HBHkbZMpcrAutn6d" target="_blank" rel="noopener">https://open-source-bazaar.feishu.cn/wiki/L1UqwHif2i4HBHkbZMpcrAutn6d</a></li><li>直播：<a href="https://vc.feishu.cn/j/757288816" target="_blank" rel="noopener">https://vc.feishu.cn/j/757288816</a></li><li>群聊：<a href="https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=0dcqe9e3-5f27-4d5d-a30c-0477b64c828b" target="_blank" rel="noopener">https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=0dcqe9e3-5f27-4d5d-a30c-0477b64c828b</a></li></ul><a id="more"></a><h2 id="活动内容"><a href="#活动内容" class="headerlink" title="活动内容"></a>活动内容</h2><ol><li>🤖<a href="https://agents.md/" target="_blank" rel="noopener">AI agent 通用代码库规格文件</a> <a href="https://github.com/TechQuery" target="_blank" rel="noopener">@水歌</a></li><li>🚀<a href="https://open-source-bazaar.feishu.cn/wiki/VGrMwiweVivWrHkTcvpcJTjjnoY" target="_blank" rel="noopener">开源公益</a>计划发布 @水歌 </li><li>🚧<a href="https://open-source-bazaar.feishu.cn/wiki/Ai2jwnAiZi2U8zkKAHqcDEqKnUc" target="_blank" rel="noopener">中国公益数据库 2.0</a><ol><li>测试服导入旧版数据 @水歌 <a href="https://github.com/luojiyin1987" target="_blank" rel="noopener">@罗基印</a></li><li><a href="https://bazaar.fcc-cd.dev/NGO" target="_blank" rel="noopener">前端页面</a>接入测试服 @水歌</li></ol></li><li>🛠️新冠抗疫信息平台<ol><li>后端基于 SQL ORM + Docker 重构 @水歌</li><li>前端基于 EChart-JSX 1.x 精简、优化 @水歌</li></ol></li><li>🚧开源市集官网<ol><li><a href="https://bazaar.fcc-cd.dev/recipe" target="_blank" rel="noopener">老乡鸡开源菜谱知识库</a> @水歌 </li></ol></li><li>🛠️<a href="https://open-source-bazaar.feishu.cn/wiki/IbW6w9TXmiuntDkGL5Ic5Nq0nPe" target="_blank" rel="noopener">开源镜像站</a><ol><li><a href="https://polyfill.web-conf.dev/" target="_blank" rel="noopener">Web polyfill 中国大陆备份镜像</a>由 fCC 成都社区接管 @水歌</li></ol></li><li>💻结对编程</li></ol></body></html>]]></content>
    
    <summary type="html">
    
      近一个多月真的是中国人的爱国教育月 —— 九三抗战胜利日、九一八国耻日、十一国庆节。吾等平民百姓虽无力左右宏大叙事，但可以从身边小事做起，用开源代码助力公益事业，为爱国尽绵薄之力！  本期 fCC Coffee &amp; Code 将主要分享【开源市集】社区的【开源公益】计划，同时现场展示、演练如何用 AI agent 加速公益 IT 基础设施的建设。
    
    </summary>
    
    
      <category term="Activity" scheme="https://fcc-cd.dev/categories/Activity/"/>
    
      <category term="Salon" scheme="https://fcc-cd.dev/categories/Activity/Salon/"/>
    
    
      <category term="开源" scheme="https://fcc-cd.dev/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="online" scheme="https://fcc-cd.dev/tags/online/"/>
    
      <category term="offline" scheme="https://fcc-cd.dev/tags/offline/"/>
    
      <category term="NGO" scheme="https://fcc-cd.dev/tags/NGO/"/>
    
      <category term="结对编程" scheme="https://fcc-cd.dev/tags/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AI" scheme="https://fcc-cd.dev/tags/AI/"/>
    
      <category term="copilot" scheme="https://fcc-cd.dev/tags/copilot/"/>
    
  </entry>
  
  <entry>
    <title>fCC 成都社区 Coffee &amp; Code 周末编程自习室 2025年9月7日</title>
    <link href="https://fcc-cd.dev/activity/salon/fcc-chengdu-coffee-and-code-2025-09-07/"/>
    <id>https://fcc-cd.dev/activity/salon/fcc-chengdu-coffee-and-code-2025-09-07/</id>
    <published>2025-08-24T02:34:00.000Z</published>
    <updated>2025-11-11T17:23:20.526Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>9 月开学季，恰逢大阅兵，fCC 成都社区邀您一同探讨 AI MCP 编程技巧、飞书建站方案。用代码致敬开源精神，让技术如阅兵般整齐有力！</p><h2 id="活动信息"><a href="#活动信息" class="headerlink" title="活动信息"></a>活动信息</h2><ul><li>时间：2025-09-07 14:00~18:00</li><li>地点：漫咖啡 MAAN COFFEE(红唐店)，四川省成都市武侯区天府大道中段中 1388 号红唐购物中心 1 层 LA104</li><li>人群：编程初学者、开源爱好者、AI 从业者</li><li>费用：参会免费、餐饮自费</li><li>文档：<a href="https://open-source-bazaar.feishu.cn/wiki/O7d7wTOJZiVbc6k8h0YcInu9nkg" target="_blank" rel="noopener">https://open-source-bazaar.feishu.cn/wiki/O7d7wTOJZiVbc6k8h0YcInu9nkg</a></li><li>直播：<a href="https://vc.feishu.cn/j/154339918" target="_blank" rel="noopener">https://vc.feishu.cn/j/154339918</a></li><li>群聊：<a href="https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=0dcqe9e3-5f27-4d5d-a30c-0477b64c828b" target="_blank" rel="noopener">https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=0dcqe9e3-5f27-4d5d-a30c-0477b64c828b</a></li></ul><a id="more"></a><h2 id="活动内容"><a href="#活动内容" class="headerlink" title="活动内容"></a>活动内容</h2><ol><li><p>💡Python 中文社区【开源松】<a href="https://github.com/TechQuery" target="_blank" rel="noopener">@TechQuery</a></p><ul><li><a href="https://codekitchen.community/t/topic/1095" target="_blank" rel="noopener">https://codekitchen.community/t/topic/1095</a></li><li><a href="https://codekitchen.community/c/song/l/latest?board=default" target="_blank" rel="noopener">https://codekitchen.community/c/song/l/latest?board=default</a></li></ul></li><li><p>🛠️<a href="https://vxkeohee2mi.feishu.cn/wiki/L2S6w1kI6ifQsxky9pWcEJI3nJe" target="_blank" rel="noopener">Claude Code 在开发中的使用</a> <a href="https://github.com/hu-qi" target="_blank" rel="noopener">@hu-qi</a></p><blockquote><p>从早期对 Claude Code 的偏见到现在开发中离不开 Claude Code ，我究竟经历了什么？</p></blockquote></li><li><p>🚀<a href="https://idea2app.feishu.cn/wiki/RsCvwrpXPimCpRkjpsAcWl2rnJd" target="_blank" rel="noopener">组织智能化转型之 idea2app 飞书方案</a> @TechQuery</p><blockquote><p>结合<a href="https://bazaar.fcc-cd.dev/" target="_blank" rel="noopener">开源市集</a>官网、<a href="https://open-source-bazaar.feishu.cn/wiki/KWYyw9fiCiKrO1ksDR6cjum6npd" target="_blank" rel="noopener">开放会务系统</a>、<a href="https://open-source-bazaar.feishu.cn/wiki/NSthwlAnzikmOHkToj4cP6HznQb" target="_blank" rel="noopener">开放治理系统</a>等的开源代码更新，讲解如何利用飞书低成本、低代码地建设公益组织、中小企业的 IT 基础设施。</p></blockquote></li><li><p>💻 结对编程</p><ol><li><a href="https://github.com/FreeCodeCamp-Chengdu" target="_blank" rel="noopener">https://github.com/FreeCodeCamp-Chengdu</a></li><li><a href="https://github.com/Open-Source-Bazaar" target="_blank" rel="noopener">https://github.com/Open-Source-Bazaar</a></li></ol></li></ol></body></html>]]></content>
    
    <summary type="html">
    
      9月开学季，恰逢大阅兵，fCC成都社区邀您一同探讨 AI MCP 编程技巧、飞书建站方案。用代码致敬开源精神，让技术如阅兵般整齐有力！
    
    </summary>
    
    
      <category term="Activity" scheme="https://fcc-cd.dev/categories/Activity/"/>
    
      <category term="Salon" scheme="https://fcc-cd.dev/categories/Activity/Salon/"/>
    
    
      <category term="开源" scheme="https://fcc-cd.dev/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="online" scheme="https://fcc-cd.dev/tags/online/"/>
    
      <category term="offline" scheme="https://fcc-cd.dev/tags/offline/"/>
    
      <category term="结对编程" scheme="https://fcc-cd.dev/tags/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AI" scheme="https://fcc-cd.dev/tags/AI/"/>
    
      <category term="copilot" scheme="https://fcc-cd.dev/tags/copilot/"/>
    
  </entry>
  
  <entry>
    <title>fCC 成都社区 Coffee &amp; Code 周末编程自习室 2025年8月24日</title>
    <link href="https://fcc-cd.dev/activity/salon/fcc-chengdu-coffee-and-code-2025-08-24/"/>
    <id>https://fcc-cd.dev/activity/salon/fcc-chengdu-coffee-and-code-2025-08-24/</id>
    <published>2025-08-19T16:00:00.000Z</published>
    <updated>2025-11-11T17:23:20.526Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>七夕节又要到了，fCC 成都社区的小伙伴将分享自己”用 AI 耗电“的 AI 开源应用开发经验，用实战让大家体会 —— AI 让人回归”做爱做的事“本身~</p><h2 id="活动信息"><a href="#活动信息" class="headerlink" title="活动信息"></a>活动信息</h2><ul><li>时间：2025-08-24 14:00~18:00</li><li>地点：漫咖啡 MAAN COFFEE(红唐店)，四川省成都市武侯区天府大道中段中 1388 号红唐购物中心 1 层 LA104</li><li>人群：编程初学者、开源爱好者、AI 从业者</li><li>费用：参会免费、餐饮自费</li><li>文档： <a href="https://open-source-bazaar.feishu.cn/wiki/DwnvwaAyWidJDakTUiecH8mDnEh" target="_blank" rel="noopener">https://open-source-bazaar.feishu.cn/wiki/DwnvwaAyWidJDakTUiecH8mDnEh</a></li><li>直播: <a href="https://vc.feishu.cn/j/482033714" target="_blank" rel="noopener">https://vc.feishu.cn/j/482033714</a></li><li>群聊: <a href="https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=0dcqe9e3-5f27-4d5d-a30c-0477b64c828b" target="_blank" rel="noopener">https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=0dcqe9e3-5f27-4d5d-a30c-0477b64c828b</a></li></ul><a id="more"></a><h2 id="活动内容"><a href="#活动内容" class="headerlink" title="活动内容"></a>活动内容</h2><ol><li>🦉 新项目发布：Tickeye - 轻量股指监测工具<ol><li>🚨 每天在股市下跌的警报中起床 <a href="https://github.com/dethan3" target="_blank" rel="noopener">@dethan3</a><blockquote><p><a href="https://github.com/dethan3/tickeye" target="_blank" rel="noopener">https://github.com/dethan3/tickeye</a><br>Tickeye 是一款轻量的全球市场指数监控工具，灵感来自 fCC 成都社区深夜自习室。有了想法之后，说干就干，用最传统的 AI 编辑器一个晚上就有了原型，之后又断断续续优化了两周，才成了现在的模样。过程中几乎处处有 AI 的影子，连飞书开放平台也有 AI 助手给方案，算是一次挺有趣的探索，也是我的第一款 Vibe Coding 产品。<br>技术栈：Python + <a href="https://akshare.akfamily.xyz/" target="_blank" rel="noopener">AKShare API</a></p></blockquote></li><li><a href="https://vxkeohee2mi.feishu.cn/wiki/GiPdwzl9qii1uvkUaHHcmBOAnif" target="_blank" rel="noopener">从部署 Tickeye 窥见 Vibe Coding</a> <a href="https://github.com/hu-qi" target="_blank" rel="noopener">@hu-qi</a><blockquote><p>以 Github Action 定时执行会延迟的“痛点”作为切入点，从 Python 部署遇到依赖包困境，到探索 Docker 容器化部署的 Serverless 技术实践过程，梳理 Vibe Coding 在实际开发中的应用价值。</p></blockquote></li></ol></li><li>🚀<a href="https://open-source-bazaar.feishu.cn/wiki/KWYyw9fiCiKrO1ksDR6cjum6npd" target="_blank" rel="noopener">开放会务系统</a>（全栈开源版）开发重启 <a href="https://github.com/TechQuery" target="_blank" rel="noopener">@TechQuery</a><blockquote><p>@TechQuery 基于 GitHub copilot agent 用 6 天写完了开源社 6 年写不完的前端代码。</p></blockquote></li><li>💻 结对编程<ol><li><a href="https://github.com/FreeCodeCamp-Chengdu" target="_blank" rel="noopener">https://github.com/FreeCodeCamp-Chengdu</a></li><li><a href="https://github.com/Open-Source-Bazaar" target="_blank" rel="noopener">https://github.com/Open-Source-Bazaar</a></li></ol></li></ol></body></html>]]></content>
    
    <summary type="html">
    
      七夕节又要到了，fCC 成都社区的小伙伴将分享自己”用 AI 耗电“的 AI 开源应用开发经验，用实战让大家体会 —— AI 让人回归”做爱做的事“本身~
    
    </summary>
    
    
      <category term="Activity" scheme="https://fcc-cd.dev/categories/Activity/"/>
    
      <category term="Salon" scheme="https://fcc-cd.dev/categories/Activity/Salon/"/>
    
    
      <category term="开源" scheme="https://fcc-cd.dev/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="online" scheme="https://fcc-cd.dev/tags/online/"/>
    
      <category term="offline" scheme="https://fcc-cd.dev/tags/offline/"/>
    
      <category term="结对编程" scheme="https://fcc-cd.dev/tags/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AI" scheme="https://fcc-cd.dev/tags/AI/"/>
    
      <category term="copilot" scheme="https://fcc-cd.dev/tags/copilot/"/>
    
  </entry>
  
  <entry>
    <title>fCC Coffee &amp; Code 周末编程自习室 2025年8月3日</title>
    <link href="https://fcc-cd.dev/activity/salon/20250803-coffee-code/"/>
    <id>https://fcc-cd.dev/activity/salon/20250803-coffee-code/</id>
    <published>2025-08-02T16:00:00.000Z</published>
    <updated>2025-11-11T17:23:20.418Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>还在一个人对着屏幕写代码吗？本周末，来和 fCC 成都社区的伙伴们一起结对编程吧！无论你是编程初学者、进阶学习者还是开发者，都能在这里找到志同道合的小伙伴。</p><p>这一次，我们希望带你体验更真实、更有温度的编程学习方式：</p><ul><li><strong>自由结对</strong>：随机或自选伙伴，一起挑战小任务，交流彼此的思路。</li><li><strong>项目共创</strong>：社区开放项目现场对接，想加入团队实战的朋友千万别错过。</li><li><strong>问题速解</strong>：不会写？卡 Bug？这里有经验丰富的社区伙伴可以帮你出招。</li><li><strong>灵感碰撞</strong>：比起独自写代码，和人聊聊需求、架构、实现，往往更有启发！</li></ul><blockquote><p>活动依旧 <strong>免费参加，饮品自费</strong>。无需准备复杂议题，带着问题或小目标来就好～</p></blockquote><h2 id="📍-活动信息"><a href="#📍-活动信息" class="headerlink" title="📍 活动信息"></a>📍 活动信息</h2><ul><li><strong>时间</strong>：2025 年 8 月 3 日（周日）14:00 - 18:00</li><li><strong>地点</strong>：漫咖啡MAAN COFFEE(红唐店) - 成都市武侯区天府大道中段中1388号红唐购物中心1层LA104</li><li><strong>直播</strong>：<a href="https://vc.feishu.cn/j/755910722" target="_blank" rel="noopener">https://vc.feishu.cn/j/755910722</a></li><li><strong>人群</strong>：编程初学者、爱好者、从业者</li><li><strong>文档</strong>：<a href="https://open-source-bazaar.feishu.cn/wiki/MYXWwYdfRiLhSfkdS9ocdE86n48" target="_blank" rel="noopener">fCC 成都社区 Coffee &amp; Code 周末编程自习室 2025年8月3日</a></li><li><strong>费用</strong>：活动免费、饮品自费</li><li><strong>装备</strong>：自备电脑</li></ul><h2 id="📚-主要内容"><a href="#📚-主要内容" class="headerlink" title="📚 主要内容"></a>📚 主要内容</h2><ol><li><p>开源市集项目进展分享</p><ul><li>中国公益数据库 2.0</li><li>fCC 成都社区官网（2025版）</li><li>开源市集官网</li><li><a href="https://open-source-bazaar.feishu.cn/wiki/KWYyw9fiCiKrO1ksDR6cjum6npd" target="_blank" rel="noopener">开放会务系统</a></li><li><a href="https://open-source-bazaar.feishu.cn/wiki/RCTxw8GATijLEGkCmuvcOXQwnbb" target="_blank" rel="noopener">黑客松开放平台 HOP</a></li></ul></li><li><p>Coffee &amp; Code 结对编程体验</p><h2 id="为什么要来？"><a href="#为什么要来？" class="headerlink" title="为什么要来？"></a>为什么要来？</h2></li></ol><ul><li>找到志同道合的学习伙伴，避免单打独斗</li><li>用结对方式更高效地完成学习或开发任务</li><li>接触社区真实项目，参与开源，提升实战经验</li><li>发现灵感、拓展人脉，轻松高效度过周末</li></ul><p>无论你是想完成自己的学习计划，还是想在真实场景下提升技术，带上电脑，加入我们，一起分享知识、输出代码、结识朋友！</p></body></html>]]></content>
    
    <summary type="html">
    
      无论你是编程初学者还是有经验的开发者，都欢迎加入 Coffee &amp; Code 【周末编程自习室】
    
    </summary>
    
    
      <category term="Activity" scheme="https://fcc-cd.dev/categories/Activity/"/>
    
      <category term="Salon" scheme="https://fcc-cd.dev/categories/Activity/Salon/"/>
    
    
      <category term="online" scheme="https://fcc-cd.dev/tags/online/"/>
    
      <category term="offline" scheme="https://fcc-cd.dev/tags/offline/"/>
    
      <category term="Coffee&amp;Code" scheme="https://fcc-cd.dev/tags/Coffee-Code/"/>
    
      <category term="成都" scheme="https://fcc-cd.dev/tags/%E6%88%90%E9%83%BD/"/>
    
      <category term="NGO" scheme="https://fcc-cd.dev/tags/NGO/"/>
    
      <category term="公益" scheme="https://fcc-cd.dev/tags/%E5%85%AC%E7%9B%8A/"/>
    
      <category term="官网" scheme="https://fcc-cd.dev/tags/%E5%AE%98%E7%BD%91/"/>
    
      <category term="会务" scheme="https://fcc-cd.dev/tags/%E4%BC%9A%E5%8A%A1/"/>
    
      <category term="结对编程" scheme="https://fcc-cd.dev/tags/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>fCC Coffee &amp; Code 周末编程自习室 2025-07-13</title>
    <link href="https://fcc-cd.dev/activity/workshop/fcc-coffee-and-code-2025-07-13/"/>
    <id>https://fcc-cd.dev/activity/workshop/fcc-coffee-and-code-2025-07-13/</id>
    <published>2025-07-11T18:43:00.000Z</published>
    <updated>2025-11-11T17:23:20.715Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>fCC 成都社区上次以 <a href="https://www.freecodecamp.org/news/jump-start-your-local-campsite-with-coffee-and-code-a8d1a57d30e/" target="_blank" rel="noopener">Coffee &amp; Code</a> 命名的活动还是 2019 年 3 月 30 日的<a href="https://fcc-cd.dev/activity/salon/start-functional-programming/">《走进函数式编程》</a>活动，近 6 年半后，我<a href="https://github.com/TechQuery" target="_blank" rel="noopener">水歌</a>这个 6 年半三度接任 fCC 成都社区主理人的开源老将，在大家对“轻松的日常小活动”的期待中，重启这个 freeCodeCamp.org 最早、最经典的活动品牌。</p><p>同时，我将组织者闯闯提出的【<a href="https://open-source-bazaar.feishu.cn/docx/Fhxod3nHFoaEmMxJfPbc6YQUnxb" target="_blank" rel="noopener">周末编程自习室</a>】作为它的中文名，再通过<a href="https://www.feishu.cn/" target="_blank" rel="noopener">飞书</a>视频会议的方式兼容线上线下的参与者，让所有学习编程、从事编程的人都能感受到编程的快乐！</p><p><img src="https://pbs.twimg.com/media/FyF57huWAAAt4lA?format=jpg&amp;name=medium" alt="I turn Coffee into Code"></p><a id="more"></a><h2 id="📍-参会信息"><a href="#📍-参会信息" class="headerlink" title="📍 参会信息"></a>📍 参会信息</h2><ul><li>时间：2025年7月13日（周日）14:00 - 18:00</li><li>地点：成都市高新区天府五街红唐商城一层星巴克咖啡</li><li>直播：<a href="https://vc.feishu.cn/j/704264950" target="_blank" rel="noopener">https://vc.feishu.cn/j/704264950</a></li><li>人群：编程初学者、爱好者、从业者</li><li>文档：<a href="https://open-source-bazaar.feishu.cn/wiki/TTPvwJhpni1OGqknc7CcxWvTnCd" target="_blank" rel="noopener">https://open-source-bazaar.feishu.cn/wiki/TTPvwJhpni1OGqknc7CcxWvTnCd</a></li><li>费用：活动免费、饮品自费</li><li>装备：自备笔记本/平板电脑</li></ul><h2 id="📚-主要内容"><a href="#📚-主要内容" class="headerlink" title="📚 主要内容"></a>📚 主要内容</h2><ol><li>fCC 成都社区【<a href="https://open-source-bazaar.feishu.cn/wiki/RCTxw8GATijLEGkCmuvcOXQwnbb" target="_blank" rel="noopener">黑客松开放平台</a> 2.0】重启官宣</li><li><a href="https://open-source-bazaar.feishu.cn/wiki/QOfEwwRryiP9DRkNc3xcRRFwnfd" target="_blank" rel="noopener">【开源市集】行动落地</a>进展分享</li><li>社区自有项目阶段路演<ol><li>黑客松开放平台 HOP</li><li><a href="https://bazaar.fcc-cd.dev/" target="_blank" rel="noopener">开源市集官网</a></li><li><a href="https://fcc-cd.dev/">fCC 成都社区官网</a>（2025 版）</li><li><a href="https://open-source-bazaar.feishu.cn/wiki/ENjWwRT4piwDxwkjQOcc81xDnfc" target="_blank" rel="noopener">fCC 成都社区图书馆</a> - Open Library</li></ol></li><li>自由结对编程</li></ol><h2 id="📋-协作文档"><a href="#📋-协作文档" class="headerlink" title="📋 协作文档"></a>📋 协作文档</h2><iframe style="border: 0; width: 100%; height: 90vh" src="https://open-source-bazaar.feishu.cn/wiki/TTPvwJhpni1OGqknc7CcxWvTnCd"></iframe></body></html>]]></content>
    
    <summary type="html">
    
      fCC Coffee &amp; Code 在成都社区时隔 6 年半的重启
    
    </summary>
    
    
      <category term="Activity" scheme="https://fcc-cd.dev/categories/Activity/"/>
    
      <category term="Workshop" scheme="https://fcc-cd.dev/categories/Activity/Workshop/"/>
    
    
      <category term="online" scheme="https://fcc-cd.dev/tags/online/"/>
    
      <category term="offline" scheme="https://fcc-cd.dev/tags/offline/"/>
    
      <category term="结对编程" scheme="https://fcc-cd.dev/tags/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B/"/>
    
      <category term="黑客松" scheme="https://fcc-cd.dev/tags/%E9%BB%91%E5%AE%A2%E6%9D%BE/"/>
    
      <category term="开源市集" scheme="https://fcc-cd.dev/tags/%E5%BC%80%E6%BA%90%E5%B8%82%E9%9B%86/"/>
    
      <category term="图书馆" scheme="https://fcc-cd.dev/tags/%E5%9B%BE%E4%B9%A6%E9%A6%86/"/>
    
  </entry>
  
  <entry>
    <title>【fCC成都社区技术分享活动】</title>
    <link href="https://fcc-cd.dev/activity/workshop/ai-javascript-events/"/>
    <id>https://fcc-cd.dev/activity/workshop/ai-javascript-events/</id>
    <published>2025-03-08T06:40:00.000Z</published>
    <updated>2025-11-11T17:23:20.600Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><ul><li>费用：免费</li><li>设备：​自带电脑</li><li>参与方式：线下为主，线上为辅</li></ul><h2 id="活动日程"><a href="#活动日程" class="headerlink" title="活动日程"></a>活动日程</h2><table><thead><tr><th align="center">时间</th><th align="center">内容</th><th align="center">讲师</th></tr></thead><tbody><tr><td align="center">14:00-14:30</td><td align="center">签到</td><td align="center"></td></tr><tr><td align="center">14:30-14:40</td><td align="center">自我介绍</td><td align="center"></td></tr><tr><td align="center">14:40-15:30</td><td align="center">JavaScript 栈溢出的底层原理</td><td align="center">彭雪梅- 资深前端工程师</td></tr><tr><td align="center">15:40-16:20</td><td align="center">AI 时代开发者的突围与重构·聊聊技术、产品、商业</td><td align="center">Ironben - 开源智能助手 <a href="https://5ire.app/" target="_blank" rel="noopener">5ire.app</a> 作者、<a href="https://www.essay.ink/" target="_blank" rel="noopener">Essay.ink</a> 文字社区主理人、饺子科技产品领航员</td></tr><tr><td align="center">16:30-18:00</td><td align="center">结对编程-现场有预设主题或自行选择编程主题</td><td align="center"></td></tr><tr><td align="center">17:30-18:00</td><td align="center">展示成果并分析心得、疑问解答</td><td align="center"></td></tr></tbody></table></body></html>]]></content>
    
    <summary type="html">
    
      提升编程实操技能-增强团队协作能力-实战演练-行业专家指导-建立专业链接-轻松愉快的氛围
    
    </summary>
    
    
      <category term="Activity" scheme="https://fcc-cd.dev/categories/Activity/"/>
    
      <category term="Workshop" scheme="https://fcc-cd.dev/categories/Activity/Workshop/"/>
    
    
      <category term="online" scheme="https://fcc-cd.dev/tags/online/"/>
    
      <category term="offline" scheme="https://fcc-cd.dev/tags/offline/"/>
    
      <category term="结对编程" scheme="https://fcc-cd.dev/tags/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B/"/>
    
      <category term="JavaScript" scheme="https://fcc-cd.dev/tags/JavaScript/"/>
    
      <category term="AI" scheme="https://fcc-cd.dev/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>fCC开源技术分享活动回顾</title>
    <link href="https://fcc-cd.dev/article/summary/ai-deno-scaffold-event/"/>
    <id>https://fcc-cd.dev/article/summary/ai-deno-scaffold-event/</id>
    <published>2025-03-05T06:30:00.000Z</published>
    <updated>2025-11-11T17:23:20.775Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>2025 年 3 月 1 日周六下午由 fCC 成都社区举办的开源技术分享活动在成都市天府五街 200 号菁蓉汇 2A 栋 5 层炎上台成功举办。</p><p><strong>软件工程师会被AI替代吗？</strong><br><img src="https://github.com/user-attachments/assets/4c65246f-43f4-4efe-92a1-df1274a95f81" alt="Image"></p><p>资深前端工程师彭雪梅就“软件工程师是否会被AI替代”这一话题进行了分享。首先从AI工具的实现步骤入手，将其分为三个阶段：预训练、后训练和强化学习，并结合理论与实操详细讲解了每个阶段的用途和作用。随后，分析了当前软件工程师的市场现状，将其划分为三个层级：能够实现基本功能、能够适当考虑性能和框架优化、以及能够结合业务需求搭建框架并提供解决方案。最后，结合AI工具的实现步骤与软件工程师的现状，探讨了软件工程师是否会被AI替代的可能性。分享结束后，与参与者围绕这一话题展开了讨论，各自表达了不同的观点和见解。分享链接：<a href="https://mp.weixin.qq.com/s/Y5BgpdIqoXUaybUjYycF5g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Y5BgpdIqoXUaybUjYycF5g</a></p><p><strong>手搓一个Deno脚手架</strong><br><img src="https://github.com/user-attachments/assets/f8b4219c-349f-4ba6-aac8-150c745a0630" alt="Image"></p><p>idea2app 公司的创始人、fCC 成都社区主理事、TS 全栈开发工程师 水歌分享了怎么手搓一个Deno脚手架 ，首先介绍了Deno的用途及其当前的发展现状，随后详细分享了自己搭建Deno脚手架的具体步骤和过程，包括在搭建过程中遇到的问题以及相应的解决方案。接着，带领参与者进行实操，帮助大家更好地理解Deno。分享结束后，与参与者共同探讨了目前Bun、Deno和Node.js各自的优势，并对三者进行了对比分析。Deno脚手架地址：<a href="https://github.com/idea2app/Deno-quick-start/tree/main" target="_blank" rel="noopener">https://github.com/idea2app/Deno-quick-start/tree/main</a></p><p>在活动的结对编程环节调整为自由交流环节后，参与者们展开了轻松愉快的讨论。大家围绕旅游、编程等话题畅所欲言，分享各自的经历和见解。整个交流过程充满了欢声笑语，大家在轻松的氛围中度过了愉快的半小时。</p><p>开源技术分享活动作为对技术爱好者提供一个互动交流的学习平台，通过主题分享加理论实践，增强参与者的实操技能，促进知识共享与技能提升。</p><p>本次活动圆满结束，感谢所有参与者的积极参与和赞助商的支持。</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;2025 年 3 月 1 
      
    
    </summary>
    
    
      <category term="Article" scheme="https://fcc-cd.dev/categories/Article/"/>
    
      <category term="Summary" scheme="https://fcc-cd.dev/categories/Article/Summary/"/>
    
    
      <category term="Deno" scheme="https://fcc-cd.dev/tags/Deno/"/>
    
      <category term="AI" scheme="https://fcc-cd.dev/tags/AI/"/>
    
      <category term="脚手架" scheme="https://fcc-cd.dev/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>fCC开源技术分享活动·AI主题分享·脚手架现场实操</title>
    <link href="https://fcc-cd.dev/activity/workshop/ai-deno-scaffold/"/>
    <id>https://fcc-cd.dev/activity/workshop/ai-deno-scaffold/</id>
    <published>2025-02-24T03:00:00.000Z</published>
    <updated>2025-11-11T17:23:20.715Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p><img src="https://github.com/user-attachments/assets/baed6884-756d-4e32-9cdc-a1097d3710f5" alt="Image"></p><p>我们不给活动设定预期，比如规模要多大或者邀请多少人加入，我们希望通过真诚且有温度的表达，为自己、也为更多人营造一个轻松愉快的编程氛围，通过实战演练提升各自的编程技能、结对编程提升团队协作能力，让我们共同进步，抵达各自的彼岸。</p></body></html>]]></content>
    
    <summary type="html">
    
      提升编程实操技能、增强团队协作能力、实战演练、行业专家指导、建立专业网络、轻松愉快的氛围
    
    </summary>
    
    
      <category term="Activity" scheme="https://fcc-cd.dev/categories/Activity/"/>
    
      <category term="Workshop" scheme="https://fcc-cd.dev/categories/Activity/Workshop/"/>
    
    
      <category term="offline" scheme="https://fcc-cd.dev/tags/offline/"/>
    
      <category term="Deno" scheme="https://fcc-cd.dev/tags/Deno/"/>
    
      <category term="AI" scheme="https://fcc-cd.dev/tags/AI/"/>
    
      <category term="脚手架" scheme="https://fcc-cd.dev/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>理解容器镜像层</title>
    <link href="https://fcc-cd.dev/article/translation/understanding-container-image-layers/"/>
    <id>https://fcc-cd.dev/article/translation/understanding-container-image-layers/</id>
    <published>2024-06-26T19:12:52.216Z</published>
    <updated>2025-11-11T17:23:20.883Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>容器非常了不起。它们允许简单的进程像虚拟机一样运行。这种优雅的背后是一套模式和实践，最终使一切都能正常工作。设计的根源在于<em>层</em>。层是存储和分发容器化文件系统内容的基本方式。这种设计既非常简单，同时又非常强大。在今天的文章中，我将解释什么是层，以及它们在概念上是如何工作的。</p><a id="more"></a><h2 id="构建分层镜像"><a href="#构建分层镜像" class="headerlink" title="构建分层镜像"></a>构建分层镜像</h2><p>当你创建一个镜像时，你通常会使用一个 <code>Dockerfile</code> 来定义容器的内容。它包含一系列命令，例如：</p><pre class=" language-dockerfile"><code class="language-dockerfile">FROM scratchRUN echo "hello" &gt; /work/message.txtCOPY content.txt /work/content.txtRUN rm -rf /work/message.txt</code></pre><p>在底层，容器引擎会按顺序执行这些命令，为每个命令创建一个“层”。 但这究竟是如何实现的呢？ 最简单的理解方式是将每一层都视为一个目录，其中包含所有已修改的文件。</p><p>让我们通过一个可能的实现方法的例子来逐步解释。</p><ol><li><code>FROM scratch</code> 表示此容器从零内容开始。 这是第一层，它可以用一个空目录 <code>/img/layer1</code> 来表示。</li><li>创建一个第二个目录 <code>/img/layer2</code> 并将 <code>/img/layer1</code> 中的所有内容复制到其中。 然后，执行 Dockerfile 中的下一条命令（将一个文件写入 <code>/work/message.txt</code>）。 这些内容被写入 <code>/img/layer2/work/message.txt</code>。 这是第二层。</li><li>创建一个第三个目录 <code>/img/layer3</code>，将 <code>img/layer2</code> 中的所有内容复制到其中。 下一个 Dockerfile 命令需要将主机的 <code>content.txt</code> 复制到该目录。 该文件被写入 <code>/img/layer3/work/content.txt</code>。 这是第三层。</li><li>最后，创建一个第四个目录 <code>/img/layer4</code>，将 <code>img/layer3</code> 中的所有内容复制到其中。 下一条命令删除消息文件 <code>img/layer4/work/message.txt</code>。 这是第四层。</li></ol><p>为了共享这些层，最简单的方法是为每个目录创建一个压缩的 <code>.tar.gz</code> 文件。为了减小总文件大小，任何未经修改、只是从上一层复制的文件都会被删除。为了明确何时删除了文件，可以使用 <code>whiteout 文件</code> 作为占位符。该文件只需在原始文件名前加上前缀 <code>.wh.</code>。例如，第四层会将删除的文件替换为名为 <code>.wh.message.txt</code> 的占位符。当一个层被解包时，任何以 <code>.wh.</code> 开头的文件都可以被删除。</p><p>继续我们的例子，压缩文件将包含：</p><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td><code>layer1.tar.gz</code></td><td>空文件</td></tr><tr><td><code>layer2.tar.gz</code></td><td>包含 <code>/work/message.txt</code></td></tr><tr><td><code>layer3.tar.gz</code></td><td>包含 <code>/work/content.txt</code> （因为 <code>message.txt</code> 文件没有修改）</td></tr><tr><td><code>layer4.tar.gz</code></td><td>包含 <code>/work/.wh.message.txt</code> （因为 <code>message.txt</code> 删除了）</td></tr><tr><td>文件 <code>content.txt</code> 没有被修改，所以没有被包含在内。</td><td></td></tr></tbody></table><p>以这种方式构建大量镜像会导致大量的 <code>layer1</code> 目录。为了确保名称的唯一性，压缩文件的命名基于内容的摘要。这类似于 Git 的工作方式。它的好处是在识别文件下载过程中任何损坏的同时，还能识别相同的内容。如果内容的摘要（哈希值）与文件名不匹配，则文件已损坏。</p><p>为了使结果可重复，还需要一个文件来解释如何对层进行排序（清单）。清单会标识要下载哪些文件以及解包它们的顺序。这使得能够重新创建目录结构。它还提供了一个重要的好处：层可以在镜像之间重复使用和共享。这最大限度地减少了本地存储需求。</p><p>在实践中，还有更多可用的优化。例如，<code>FROM scratch</code> 实际上意味着没有父层，所以我们的示例实际上是从 <code>layer2</code> 的内容开始的。引擎还可以查看构建中使用的文件，以确定是否需要重新创建层。这是层缓存的基础，它最大限度地减少了构建或重新创建层的需要。作为额外的优化，不依赖于前一层的层可以使用 <code>COPY --link</code> 来指示该层不需要删除或修改前一层中的任何文件。这允许压缩层文件与其他步骤并行创建。</p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>在容器可以运行之前，它需要一个文件系统来挂载。本质上，它需要一个包含所有需要可用的文件的目录。压缩的层文件包含文件系统的组件，但它们不能直接挂载和使用。相反，它们需要被解包并组织成一个文件系统。这个解包后的目录被称为<em>快照</em>（好吧，它是具有该名称的几样东西之一 😄）。</p><p>创建快照的过程与镜像构建相反。它首先下载清单并构建要下载的层列表。对于每一层，都会创建一个包含该层父层内容的目录。此目录称为<em>活动快照</em>。接下来，<em>差异应用器</em>负责解压缩压缩的层文件并将更改应用于活动快照。然后，生成的目录称为<em>已提交快照</em>。最终提交的快照是作为容器文件系统挂载的快照。</p><p>使用我们之前的例子：</p><ol><li>初始层 <code>FROM scratch</code> 意味着我们可以从下一层和一个空目录开始。没有父层。</li><li>创建一个 <code>layer2</code> 的目录。这个空目录现在是一个活动快照。下载文件 <code>layer2.tar.gz</code>，验证（通过将摘要与文件名进行比较），并解压缩到目录中。结果是一个包含 <code>/work/message.txt</code> 的目录。这是第一个提交的快照。</li><li>创建一个 <code>layer3</code> 的目录，并将 <code>layer2</code> 的内容复制到其中。这是一个新的活动快照。下载文件 <code>layer3.tar.gz</code>，验证并解压缩。结果是一个包含 <code>/work/message.txt</code> 和 <code>/work/content.txt</code> 的目录。这是第二个提交的快照。</li><li>创建一个 <code>layer4</code> 的目录，并将 <code>layer3</code> 的内容复制到其中。下载文件 <code>layer4.tar.gz</code>，验证并解压缩。差异应用器识别出删除文件 <code>/work/.wh.message.txt</code>，并删除 <code>/work/message.txt</code>。只剩下 <code>/work/content.txt</code>。这是第三个提交的快照。</li><li>由于 <code>layer4</code> 是最后一层，因此它是容器的基础。为了使其支持读写操作，会创建一个新的快照目录，并将 <code>layer4</code> 的内容复制到其中。此目录作为容器的文件系统挂载。运行中的容器所做的任何更改都将发生在此目录中。</li></ol><p>如果这些目录中的任何一个已经存在，则表明另一个镜像具有相同的依赖项。因此，引擎可以跳过下载和差异应用器。它可以按原样使用该层。在实践中，这些目录和文件中的每一个都根据内容的摘要进行命名，以便更容易识别。例如，一组快照可能如下所示：</p><pre class=" language-text"><code class="language-text">1/var/path/to/snapshots/blobs2└─ sha2563   ├─ 635944d2044d0a54d01385271ebe96ec18b26791eb8b85790974da36a452cc5c4   ├─ 9de59f6b211510bd59d745a5e49d7aa0db263deedc822005ed388f8d55227fc15   ├─ fb0624e7b7cb9c912f952dd30833fb2fe1109ffdbcc80d995781f47bd1b4017f6   └─ fb124ec4f943662ecf7aac45a43b096d316f1a6833548ec802226c7b406154e9</code></pre><p>或者，换句话说:</p><table><thead><tr><th>镜像</th><th>父镜像</th></tr></thead><tbody><tr><td>sha256:635944d2044d0a54d01385271ebe96ec18b26791eb8b85790974da36a452cc5c</td><td></td></tr><tr><td>sha256:9de59f6b211510bd59d745a5e49d7aa0db263deedc822005ed388f8d55227fc1</td><td>sha256:635944d2044d0a54d01385271ebe96ec18b26791eb8b85790974da36a452cc5c</td></tr><tr><td>sha256:fb0624e7b7cb9c912f952dd30833fb2fe1109ffdbcc80d995781f47bd1b4017f</td><td>sha256:9de59f6b211510bd59d745a5e49d7aa0db263deedc822005ed388f8d55227fc1</td></tr><tr><td>sha256:fb124ec4f943662ecf7aac45a43b096d316f1a6833548ec802226c7b406154e9</td><td>sha256:fb0624e7b7cb9c912f952dd30833fb2fe1109ffdbcc80d995781f47bd1b4017f</td></tr></tbody></table><p>实际的快照系统支持插件，可以改善其中一些行为。例如，它可以允许预先组合和解压缩快照，从而加快进程。这允许将快照存储在远程。它还允许进行特殊优化，例如按需下载所需的文件和层。</p><h2 id="覆盖层"><a href="#覆盖层" class="headerlink" title="覆盖层"></a>覆盖层</h2><p>虽然挂载很容易，但我们刚才描述的快照方法会创建大量文件变更和重复文件。这会减慢第一次启动容器的速度并浪费空间。值得庆幸的是，这是容器化过程中可以通过文件系统处理的众多方面之一。Linux 本身支持将目录挂载为覆盖层，为我们实现了大部分过程。</p><p>在 Linux 中（或以 <code>--privileged</code> 或 <code>--cap-add=SYS_ADMIN</code> 运行的 Linux 容器中）：</p><ol><li><p>创建一个 <code>tmpfs</code> 挂载点（基于内存的文件系统，将用于探索覆盖过程）</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> /tmp/overlay<span class="token function">mount</span> -t tmpfs tmpfs /tmp/overlay</code></pre></li><li><p>创建我们流程所需的目录。我们将使用 <code>lower</code> 作为下层（父层），<code>upper</code> 作为上层（子层），<code>work</code> 作为文件系统的工作目录，<code>merged</code> 包含合并后的文件系统。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> /tmp/overlay/<span class="token punctuation">{</span>lower,upper,work,merged<span class="token punctuation">}</span></code></pre></li><li><p>为实验创建一些文件。你也可以选择在 <code>upper</code> 中添加文件。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /tmp/overlay<span class="token keyword">echo</span> hello <span class="token operator">&gt;</span> lower/hello.txt<span class="token keyword">echo</span> <span class="token string">"I'm only here for a moment"</span> <span class="token operator">&gt;</span> lower/delete-me.txt<span class="token keyword">echo</span> message <span class="token operator">&gt;</span> upper/upper-message.txt</code></pre></li><li><p>将这些目录挂载为 <code>overlay</code> 类型的文件系统。这将在 <code>merged</code> 目录中创建一个新的文件系统，其中包含 <code>lower</code> 和 <code>upper</code> 目录的组合内容。 <code>work</code> 目录将用于跟踪文件系统的更改。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mount</span> -t overlay overlay -o lowerdir<span class="token operator">=</span>lower,upperdir<span class="token operator">=</span>upper,workdir<span class="token operator">=</span>work merged</code></pre></li><li><p>探索文件系统。你会注意到 <code>merged</code> 包含 <code>upper</code> 和 <code>lower</code> 的组合内容。然后，进行一些更改：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">rm</span> -rf merged/delete-me.txt<span class="token keyword">echo</span> <span class="token string">"I'm new"</span> <span class="token operator">&gt;</span> merged/new.txt<span class="token keyword">echo</span> world <span class="token operator">&gt;&gt;</span> merged/hello.txt</code></pre></li><li><p>正如预期的那样，<code>delete-me.txt</code> 已从 <code>merged</code> 中删除，并在同一目录中创建了一个新文件 <code>new.txt</code>。如果你对这些目录执行 <code>tree</code> 命令，你会发现一些有趣的事情：</p><pre class=" language-txt"><code class="language-txt">   |-- lower   |   |-- delete-me.txt   |   `-- hello.txt   |-- merged   |   |-- hello.txt   |   |-- new.txt   |   `-- upper-message.txt   |-- upper   |   |-- delete-me.txt   |   |-- hello.txt   |   |-- new.txt   |   `-- upper-message.txt</code></pre><p>运行 <code>ls -l upper</code> 显示：</p><pre class=" language-text"><code class="language-text">total 12c--------- 2 root root 0, 0 Jan 20 00:17 delete-me.txt-rw-r--r-- 1 root root   12 Jan 20 00:20 hello.txt-rw-r--r-- 1 root root    8 Jan 20 00:17 new.txt-rw-r--r-- 1 root root    8 Jan 20 00:17 upper-message.txt</code></pre></li></ol><p>虽然 <code>merged</code> 显示了我们更改的效果，但 <code>upper</code>（作为父层）存储的更改类似于我们手动过程中的示例。它包含新文件 <code>new.txt</code> 和修改后的 <code>hello.txt</code>。它还创建了一个 whiteout 文件。对于 overlay 文件系统，这涉及将文件替换为字符设备（以及设备号 0，0）。简而言之，它拥有打包目录所需的一切！</p><p>你可以看到这种方法如何也可以用于实现快照系统。 <code>mount</code> 命令本身可以接受一个以冒号 (<code>:</code>) 分隔的 <code>lowerdir</code> 路径列表，所有这些路径都合并到一个文件系统中。这是现代容器本质的一部分——容器是使用原生操作系统特性组成的。</p><p>这就是创建一个基本系统的全部内容。事实上，Kubernetes（以及最近发布的 Docker Desktop 4.27.0）使用的 <code>containerd</code> 运行时使用类似的方法来构建和管理其镜像（更详细的内容在 <a href="https://github.com/containerd/containerd/blob/main/docs/content-flow.md" target="_blank" rel="noopener">Content Flow</a> 中介绍）。希望这有助于揭开容器镜像工作方式的神秘面纱！</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;容器非常了不起。它们允许简单的进程像虚拟机一样运行。这种优雅的背后是一套模式和实践，最终使一切都能正常工作。设计的根源在于&lt;em&gt;层&lt;/em&gt;。层是存储和分发容器化文件系统内容的基本方式。这种设计既非常简单，同时又非常强大。在今天的文章中，我将解释什么是层，以及它们在概念上是如何工作的。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="Article" scheme="https://fcc-cd.dev/categories/Article/"/>
    
      <category term="Translation" scheme="https://fcc-cd.dev/categories/Article/Translation/"/>
    
    
  </entry>
  
  <entry>
    <title>如何快速学习</title>
    <link href="https://fcc-cd.dev/article/translation/how-to-learn-stuff-quickly/"/>
    <id>https://fcc-cd.dev/article/translation/how-to-learn-stuff-quickly/</id>
    <published>2024-06-22T08:21:51.250Z</published>
    <updated>2025-11-11T17:23:20.883Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>人们常说互联网已经实现了教育民主化：人类知识的总和只需要谷歌搜索即可获取！然而，获取信息只是故事的一半；你还需要能够将原始信息转化为可用的技能。</p><p>对于我们很多人来说，这两者之间的差距可能会导致类似于 <em>教程地狱</em> 的情况——不断地做一个又一个教程，却从未觉得自己在取得实质性的进展。</p><p>学习如何有效地学习是非常重要的，<em>尤其</em> 是作为一名软件开发人员；学习新知识几乎就是整个工作的全部！如果你能快速掌握新语言/框架/工具，你会比一般的开发人员 <em>更高效</em> 。这有点像超级能力。</p><p>在这篇博文中，我将分享我关于学习的心得，并展示我如何快速掌握新技能！</p><a id="more"></a><h2 id="混合指导学习和非指导学习"><a href="#混合指导学习和非指导学习" class="headerlink" title="混合指导学习和非指导学习"></a>混合指导学习和非指导学习</h2><p>广义上讲，有两类学习：</p><ol><li><strong>指导型学习：</strong> 阅读教程、参加课程、观看 YouTube 视频。任何你在跟随指导的活动。</li><li><strong>非指导型学习：</strong> 从头开始创建自己的项目、扩展教程、在文档中查找信息。任何你不跟随指导的活动。</li></ol><p>如果你只跟随指导资源，你会陷入<em>教程地狱</em>。你将无法掌握作为一名开发人员取得成功所需的解决问题的技能。当你尝试创建自己的项目时，你不知道从哪里开始。会觉得自己花了很多时间练习却没有获得任何实际的、实用的技能。</p><p>另一方面，如果你完全专注于非指导学习，学习过程会<em>非常漫长</em>。没有经验丰富的指导，你需要重新发明每一个轮子，花费几天或几周解决已经解决的问题。这是一条漫长而令人沮丧的道路。在最坏的情况下，你可能会完全放弃，错误地认为你不够聪明。</p><p>一些课程意识到了这种对立关系，并会包括非指导学习的机会。比如扩展目标、思维实验和挑战性练习。我希望这种类型的资源能更常见一些！</p><p>让我们看看如何将一些非指导学习融入指导资源中的一些想法。</p><h3 id="故意犯错"><a href="#故意犯错" class="headerlink" title="故意犯错"></a>故意犯错</h3><p>如果你和我一样，你不喜欢犯错。你希望一切都能第一次就完美进行。</p><p>这种心态在生活中通常是有帮助的，在其他领域也有帮助。如果你是一名汽车修理工，错误可能会花费数百美元的零件费用。如果你是一名牙医，一个错误可能会毁掉某人的微笑。</p><p>但是在软件开发中，错误是免费的！如果我们犯了错误，可以切换回编辑器，修改代码，然后再试一次。我们甚至还有一些有用的错误信息（有时）可以指引我们方向。这是一种不可思议的奢侈，我们并没有充分利用它。</p><p>当我跟随教程时，我喜欢玩代码。不要逐字逐句地复制/粘贴提供的代码，试着进行实验：如果省略其中一行会发生什么？或者更改某些值会发生什么？</p><p>我尝试像科学家一样行事。如果我对这段代码的工作方式有一个假设，我会通过更改代码并观察它是否以我预期的方式崩溃来检验这个假设。当我发现我的假设有缺陷时，我可能会从教程中偏离，去谷歌上做一些研究。或者如果这个问题看起来太深，我可能会把它列入“稍后探索的事情”清单中。</p><p>这个过程帮助我们避免了无主动意识地跟随教程，复制/粘贴代码而不真正理解它做了什么或为什么我们要这样做的危险循环。</p><p>学习是一个主动的过程。探究代码有助于我们建立对正在发生的事情的心理模型。</p><blockquote><h4 id="教程渐隐"><a href="#教程渐隐" class="headerlink" title="教程渐隐"></a>教程渐隐</h4><p>多年前，当我刚起步时，我使用了一个我称之为“教程渐隐”的方法。</p><p>具体操作如下：</p><ol><li>按照教程逐字逐句地操作，一步一步地进行。</li><li>完成后，将代码重置为初始状态，并最小化教程。看看在不看教程的情况下你能走多远。当你卡住时，重新打开教程，但一旦你解开困惑，就再次将其最小化。</li><li>重复这个过程，直到你可以从头到尾完成教程而不看说明。 就像上面描述的科学家心态一样，这个过程很有用，因为它迫使你集中注意力。教程逐渐淡出，你最终学会了在没有指导的情况下创建事物。</li></ol><p>这种方法非常有效，但并不是每个人都喜欢反复创建同样的东西。不过，如果你曾经挣扎于“教程地狱”，这可能值得一试！</p></blockquote><h3 id="扩展教程"><a href="#扩展教程" class="headerlink" title="扩展教程"></a>扩展教程</h3><p>假设我们通过这个 <a href="https://react.dev/learn/tutorial-tic-tac-toe" target="_blank" rel="noopener">官方教程</a> 学习 React 并创建了一个井字棋游戏。</p><p>当你完成教程时，你将创建一个功能齐全但非常简单的游戏。</p><p><video autoplay="" loop="" muted="" playsinline="" src="https://www.joshwcomeau.com/videos/how-to-learn-stuff-quickly/tic-tac-toe.mp4" aria-label="单人玩的井字游戏"><br></video></p><p>我们可以为它添加各种有趣的功能：</p><ul><li>记录每个玩家赢得了多少场比赛</li><li>用更多的展示组件增强 UI</li><li>允许配置棋盘大小（4x4, 5x5）</li><li>添加一个可以与玩家对战的 AI</li><li>趣味元素！（动画、音效、胜利时的彩带等）</li></ul><p>要有创造力，并选择你真正感兴趣的事情！</p><p>这种策略很好，因为你避免了空白画布的压力。你已经有了一个功能齐全、理解透彻的项目。你是在坚实的基础上添加砖块。</p><p>它还有一个好处：如果你对教程项目进行了显著扩展，可以在你的作品集中将其作为亮点！我在我的书<a href="https://www.joshwcomeau.com/effective-portfolio/" target="_blank" rel="noopener">《创建一个有效的开发者作品集》</a>中深入探讨了这个策略。</p><h3 id="创建相关项目"><a href="#创建相关项目" class="headerlink" title="创建相关项目"></a>创建相关项目</h3><p>一旦你完成了井字棋项目，你可能会有点不确定接下来该做什么。</p><p>在跳到另一个教程之前，尝试从头开始创建一个类似的项目可能是个好主意。</p><p>例如，也许你可以制作一个宾果游戏！你可以利用一些新技能（状态管理、事件监听），但在一个稍微不同的背景下。你可能会遇到一些教程中没有涉及的难题；你可以在谷歌上做些调查，尝试找到解决方案！</p><p>如果你真的无法解决，可以暂时搁置这个项目。再做几个教程，然后回来看你是否已经学到足够的知识来突破自己的知识局限。</p><p>我见过这种策略被描述为“一个有指导，一个无指导”。跟随一个有指导资源，如教程，然后花费相同的时间创建一个类似的（但无指导的）项目。如果教程教你如何创建一个 Instagram 克隆版，尝试自己创建一个 Twitter 克隆版！</p><blockquote><h4 id="找到正确的平衡点"><a href="#找到正确的平衡点" class="headerlink" title="找到正确的平衡点"></a>找到正确的平衡点</h4><p>当我刚开始学习旅程时，我倾向于主要专注于有指导的学习。当我还在努力掌握语法和基础知识时，很难以无指导的方式构建任何东西！</p><p>然而，当我变得越来越熟悉后，平衡就会发生变化。我花更多的时间进行无指导的学习，构建那些对我来说有趣的东西。当遇到新的或不熟悉的问题时，我会寻找教程，但随着经验的积累，这种情况会越来越少。</p><p>我的图表看起来像这样：</p><p><img src="https://www.joshwcomeau.com/_next/image/?url=%2Fimages%2Fhow-to-learn-stuff-quickly%2Fguided-graph.png&amp;w=640&amp;q=75" alt="Line Chart"></p><p>你的图表可能看起来有些不同；最终，找到正确的平衡点取决于你自己！重要的是，我们不要只专注于有指导的学习或无指导的学习。</p></blockquote><h2 id="心态培养"><a href="#心态培养" class="headerlink" title="心态培养"></a>心态培养</h2><p>多年前，我和一些朋友去打保龄球。</p><p>我表现得很差。我的大多数球都进了沟。到比赛结束时，我的得分是小组中最低的。</p><p>有两种不同的方式来解释这种情况：</p><ol><li>我就是不擅长打保龄球，我永远不会擅长。保龄球根本不是我的菜。</li><li>我不擅长打保龄球。但如果我愿意，我可以成为一个优秀的保龄球选手。</li></ol><p>这有一种自我实现预言的性质：无论你选择哪种解释都是正确的。如果你认为你的保龄球技能水平是固定的，它就会是。如果你相信自己可以提高，你就会提高！</p><p>如果你想快速学习新技能，培养正确的心态至关重要。</p><p>软件开发从来都不是一帆风顺的。不可避免地，我们会遇到一个困难的问题，即代码无法达到我们的预期。</p><p>这可能会导致一个充满沮丧和自我怀疑以及冒名顶替综合症的下行螺旋，或者它可以被视为一个极好的学习机会。只要你有正确的心态，没有什么比难以理解的错误信息更能帮助你快速学习。</p><p>说实话，<strong>我们从挣扎和失败中学到的比从轻松成功中学到的要多得多</strong>。有了成长心态，虽然挣扎可能不一定<em>有趣</em>，但感觉很有成效，就像一次好的锻炼。</p><p>了解更多关于 <a href="https://www.youtube.com/watch?v=-71zdXCMU6A" target="_blank" rel="noopener">培养成长心态</a> 的信息。</p><h2 id="目标和动机"><a href="#目标和动机" class="headerlink" title="目标和动机"></a>目标和动机</h2><p>我们生活在一个社交媒体炒作的世界里，很容易感到有压力，要跟上潮流，学习每一个在 Twitter 上出现的流行 JS 库。</p><p>就我个人而言，每次我试图这样做，结果都不太好。😅</p><p>我只是对为了学习而学习并没有特别的动力。为了让我保持动力，我需要有一个令人兴奋和具体的目标。</p><p>例如：几年前，我发现了 Beat Saber，这是一款 VR 视频游戏。在这个游戏中，你用光剑攻击方块，与音乐同步。每首歌都有一个独特的编舞。</p><p>有软件让用户可以创建自己的编舞（在社区中称为“地图”），但我并不是它的忠实粉丝。我想为 Beat Saber 创建自己的地图编辑器。</p><p>经过几个月的艰苦和偶尔令人沮丧的工作，我实现了我的目标：</p><iframe frameborder="0" allow="autoplay; fullscreen" allowfullscreen="" src="https://player.vimeo.com/video/652869239?pip=true"></iframe><p>（如果你对这个项目感兴趣，可以<a href="https://beatmapper.app/" target="_blank" rel="noopener">在线观看</a>，在 <a href="https://github.com/joshwcomeau/beatmapper" target="_blank" rel="noopener">Github 上查看代码</a>，或<a href="https://www.youtube.com/watch?v=9u0VapB-AbE" target="_blank" rel="noopener">观看关于其开发的会议演讲</a>！）</p><p>在这个项目之前，我没有任何 3D 经验，我必须学习大量关于 WebGL、Three.js 和 react-three-fiber 的知识。学习是困难的，无论你的成长心态有多么培养得当，总会有些日子事情进展不顺利。</p><p>但因为我有一个具体的目标，是我<em>真正</em>想要的，我能够克服挫折并继续进步。如果我只是为了好玩或者因为我认为它会让我的简历看起来更好而学习这些东西，我可能很快就放弃了。</p><p>不同的人受到不同事物的激励，所以我并不是说你需要找到一个特定的项目来创建。但我确实认为有一个明确的目标是很重要的，某个你真正感兴趣的东西。否则，在最初的新奇感消失后，维持所需的动力将变得很困难。</p><h2 id="记忆事物"><a href="#记忆事物" class="headerlink" title="记忆事物"></a>记忆事物</h2><p>我的记忆力 <em>非常</em> 差。</p><p>这可能有点问题；如果你不能记住事情，学习东西会很难！幸运的是，我有一个系统：<strong>间隔重复</strong>。</p><p>这里是间隔重复的核心思想：为了增强记忆，你需要在记忆即将消退时访问它。每次你增强记忆，它的持续时间就会稍微长一点。</p><p>这听起来很复杂，但有一些工具可以帮你跟踪这个过程。我个人使用 Leitner 盒，这是一个装有几百张索引卡的物理盒子。每天，我会复习一小部分卡片。</p><p>如果你对间隔重复感兴趣，我<em>强烈</em>建议你看看 Nicky Case 的这篇可探索的解释：<a href="https://ncase.me/remember/" target="_blank" rel="noopener">《如何永远记住任何事情》</a>。</p><h2 id="建立日常习惯"><a href="#建立日常习惯" class="headerlink" title="建立日常习惯"></a>建立日常习惯</h2><p>假设我们承诺每周花 7 个小时学习新东西。你认为是每天花一个小时在这个活动上更有效，还是每周日连续花 7 个小时更有效？</p><p>据我的经验，花费较少的时间但更频繁地进行会 <em>更</em> 有效。</p><p>我意识到并非每个人都有这种奢侈的结构，但如果你能做到，我强烈建议你尝试每天花一点时间在你试图学习的东西上。</p><p>我有一些关于为什么这种方式对我来说更有效的假设：</p><ol><li>每晚，大脑会处理并承诺当天学到的东西。我希望每天都能利用这一点，而不仅仅是每周一次！</li><li>因为我每天都练习，可以直接从上次中断的地方继续。我不必花费大量时间刷新记忆和重新开始。</li><li>正如我们所谈论的，在新奇感消失后维持动力可能很困难。如果你能将其融入日常生活，你就不必太担心动力问题；不管你感觉如何，它变成了你只需要<em>做</em>的事情。</li></ol><h2 id="公开学习"><a href="#公开学习" class="headerlink" title="公开学习"></a>公开学习</h2><p>我是 Swyx 的 <a href="https://www.swyx.io/learn-in-public/" target="_blank" rel="noopener">公开学习</a> 理念的忠实粉丝。</p><p>主要思想是，通过发布我们所学的内容，我们可以帮助未来的自己。当我们发现新事物时，我们应该创建一个记录它的文档，比如博文、推文或 YouTube 视频。</p><p>这可能有点违背直觉；为什么要在“学习时间”写博文呢？这不是浪费时间吗？</p><p>公开学习有<em>很多</em>好处，我发现了以下几点：</p><ol><li>你有没有试图向某人解释某事，结果发现自己并不像你想象的那样彻底理解它？写博文有同样的效果。这是揭示你心理模型中的缺陷/漏洞的最佳方法，以便你可以修复它们。</li><li>世界上最糟糕的感觉是遇到一个你<em>知道</em>自己已经解决过的 bug，但你记不起如何解决它。如果你写了一篇关于它的博文，你可以参考它！</li><li>通过分享你的学习，你成为开发者社区的积极参与者。你可以结交朋友和建立联系。这既有趣又有成就感，更不用说在找新工作或启动新企业时的好处了！</li></ol><p>需要注意的一点是：不要陷入设置完美博客数周的陷阱！从像 <a href="https://dev.to/" target="_blank" rel="noopener">Dev</a> 这样的平台上发布开始，甚至只是发布在 Twitter 上！在我建立博客之前，我在 Medium 上发布了数十篇博文。如果你发现自己真的喜欢公开学习，你可以随时迁移到一个华丽的定制博客。😄</p><h2 id="技能网络"><a href="#技能网络" class="headerlink" title="技能网络"></a>技能网络</h2><p>最近，我开始自学如何使用 <a href="https://www.blender.org/" target="_blank" rel="noopener">Blender</a> 创建 3D 插图。</p><p>我还是个初学者。目前，我大概投入了约 150 个小时的时间。但我已经能够创建一些看起来不错的艺术作品。以下是我制作的一些东西：</p><p><img src="https://www.joshwcomeau.com/images/how-to-learn-stuff-quickly/sneakers.png" alt="3D 插图"><br><img src="https://www.joshwcomeau.com/images/how-to-learn-stuff-quickly/muffin.png" alt="3D 插图"><br><img src="https://www.joshwcomeau.com/images/how-to-learn-stuff-quickly/chess.png" alt="3D 插图"></p><p>我能够如此快速地学习，是因为遵循了这篇博文中列出的所有技巧。但还有一个我手中的王牌：<em>互补技能</em> 。</p><p>事情是这样的，3D 插图不是一项单一的技能；它是多个技能组成的集合。其中一些，比如创建 3D 模型，对我来说是全新的，我必须从头学起。但其中一些是我有经验的技能网络的一部分。</p><p>例如：我有点业余摄影爱好。几年前，我学会了构图，如何在视口中排列元素以获得引人注目的镜头。我可以在我的渲染中定位对象时利用这些技能。</p><p>这是一个特别具体的例子，但其他的例子则更为模糊。多年来，我在前端开发工作的过程中培养了对细节的关注。所有这些像素推敲帮助我为倒角和厚度设定合适的值。而我做 UI 设计的工作帮助我理解色彩理论和美学。</p><p>你不一定会认为我已经拥有的技能会与 3D 插图产生协同作用，但它给了我一个极大的不公平优势。</p><p>在我看来，技能就像财富。你积累的技能越多，它们增长的速度就越快。在一个领域中获得的想法和技术可以在另一个领域中发挥作用。</p><p>我并不是说你应该成为一个完全的通才——拥有深厚的专业知识仍然是值得的！但你的技能网络越广，在学习新事物时你的优势就越大。</p><p>有时，学习资源会利用这一点。例如，我正在制作一个 CSS 课程，<a href="https://css-for-js.dev/" target="_blank" rel="noopener">《为 JavaScript 开发者准备的 CSS》</a>。我专门为 JS 开发者创建它，因为我知道我可以利用大量的预先存在的知识来简化学习 CSS 的过程。我们不是从零开始创建，而是利用你对 JS 的知识来解释 CSS，复制/粘贴你已经拥有的心理模型。</p><p>我的目标是改变你与 CSS 的关系。很多 JS 开发者觉得它令人沮丧且违反直觉。如果你想提升你的 CSS 技能，你可以<a href="https://css-for-js.dev/" target="_blank" rel="noopener">了解更多关于课程的信息</a>。</p><p>在这篇博文中我覆盖了 <em>很多</em> 内容，真的很感谢你坚持到最后 💖 祝你在学习旅程中好运！</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;人们常说互联网已经实现了教育民主化：人类知识的总和只需要谷歌搜索即可获取！然而，获取信息只是故事的一半；你还需要能够将原始信息转化为可用的技能。&lt;/p&gt;
&lt;p&gt;对于我们很多人来说，这两者之间的差距可能会导致类似于 &lt;em&gt;教程地狱&lt;/em&gt; 的情况——不断地做一个又一个教程，却从未觉得自己在取得实质性的进展。&lt;/p&gt;
&lt;p&gt;学习如何有效地学习是非常重要的，&lt;em&gt;尤其&lt;/em&gt; 是作为一名软件开发人员；学习新知识几乎就是整个工作的全部！如果你能快速掌握新语言/框架/工具，你会比一般的开发人员 &lt;em&gt;更高效&lt;/em&gt; 。这有点像超级能力。&lt;/p&gt;
&lt;p&gt;在这篇博文中，我将分享我关于学习的心得，并展示我如何快速掌握新技能！&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="Article" scheme="https://fcc-cd.dev/categories/Article/"/>
    
      <category term="Translation" scheme="https://fcc-cd.dev/categories/Article/Translation/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始构建容器：层</title>
    <link href="https://fcc-cd.dev/article/translation/building-container-layers-from-scratch/"/>
    <id>https://fcc-cd.dev/article/translation/building-container-layers-from-scratch/</id>
    <published>2024-06-06T19:14:58.423Z</published>
    <updated>2025-11-11T17:23:20.883Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>在 Depot，我们专注于为容器镜像提供最快的构建服务。我们主要通过以下方式实现这一目标：</p><ol><li>提供对强大计算和存储的即时访问。</li><li>优化构建过程本身以使其尽可能快。</li></ol><p>我们将 Depot 运行在 AWS 之上，为每个 Depot 项目使用大型 16 核机器。这些机器使用原生 Intel 和 Arm CPU，避免了多平台镜像的仿真。并且我们使用带有 NVMe SSD 的 Ceph 集群为它们提供分布式缓存存储。这一切都使得执行 <code>RUN</code> 语句变得快速，并使缓存查找和写入变得快速。</p><p>对于构建过程本身，除了对构建过程进行许多<a href="https://twitter.com/kylegalbraith/status/1746161367290167705" target="_blank" rel="noopener">高级优化</a>之外，我们目前正在对构建过程本身进行许多低级优化。</p><p>为了更好地理解其中一些优化，了解 OCI 容器镜像层格式本身很有帮助。</p><a id="more"></a><h2 id="层格式"><a href="#层格式" class="headerlink" title="层格式"></a>层格式</h2><p>它们只是 tar 包！</p><p><a href="https://github.com/opencontainers/image-spec/blob/main/spec.md" target="_blank" rel="noopener">OCI 镜像规范</a> 为容器镜像（“Docker 镜像”）定义了一个容器镜像，它是由“层”和元数据组成的集合。每一层都是一个以 <a href="https://en.wikipedia.org/wiki/Tar_(computing)" target="_blank" rel="noopener">tar 归档</a> 形式存储的文件集合。</p><p>当镜像被解包时，各层相互堆叠形成容器的文件系统。从概念上讲，这可以看作是在彼此之上提取每个 tar 包，直到拥有整个文件系统，或者将所有层“联合”在一起。</p><p>以这个 Dockerfile 为例：</p><pre class=" language-dockerfile"><code class="language-dockerfile">FROM ubuntu:22.04COPY hello.txt .COPY world.txt .</code></pre><p>构建时，这将生成一个包含三层的容器镜像：</p><ol><li>一个包含 Ubuntu 22.04 基础镜像文件的“层”（tar 包）</li><li>一个包含 <code>hello.txt</code> 文件的“层”（tar 包）</li><li>一个包含 <code>world.txt</code> 文件的“层”（tar 包）</li></ol><p>解压生成的镜像后，容器文件系统将如下所示：</p><pre class=" language-text"><code class="language-text">/├── bin/├── boot/├── dev/├── etc/├── home/├── lib/├── media/├── mnt/├── opt/├── proc/├── root/├── run/├── sbin/├── srv/├── sys/├── tmp/├── usr/├── var/├── hello.txt└── world.txt</code></pre><p>这将包含 Ubuntu 22.04 基础层中的所有文件，以及第二层中的 <code>hello.txt</code> 文件，以及第三层中的 <code>world.txt</code> 文件。</p><p>如今，像 Docker 和 BuildKit 这样的工具会为 Dockerfile（或多阶段 Dockerfile 的目标阶段）中的每个 <code>RUN</code>、<code>COPY</code>、<code>ADD</code> 等语句生成一个 tar 层。请注意，这不是 OCI 镜像规范的要求，该规范没有指定如何创建层。</p><p>OCI 容器镜像只是一组 tar 包。</p><h2 id="组装-OCI-镜像"><a href="#组装-OCI-镜像" class="headerlink" title="组装 OCI 镜像"></a>组装 OCI 镜像</h2><p>如果容器镜像层只是 tar 包，并且它们被联合在一起形成容器文件系统，那么如何才能在后面的层中删除或修改文件呢？</p><h3 id="处理已修改的文件"><a href="#处理已修改的文件" class="headerlink" title="处理已修改的文件"></a>处理已修改的文件</h3><p>修改文件很简单：如果一个文件包含在多个层中，则最后包含该文件的层 <code>wins</code>。例如</p><pre class=" language-dockerfile"><code class="language-dockerfile">FROM scratchRUN echo "hello" &gt; example.txtRUN echo "world" &gt; example.txt</code></pre><p>这将生成一个包含两层的镜像：</p><ol><li>一个包含 <code>example.txt</code> 文件的 tar 包，其中包含文本 <code>hello</code></li><li>一个包含 <code>example.txt</code> 文件的 tar 包，其中包含文本 <code>world</code></li></ol><p>解压后，第一层的 <code>example.txt</code> 文件将被第二层的 <code>example.txt</code> 文件覆盖，从而生成一个容器文件系统，其中包含一个 <code>example.txt</code> 文件，其中包含文本 <code>world</code>。</p><h3 id="处理已删除的文件"><a href="#处理已删除的文件" class="headerlink" title="处理已删除的文件"></a>处理已删除的文件</h3><p>但是，已删除的文件该如何处理？ 例如：</p><pre class=" language-dockerfile"><code class="language-dockerfile">FROM scratchRUN echo "hello" &gt; example.txtRUN rm example.txt</code></pre><p>为此，OCI 镜像规范定义了一种特殊的文件，称为 <code>whiteout</code> 文件。</p><p>Whiteout 文件是带有特殊名称的空文件，它告诉容器运行时应从容器文件系统中删除某个路径。 Whiteout 文件有一个特殊的<code>.wh.</code>前缀，后跟要删除的文件的名称。</p><p>例如，上面示例生成的第二层将包含一个名为 <code>.wh.example.txt</code> 的零字节文件。 这指示容器运行时在解压该层时从容器文件系统中删除 <code>example.txt</code> 文件。</p><p><strong>注意：</strong> 这是容器构建中安全漏洞的常见原因。如果一个文件包含在较早的层中，然后在较晚的层中被删除，则该文件的内容仍然存在于容器镜像内容中。这可能导致泄露敏感信息，例如凭据或私钥。</p><p>还有一种特殊的 whiteout 文件，称为 <code>opaque whiteout</code>，名为 <code>.wh..wh..opq</code>。该文件指示容器运行时删除与 opaque whiteout 文件位于同一目录中的所有文件和目录。例如，如果一个层包含一个名为<code>/example/.wh..wh..opq</code>的文件，则指示容器运行时删除 <code>/example</code> 目录下的所有文件和目录。</p><p>最后，层通常以 gzip 压缩的 tar 包（扩展名为<code>.tar.gz</code>）的形式分发，以节省存储空间并减少网络数据传输。请注意，该规范还支持未压缩的 tar 包（<code>.tar</code>）和 zstd 压缩的 tar 包（<code>.tar.zstd</code>）。</p><h2 id="Overlay-filesystems（叠加文件系统）"><a href="#Overlay-filesystems（叠加文件系统）" class="headerlink" title="Overlay filesystems（叠加文件系统）"></a>Overlay filesystems（叠加文件系统）</h2><p>像 containerd 或 podman 这样的容器运行时负责在运行容器之前将镜像的层（tar 包）解压到一个目录中。这被称为容器的 <code>rootfs</code> 或根文件系统。</p><p>实际上，对于每个启动的容器，依次将每一层解压到 rootfs 目录中，并注意应用文件修改或删除 whiteout 文件，这将非常缓慢。相反，容器运行时通常使用特殊的文件系统来有效地将各层组合成一个单一的文件系统。</p><p>其中一种文件系统是 <a href="https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html" target="_blank" rel="noopener">overlayfs</a>，它是 Linux 内核的一项功能，允许多个目录组合成一个单一目录。这是 Docker 和 Podman 使用的默认文件系统。</p><p>使用 overlayfs 时，每一层都会被解压到一个单独的目录中，然后容器运行时会告诉 Linux 内核将这些目录相互叠加挂载。然后，内核将组合后的目录作为单个目录呈现给容器运行时。</p><p>Overlayfs 本身支持 whiteout 文件的概念，因此容器运行时在挂载层时会将 OCI 镜像 whiteout 文件转换为 overlayfs whiteout 文件。</p><p>这使得每个镜像层只需解压一次，因此从同一个镜像运行多个容器非常快，并且在镜像之间共享公共基础层非常高效。Linux 内核处理将各层组合成单个文件系统的所有复杂性。</p><h2 id="使用-eStargz-的惰性镜像层"><a href="#使用-eStargz-的惰性镜像层" class="headerlink" title="使用 eStargz 的惰性镜像层"></a>使用 eStargz 的惰性镜像层</h2><p>虽然镜像层“仅仅”是包含文件的 tar 归档文件，但可以通过扩展格式来提高存储和传输效率。<a href="https://github.com/containerd/stargz-snapshotter/blob/main/docs/estargz.md" target="_blank" rel="noopener">eStargz</a> 镜像格式就是一个例子。</p><p>eStargz 镜像仍然是有效的 tar 归档文件，但它们的构建方式很特殊，允许元数据文件描述压缩 tar 包中每个文件的具体位置。这允许在无需从注册表下载整个层并解压缩的情况下访问这些文件。</p><p>例如，要在 eStargz 层中找到特定文件，容器运行时将执行以下操作：</p><ol><li>获取压缩 tar 包的末尾，其中包含层中所有文件的索引（<code>TOC</code>）</li><li>从 TOC 中读取文件的字节偏移量和长度</li><li>从注册表中获取指定的字节范围</li></ol><p>对于大型层来说，这可以显著节省下载大小和时间。</p><p>这种优化在启动容器时非常有用，因为容器可以在整个镜像下载完成之前就开始运行。然后，随着容器的运行和文件的访问，这些文件会从注册表中延迟加载。</p><p>这对构建镜像也很有帮助。我们构建的 <a href="https://depot.ai/" target="_blank" rel="noopener">depot.ai</a> 就是一个例子。借助 depot.ai 镜像，Hugging Face 中流行的机器学习模型被打包成与 eStargz 兼容的镜像。然后，当将这些机器学习模型复制到新的容器镜像中时，Depot 只需要下载 <code>COPY</code> 请求的文件。这比下载整个模型仓库要快得多，尤其是在模型仓库包含多种格式的模型而只需要一种格式的情况下。</p><p>这类优化的其他例子还包括 AWS 的 <a href="https://github.com/awslabs/soci-snapshotter" target="_blank" rel="noopener">SOCI 快照程序</a>、<a href="https://nydus.dev/" target="_blank" rel="noopener">Nydus</a> 镜像格式和 Red Hat 的 <a href="https://www.redhat.com/sysadmin/faster-container-image-pulls" target="_blank" rel="noopener"><code>zstd:chunked</code></a>。</p><h2 id="优化层构建"><a href="#优化层构建" class="headerlink" title="优化层构建"></a>优化层构建</h2><p>考虑到容器镜像层本质上是 tar 包，我们正在探索各种层构建过程的优化方法，使其更快、更高效：</p><ol><li>Depot 目前支持创建和使用 eStargz 镜像。</li><li>Depot 使用多个 CPU 核心并行压缩 tar 包。目前，我们会将层 tar 包分成多个块，并使用 gzip 并行压缩每个块，然后将这些块连接在一起。这会导致压缩后的 tar 包略大一些，但压缩速度会大大提高。</li><li>我们正在研究并行构建单层的方法，构建一层意味着从文件目录创建 tar 包。目前，这是按顺序完成的，但 tar 存档头的构建可以并行化。</li><li>我们正在探索构建层不需要 <code>Dockerfile</code> 的替代方法。目前，Dockerfile 是描述容器构建的最常见方式，但考虑到层是 tar 包，因此可以直接制作 tar 包。</li></ol><hr><p>优化容器构建过程还有很多方面，我们希望将来能分享更多我们的工作。如果您对这些内容感兴趣，请随时通过 <a href="https://twitter.com/jacobwgillespie" target="_blank" rel="noopener">Twitter</a> 或 <a href="https://discord.gg/MMPqYSgDCg" target="_blank" rel="noopener">Discord</a> 与我们联系。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;在 Depot，我们专注于为容器镜像提供最快的构建服务。我们主要通过以下方式实现这一目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供对强大计算和存储的即时访问。&lt;/li&gt;
&lt;li&gt;优化构建过程本身以使其尽可能快。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们将 Depot 运行在 AWS 之上，为每个 Depot 项目使用大型 16 核机器。这些机器使用原生 Intel 和 Arm CPU，避免了多平台镜像的仿真。并且我们使用带有 NVMe SSD 的 Ceph 集群为它们提供分布式缓存存储。这一切都使得执行 &lt;code&gt;RUN&lt;/code&gt; 语句变得快速，并使缓存查找和写入变得快速。&lt;/p&gt;
&lt;p&gt;对于构建过程本身，除了对构建过程进行许多&lt;a href=&quot;https://twitter.com/kylegalbraith/status/1746161367290167705&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;高级优化&lt;/a&gt;之外，我们目前正在对构建过程本身进行许多低级优化。&lt;/p&gt;
&lt;p&gt;为了更好地理解其中一些优化，了解 OCI 容器镜像层格式本身很有帮助。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="Article" scheme="https://fcc-cd.dev/categories/Article/"/>
    
      <category term="Translation" scheme="https://fcc-cd.dev/categories/Article/Translation/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 Certbot 在内网签发 wildcards（通配符证书）</title>
    <link href="https://fcc-cd.dev/article/engineering/certbot-issues-wildcards-private-network/"/>
    <id>https://fcc-cd.dev/article/engineering/certbot-issues-wildcards-private-network/</id>
    <published>2024-05-13T14:52:58.000Z</published>
    <updated>2024-05-20T17:52:32.000Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ol><li>Certbot 和 <code>certbot-dns-cloudflare</code> 插件</li><li>域名的 NS 服务器设置为 CloudFlare， 配置好，大概一天后生效（保守估计）</li><li>内网 DNS 服务器， 如果路由器支持定义局域网域名，可以不安装，我用的是 adguard</li><li>内网 Ubuntu 服务器</li><li>Ubuntu 安装 Nginx</li></ol><a id="more"></a><h2 id="安装-Certbot"><a href="#安装-Certbot" class="headerlink" title="安装 Certbot"></a>安装 Certbot</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> -y certbot</code></pre><p>因为域名的 NS 服务器在 CloudFlare， 需要使用 <code>certbot-dns-cloudflare</code> 插件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> python3-certbot-dns-cloudflare</code></pre><h2 id="获取用户-API-令牌"><a href="#获取用户-API-令牌" class="headerlink" title="获取用户 API 令牌"></a>获取用户 API 令牌</h2><ul><li>登录到 CloudFlare Dashboard。</li><li>前往 “My Profile” &gt; <a href="https://dash.cloudflare.com/profile/api-tokens" target="_blank" rel="noopener">“API Tokens”</a>。</li><li>确认你的 API 令牌具有所需的权限（<code>Zone.Zone:Read</code>  和  <code>Zone.DNS:Edit</code>），并且选择要使用的域名。</li></ul><p>在服务器上创建文件 <code>vim ~/.cloudflare.ini</code>,写入如下内容</p><pre class=" language-ini"><code class="language-ini"><span class="token constant">dns_cloudflare_api_token</span> <span class="token attr-value"><span class="token punctuation">=</span> xxx  # 对应域名的 API token</span></code></pre><p>然后修改文件权限，只可以本用户可读写 <code>chmod 600 ~/.cloudflare.ini</code>。</p><h2 id="签发证书"><a href="#签发证书" class="headerlink" title="签发证书"></a>签发证书</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> certbot certonly \    --dns-cloudflare \    --dns-cloudflare-credentials ~/.cloudflare.ini -d \    <span class="token string">'yourdomain.com, *.yourdomain.com'</span></code></pre><p>就可以看到如下</p><pre class=" language-text"><code class="language-text">Saving debug log to /var/log/letsencrypt/letsencrypt.logRequesting a certificate for yourdomain.com and *.yourdomain.comWaiting 10 seconds for DNS changes to propagateSuccessfully received certificate.Certificate is saved at: /etc/letsencrypt/live/yourdomain.com/fullchain.pemKey is saved at:         /etc/letsencrypt/live/yourdomain.com/privkey.pemThis certificate expires on 2024-08-10.These files will be updated when the certificate renews.Certbot has set up a scheduled task to automatically renew this certificate in the background.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -If you like Certbot, please consider supporting our work by: * Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate * Donating to EFF:                    https://eff.org/donate-le- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</code></pre><figure>    <img src="./6af9d79b7229c6957b734c0920e4c1753af89b3a.png">    <figcaption>几分钟后应该收到 CloudFlare 和 Certbot 的邮件</figcaption></figure><p>因为这个证书是有 90 天的有效期， 需要把 cerbot 加入定时任务。先验证 Cerbot 续签是否可以成功。</p><pre class=" language-bash"><code class="language-bash">certbot renew --dry-run</code></pre><p>Ubuntu 和 Debian 使用了 <code>systemd</code> ， 在安装 Certbot 过程中已经设置好了，不需要在自己手动加入 <code>Crontab</code> ， 验证状态。</p><pre class=" language-bash"><code class="language-bash">systemctl status certbot.timer</code></pre><pre class=" language-text"><code class="language-text">● certbot.timer - Run certbot twice dailyLoaded: loaded (/lib/systemd/system/certbot.timer; enabled; preset: enabled)Active: active (waiting) since Sun 2024-05-12 22:49:11 CST; 53min agoTrigger: Mon 2024-05-13 01:49:57 CST; 2h 7min leftTriggers: ● certbot.serviceMay 12 22:49:11 traefik systemd[1]: Started certbot.timer - Run certbot twice daily.</code></pre><p>如果发行版没有使用 <code>systemd</code> ， 运行命令， 编辑定时任务。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">crontab</span> -e</code></pre><p>加入如下内容</p><pre class=" language-text"><code class="language-text">0 0,12 * * *  sudo certbot renew --quiet</code></pre><p>每天 0 点， 12 点运行一次， <code>--quiet</code>  参数确保只有在发生错误时才会有输出。 更详细的日志可以通过下面的命令查看</p><pre class=" language-bash"><code class="language-bash"><span class="token function">less</span> /var/log/letsencrypt/letsencrypt.log</code></pre><p>请注意，Certbot 通常会在证书到期前 30 天尝试续签，所以即使你设置了每天检查，实际的续签操作并不会每天发生。</p><h2 id="配置-Nginx-读取证书"><a href="#配置-Nginx-读取证书" class="headerlink" title="配置 Nginx 读取证书"></a>配置 Nginx 读取证书</h2><pre class=" language-nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>    <span class="token keyword">listen</span> <span class="token number">443</span> <span class="token keyword">ssl</span> http2<span class="token punctuation">;</span>    <span class="token keyword">listen</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">443</span> <span class="token keyword">ssl</span> http2<span class="token punctuation">;</span>    <span class="token keyword">server_name</span> yourdomain<span class="token punctuation">.</span>com www<span class="token punctuation">.</span>yourdomain<span class="token punctuation">.</span>com<span class="token punctuation">;</span>    <span class="token keyword">ssl_certificate</span> <span class="token operator">/</span>etc<span class="token operator">/</span>letsencrypt<span class="token operator">/</span>live<span class="token operator">/</span>yourdomain<span class="token punctuation">.</span>com<span class="token operator">/</span>fullchain<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>    <span class="token keyword">ssl_certificate_key</span> <span class="token operator">/</span>etc<span class="token operator">/</span>letsencrypt<span class="token operator">/</span>live<span class="token operator">/</span>yourdomain<span class="token punctuation">.</span>com<span class="token operator">/</span>privkey<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>    <span class="token keyword">ssl_protocols</span> TLSv1<span class="token number">.2</span> TLSv1<span class="token number">.3</span><span class="token punctuation">;</span>    <span class="token keyword">ssl_ciphers</span> <span class="token string">'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384'</span><span class="token punctuation">;</span>    <span class="token keyword">ssl_prefer_server_ciphers</span> on<span class="token punctuation">;</span>    <span class="token keyword">ssl_session_cache</span> shared<span class="token punctuation">:</span><span class="token keyword">SSL</span><span class="token punctuation">:</span>10m<span class="token punctuation">;</span>    <span class="token keyword">ssl_session_timeout</span> 10m<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>请将  <code>yourdomain.com</code>  替换为你的实际域名。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> nginx -t</code></pre><p>验证 Nginx 配置</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> systemctl reload nginx</code></pre><p>使用新配置。</p><h2 id="配置-内网-DNS-服务器"><a href="#配置-内网-DNS-服务器" class="headerlink" title="配置 内网 DNS 服务器"></a>配置 内网 DNS 服务器</h2><p>需要在路由器指定 内网 DNS 服务器，我用的是小米路由器</p><p><img src="./77adb6747a403f1f6b3ab0d66e1e21939b47c885.png" alt=""></p><p>192.168.2.166 我的 DNS 服务器的内网 IP。</p><p>配置内网 DNS 服务器， 我用的是 Adguard</p><p><img src="./5354869112456c80ee49e77acc2a65fbc0df4c4b.png" alt=""></p><p>验证 DNS 解析</p><pre class=" language-bash"><code class="language-bash"><span class="token function">dig</span> gpt.luojiyin.top</code></pre><pre class=" language-text"><code class="language-text">&lt;&lt;&gt;&gt; DiG 9.18.18-0ubuntu2.1-Ubuntu&lt;&lt;&gt;&gt; gpt.luojiyin.top               ;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 50327;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:                  ; EDNS: version: 0, flags:; udp: 65494;; QUESTION SECTION: ;gpt.luojiyin.top.              IN      A;; ANSWER SECTION:gpt.luojiyin.top.       10      IN      A       192.168.2.166;; Query time: 4 msec;; SERVER: 127.0.0.53#53(127.0.0.53) (UDP);; WHEN: Mon May 13 00:13:12 CST 2024</code></pre><p>然后指定 公网 DNS 服务器 119.29.29.29</p><pre class=" language-bash"><code class="language-bash"><span class="token function">dig</span> gpt.luojiyin.top @119.29.29.29</code></pre><pre class=" language-text"><code class="language-text">; &lt;&lt;&gt;&gt; DiG 9.18.18-0ubuntu2.1-Ubuntu &lt;&lt;&gt;&gt; gpt.luojiyin.top @119.29.29.29;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 48075;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0;; QUESTION SECTION:;gpt.luojiyin.top.              IN      A;; AUTHORITY SECTION:luojiyin.top.           360     IN      SOA     jocelyn.ns.cloudflare.com. dns.cloudflare.com. 2341014133 10000 2400 604800 1800;; Query time: 272 msec;; SERVER: 8.8.8.8#53(8.8.8.8) (UDP);; WHEN: Mon May 13 00:13:32 CST 2024;; MSG SIZE  rcvd: 99</code></pre><p>就可以发现 DNS 解析只在内网生效。</p><p>然后用浏览器打开你自己的网址，可以看到。</p><p><img src="./a176571864797e95b492f33487e6085947eaa2ec.png" alt=""></p><p>就可以在内网使用 https，可以使用很多高级 web 特性了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>考虑大部分人接触过 Nginx，以 Nginx 作为示范。 可以根据自己的情况换成阿里云或者腾讯云，需要设置域名的 NS 服务器设置为对应的云。由于是 wildcard（通配符域名），只需签发一次， <code>yourdomain.com</code> <code>*.yourdomain.com</code> 等域名可以用。</p><p>思路是通过 DNS 验证，Certbot 通过 token 给 CF 的 DNS 服务器添加一个 <code>TXT</code> 记录， 然后 Cerbot 读取这个 <code>TXT</code> 记录，是否一致，验证你对域名的控制权并签发证书。也是国内很多云服务商为什么让你加一个 <code>TXT</code> 记录，才签发一个<strong>单个域名证书 (Single-domain SSL certificate)</strong> ，不舍得给你一个 <strong>通配符证书 (Wildcard SSL certificate)</strong> ，让你反复操作。</p><p>一图胜千言</p><p><img src="./2c730e26d69d603ab2e7458da867f22b4752fee2.png" alt=""></p><p>Certbot 就是图中的 Caddy</p><p>如果不使用 Nginx， 而使用云原生的网关软件，会变得更自动化，更简单。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;前置条件&quot;&gt;&lt;a href=&quot;#前置条件&quot; class=&quot;headerlink&quot; title=&quot;前置条件&quot;&gt;&lt;/a&gt;前置条件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Certbot 和 &lt;code&gt;certbot-dns-cloudflare&lt;/code&gt; 插件&lt;/li&gt;
&lt;li&gt;域名的 NS 服务器设置为 CloudFlare， 配置好，大概一天后生效（保守估计）&lt;/li&gt;
&lt;li&gt;内网 DNS 服务器， 如果路由器支持定义局域网域名，可以不安装，我用的是 adguard&lt;/li&gt;
&lt;li&gt;内网 Ubuntu 服务器&lt;/li&gt;
&lt;li&gt;Ubuntu 安装 Nginx&lt;/li&gt;
&lt;/ol&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="Article" scheme="https://fcc-cd.dev/categories/Article/"/>
    
      <category term="Engineering" scheme="https://fcc-cd.dev/categories/Article/Engineering/"/>
    
    
      <category term="http" scheme="https://fcc-cd.dev/tags/http/"/>
    
      <category term="SSL" scheme="https://fcc-cd.dev/tags/SSL/"/>
    
      <category term="内网" scheme="https://fcc-cd.dev/tags/%E5%86%85%E7%BD%91/"/>
    
      <category term="DevOps" scheme="https://fcc-cd.dev/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>使用 Caddy 和 CloudFlare 在内网自动签发 https 证书</title>
    <link href="https://fcc-cd.dev/article/engineering/using-caddy-and-cloudflare-to-issue-wildcards-on-private-networks/"/>
    <id>https://fcc-cd.dev/article/engineering/using-caddy-and-cloudflare-to-issue-wildcards-on-private-networks/</id>
    <published>2024-05-13T14:52:58.000Z</published>
    <updated>2024-05-20T17:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ol><li>Caddy 和 <code>dns-cloudflare</code> 插件，需要构建自己的 Docker 镜像</li><li>域名的 NS 服务器设置为 CloudFlare， 配置好，大概一天后生效（保守估计）</li><li>内网 DNS 服务器， 如果路由器支持定义局域网域名，可以不安装，我用的是 adguard</li><li>内网 Ubuntu 服务器</li><li>Ubuntu 安装 Docker</li></ol><a id="more"></a><h2 id="构建-Docker-镜像"><a href="#构建-Docker-镜像" class="headerlink" title="构建 Docker 镜像"></a>构建 Docker 镜像</h2><p>在 Docker compose 同一层文件夹里，创建一个 Dockerfile。</p><pre class=" language-dockerfile"><code class="language-dockerfile">FROM caddy:builder AS builderRUN caddy-builder github.com/caddy-dns/cloudflareFROM caddy:latestCOPY --from=builder /usr/bin/caddy /usr/bin/caddy</code></pre><p>在 Docker compose 使用 Dockerfile</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.7"</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">caddy</span><span class="token punctuation">:</span>    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> caddy    <span class="token key atrule">build</span><span class="token punctuation">:</span>      <span class="token key atrule">context</span><span class="token punctuation">:</span> .      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile</code></pre><h2 id="获取用户-API-令牌"><a href="#获取用户-API-令牌" class="headerlink" title="获取用户 API 令牌"></a>获取用户 API 令牌</h2><ul><li>登录到 CloudFlare Dashboard。</li><li>前往 “My Profile” &gt; <a href="https://dash.cloudflare.com/profile/api-tokens" target="_blank" rel="noopener">“API Tokens”</a>。</li><li>确认你的 API 令牌具有所需的权限（Zone.Zone:Read 和 Zone.DNS:Edit），并且选择要使用的域名。<br>在 <code>docker-compose.yml</code> 同一层文件夹里创建一个 <code>.env</code> 文件</li></ul><pre class=" language-ini"><code class="language-ini"><span class="token constant">CLOUDFLARE_API_TOKEN</span> <span class="token attr-value"><span class="token punctuation">=</span> your token</span></code></pre><p>然后修改文件权限，只允许本用户读写。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">chmod</span> 600 .env</code></pre><h2 id="编写-Caddyfile-文件"><a href="#编写-Caddyfile-文件" class="headerlink" title="编写 Caddyfile 文件"></a>编写 Caddyfile 文件</h2><p>在 <code>docker-compose.yml</code> 同一层文件夹里，创建一个 <code>Caddyfile</code> 文件</p><pre class=" language-caddyfile"><code class="language-caddyfile">caddy.luojiyin.top {  tls {       dns cloudflare {env.CLOUDFLARE_API_TOKEN}  }  respond / "Hello, world! This is a static response from Caddy." 200}</code></pre><p>Caddy 直接输出一个静态页面，验证签发是否成功。</p><h2 id="完整的-Docker-compose-文件"><a href="#完整的-Docker-compose-文件" class="headerlink" title="完整的 Docker compose 文件"></a>完整的 Docker compose 文件</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.7"</span><span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">caddy</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> caddy<span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">caddy</span><span class="token punctuation">:</span>    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> caddy    <span class="token key atrule">build</span><span class="token punctuation">:</span>      <span class="token key atrule">context</span><span class="token punctuation">:</span> .      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"80:80"</span> <span class="token comment" spellcheck="true"># Remember that Caddy does HTTP to HTTPS redirections automatically.</span>      <span class="token punctuation">-</span> <span class="token string">"443:443"</span>    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> CADDY_INGRESS_NETWORK=caddy      <span class="token comment" spellcheck="true"># If you don't want to write your token here, remember that Docker Compose picks up</span>      <span class="token comment" spellcheck="true"># variables from an .env file if present in the same directory as the compose file.</span>      <span class="token punctuation">-</span> CLOUDFLARE_API_TOKEN=$<span class="token punctuation">{</span>CLOUDFLARE_API_TOKEN<span class="token punctuation">}</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> caddy    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"/var/run/docker.sock:/var/run/docker.sock"</span>      <span class="token comment" spellcheck="true"># It is important to have these to conserve data after the container restarts</span>      <span class="token punctuation">-</span> <span class="token string">"./data:/data"</span>      <span class="token comment" spellcheck="true"># Unless we want to SSH to our server every time it restarts.</span>      <span class="token punctuation">-</span> <span class="token string">"./config:/config"</span>      <span class="token punctuation">-</span> <span class="token string">"./Caddyfile:/etc/caddy/Caddyfile"</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span> unless<span class="token punctuation">-</span>stopped</code></pre><p>完整的文件夹目录</p><pre class=" language-text"><code class="language-text">├── Caddyfile├── config│   └── caddy  [error opening dir]├── data│   └── caddy  [error opening dir]├── docker-compose.yml└── Dockerfile</code></pre><p>启动服务</p><pre class=" language-bash"><code class="language-bash">docker compose up</code></pre><p>没加 <code>-d</code> , 第一次启动查看日志， 会读取 <code>Dockerfile</code> 文件构建镜像，加入 CloudFlare 插件， 从 <code>.env</code> 文件 获取 <code>CLOUDFLARE_API_TOKEN</code> 。</p><pre class=" language-text"><code class="language-text">caddy  | {"level":"info","ts":1715595177.3236513,"logger":"tls.obtain","msg":"obtaining certificate","identifier":"caddy.luojiyin.top"}caddy  | {"level":"info","ts":1715595177.32397,"logger":"tls","msg":"finished cleaning storage units"}caddy  | {"level":"info","ts":1715595179.2300568,"logger":"tls.issuance.acme","msg":"waiting on internal rate limiter","identifiers":["caddy.luojiyin.top"],"ca":"https://acme-v02.api.letsencrypt.org/directory","account":""}caddy  | {"level":"info","ts":1715595179.2301404,"logger":"tls.issuance.acme","msg":"done waiting on internal rate limiter","identifiers":["caddy.luojiyin.top"],"ca":"https://acme-v02.api.letsencrypt.org/directory","account":""}caddy  | {"level":"info","ts":1715595180.2085311,"logger":"tls.issuance.acme.acme_client","msg":"trying to solve challenge","identifier":"caddy.luojiyin.top","challenge_type":"dns-01","ca":"https://acme-v02.api.letsencrypt.org/directory"}caddy  | {"level":"info","ts":1715595197.6058002,"logger":"tls.issuance.acme.acme_client","msg":"authorization finalized","identifier":"caddy.luojiyin.top","authz_status":"valid"}caddy  | {"level":"info","ts":1715595197.605848,"logger":"tls.issuance.acme.acme_client","msg":"validations succeeded; finalizing order","order":"https://acme-v02.api.letsencrypt.org/acme/order/1723709497/269014373307"}caddy  | {"level":"info","ts":1715595199.1746569,"logger":"tls.issuance.acme.acme_client","msg":"successfully downloaded available certificate chains","count":2,"first_url":"https://acme-v02.api.letsencrypt.org/acme/cert/049f29c5f90a9c14bd9acdb84ff4ab90af77"}caddy  | {"level":"info","ts":1715595199.176429,"logger":"tls.obtain","msg":"certificate obtained successfully","identifier":"caddy.luojiyin.top"}caddy  | {"level":"info","ts":1715595199.1766984,"logger":"tls.obtain","msg":"releasing lock","identifier":"caddy.luojiyin.top"}</code></pre><p>没有报错信息， 基本成功了。</p><h2 id="配置内网-DNS"><a href="#配置内网-DNS" class="headerlink" title="配置内网 DNS"></a>配置内网 DNS</h2><figure>    <img src="./e280d22c8bd57a59b01707b2b37e02156862500a.png">    <figcaption>配置内网域名解析</figcaption></figure><p>打开浏览器验证</p><p><img src="./f404c970e9c6ef366ba580dfa9c97e4ede61ff0e.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一图胜千言</p><p><img src="./fb21bae7a9d180c97a00fef82bdc4abc9fe83cbc.png" alt=""></p><p>是不是比用 Nginx 简单多了。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;前置条件&quot;&gt;&lt;a href=&quot;#前置条件&quot; class=&quot;headerlink&quot; title=&quot;前置条件&quot;&gt;&lt;/a&gt;前置条件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Caddy 和 &lt;code&gt;dns-cloudflare&lt;/code&gt; 插件，需要构建自己的 Docker 镜像&lt;/li&gt;
&lt;li&gt;域名的 NS 服务器设置为 CloudFlare， 配置好，大概一天后生效（保守估计）&lt;/li&gt;
&lt;li&gt;内网 DNS 服务器， 如果路由器支持定义局域网域名，可以不安装，我用的是 adguard&lt;/li&gt;
&lt;li&gt;内网 Ubuntu 服务器&lt;/li&gt;
&lt;li&gt;Ubuntu 安装 Docker&lt;/li&gt;
&lt;/ol&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="Article" scheme="https://fcc-cd.dev/categories/Article/"/>
    
      <category term="Engineering" scheme="https://fcc-cd.dev/categories/Article/Engineering/"/>
    
    
      <category term="SSL" scheme="https://fcc-cd.dev/tags/SSL/"/>
    
      <category term="内网" scheme="https://fcc-cd.dev/tags/%E5%86%85%E7%BD%91/"/>
    
      <category term="DevOps" scheme="https://fcc-cd.dev/tags/DevOps/"/>
    
      <category term="https" scheme="https://fcc-cd.dev/tags/https/"/>
    
      <category term="Caddy" scheme="https://fcc-cd.dev/tags/Caddy/"/>
    
      <category term="Docker" scheme="https://fcc-cd.dev/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>你正在错过的最新 Docker BuildKit 功能</title>
    <link href="https://fcc-cd.dev/article/translation/recent-docker-buildkit-features/"/>
    <id>https://fcc-cd.dev/article/translation/recent-docker-buildkit-features/</id>
    <published>2024-05-12T16:00:00.000Z</published>
    <updated>2025-11-11T17:23:20.882Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>随着 BuildKit 的引入，Docker 的构建后端得到了显著改进，并增添了许多强大的新功能。然而，很多用户并不了解这些新功能。因此，本文将向你介绍那些你绝对应该了解并开始使用的 BuildKit 功能，助你更好地利用 Docker。</p><a id="more"></a><h2 id="Debugging（调试）"><a href="#Debugging（调试）" class="headerlink" title="Debugging（调试）"></a>Debugging（调试）</h2><p>让我们从最常见的任务 - <strong>调试</strong> 开始。一直以来，调试 <code>docker build</code> 都是一件痛苦的事情。当 <code>RUN</code> 或 <code>COPY</code> 命令失败时，你很难查看上下文并调试问题所在，通常只能求助于添加 <code>RUN ls -la</code> 等命令来获取更多信息。</p><p>然而，随着 <strong><code>docker buildx debug</code></strong> 的引入，这一切都将成为过去！</p><pre class=" language-shell"><code class="language-shell">export BUILDX_EXPERIMENTAL=1docker buildx debug --invoke /bin/sh --on=error build .</code></pre><pre class=" language-text"><code class="language-text">[+] Building 1.2s (14/18)docker:default...------ &gt; [builder 5/6] RUN exit 1:------Dockerfile:10--------------------   8 |     RUN pip3 install -r requirements.txt   9 |  10 | &gt;&gt;&gt; RUN exit 1  11 |  12 |     COPY . /app--------------------ERROR: process "/bin/sh -c exit 1" did not complete successfully: exit code: 1[+] Building 0.0s (0/0)                  docker:defaultLaunching interactive container. Press Ctrl-a-c to switch to monitor consoleInteractive container was restarted with process "u6agxp1ywqapemxrt8iexfv4h". Press Ctrl-a-c to switch to the new container/ # ls -latotal 72drwxr-xr-x    1 root     root          4096 May  5 12:59 .drwxr-xr-x    1 root     root          4096 May  5 12:59 ..drwxr-xr-x    1 root     root          4096 May  4 10:11 app...</code></pre><p>如上述代码片段所示，我们首先通过设置 <code>BUILDX_EXPERIMENTAL</code> 环境变量来启用实验性的 BuildKit 功能。然后，我们使用 <code>docker buildx debug</code> 命令启动构建过程。如果构建过程中的任何步骤发生错误，我们将自动进入容器内部，并可以自由探索上下文和进行调试。</p><p>需要注意的是，我们使用了 <code>--on=error</code> 选项，这表示只有在构建失败时才会启动调试会话。</p><p><a href="https://github.com/docker/buildx/blob/master/docs/debugging.md" target="_blank" rel="noopener">调试文档，获取更多细节</a></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>如果你之前使用 BuildKit 运行过构建，你一定注意到了它那花哨的新日志输出格式。虽然看起来很漂亮，但在调试时却不太实用。</p><p>好消息是，我们可以通过设置一个环境变量来切换回简洁的日志输出格式：</p><pre class=" language-shell"><code class="language-shell">export BUILDKIT_PROGRESS=plain</code></pre><p>你也可以将其设置为 <code>rawjson</code> ，虽然这种格式对人类来说绝对不可读，但如果你想以某种方式处理日志，它可能会很有用。</p><p>或者，如果你喜欢基于 TTY 的动态输出，但不喜欢默认的颜色，那么你可以通过以下方式更改它们：</p><pre class=" language-shell"><code class="language-shell">BUILDKIT_COLORS="run=green:warning=yellow:error=red:cancel=cyan"docker buildx debug --invoke /bin/sh --on=error build .</code></pre><p>会有如下输出:</p><p><img src="https://i.imgur.com/gTasZHC.png" alt="Buildx Colors"></p><p>查看 <a href="https://docs.docker.com/build/building/variables/#build-tool-configuration-variables" target="_blank" rel="noopener">环境变量文档</a></p><h2 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h2><p>BuildKit 还引入了 <em>导出器(exporters)</em> 的概念，它定义了如何保存构建的输出。其中两个最有用的选项是 <code>image</code> 和 <code>registry</code>。<code>image</code> 正如你所期望的那样，将输出保存为容器镜像，而 <code>registry</code> 导出器会自动将镜像推送到指定的镜像仓库：</p><pre class=" language-shell"><code class="language-shell">docker buildx build --output type=registry,name=martinheinz/testimage:latest .</code></pre><p>我们只需要使用 <code>--output</code> 选项并指定类型为 <code>registry</code> 以及目标地址即可。此选项还支持一次指定多个镜像仓库：</p><pre class=" language-shell"><code class="language-shell">docker buildx build --output type=registry,\"name=docker.io/martinheinz/testimage,docker.io/martinheinz/testimage2\" .</code></pre><p>最后，我们还可以提供 <code>--cache-to</code> 和 <code>--cache-from</code> 选项，例如使用镜像仓库中的现有镜像作为缓存源：</p><pre class=" language-shell"><code class="language-shell">docker buildx build --output type=registry,name=martinheinz/testimage:latest \ --cache-to type=inline \ --cache-from type=registry,ref=docker.io/martinheinz/testimage .</code></pre><pre class=" language-text"><code class="language-text">... =&gt; CACHED docker-image://docker.io/docker/dockerfile:1.4@sha256:9ba7531bd80fb0a8...1e24ef1a0dbc... =&gt; CACHED [builder 2/5] WORKDIR /app                                                                            0.0s =&gt; CACHED [builder 3/5] COPY requirements.txt /app                                                              0.0s =&gt; CACHED [builder 4/5] RUN --mount=type=cache,target=/root/.cache/pip     pip3 install -r requirements.txt     0.0s =&gt; CACHED [builder 5/5] COPY . /app                                                                             0.0s =&gt; CACHED [dev-envs 1/3] RUN &lt;<eof (apk="" update...)="" 0.0s=""> CACHED [dev-envs 2/3] RUN &lt;<eof (addgroup="" -s="" docker...)="" 0.0s=""> CACHED [dev-envs 3/3] COPY --from=gloursdocker/docker / /                                                    0.0s =&gt; preparing layers for inline cache                                                                            0.0s...</eof></eof></code></pre><h2 id="镜像工具"><a href="#镜像工具" class="headerlink" title="镜像工具"></a>镜像工具</h2><p><code>docker buildx</code> 有一个简单但方便的子命令叫做 <code>imagetools</code>，它允许我们在不拉取镜像的情况下检查镜像仓库中的镜像。<a href="https://docs.docker.com/reference/cli/docker/buildx/imagetools/inspect/" target="_blank" rel="noopener">文档</a> 中包含许多示例，但对我来说最有用的是获取远程镜像的哈希值：</p><pre class=" language-shell"><code class="language-shell">docker buildx imagetools inspect alpine --format "{{json .Manifest}}" | jq .digest"sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6b"</code></pre><h2 id="最新的-Dockerfile-语法"><a href="#最新的-Dockerfile-语法" class="headerlink" title="最新的 Dockerfile 语法"></a>最新的 Dockerfile 语法</h2><p>BuildKit 还通过所谓的 <em><a href="https://docs.docker.com/build/dockerfile/frontend/" target="_blank" rel="noopener">Dockerfile 前端</a></em> 带来了新的 Dockerfile 语法。要启用当前最新的语法，我们需要在 Dockerfile 的顶部添加一个指令，例如：</p><pre class=" language-Dockerfile"><code class="language-Dockerfile"># syntax=docker/dockerfile:1.3FROM ...</code></pre><p>要查找版本，你可以查看 <a href="https://hub.docker.com/r/docker/dockerfile-upstream" target="_blank" rel="noopener"><code>dockerfile-upstream</code></a>。</p><h2 id="Here-docs"><a href="#Here-docs" class="headerlink" title="Here-docs"></a>Here-docs</h2><p>我想提到的第一个 Dockerfile 语法改进是 _here-docs_，它允许我们将多行脚本传递给 <code>RUN</code> 和 <code>COPY</code> 命令：</p><pre class=" language-Dockerfile"><code class="language-Dockerfile"># syntax = docker/dockerfile:1.3-labsFROM debianRUN &lt;<eot bash="" apt-get="" update="" install="" -y="" vim="" eot<="" code=""></eot></code></pre><code class="language-Dockerfile"><pre class=" language-Dockerfile"><code class="language-Dockerfile"># 与下面的相同:RUN apt-get update &amp;&amp; apt-get install -y vim</code></pre><p>过去，如果我们想将多个命令放入单个 <code>RUN</code> 中，我们必须使用 <code>&amp;&amp;</code>，现在使用 here 文档，我们可以编写一个正常的脚本。</p><p>此外，第一行可以指定解释器，因此我们也可以，编写 Python 脚本：</p><pre class=" language-Dockerfile"><code class="language-Dockerfile"># syntax = docker/dockerfile:1.3-labsFROM python:3.6RUN &lt;<eot #!="" usr="" bin="" env="" python="" print("hello="" world")="" eot<="" code=""></eot></code></pre><code class="language-Dockerfile"><h2 id="COPY-和-ADD-功能"><a href="#COPY-和-ADD-功能" class="headerlink" title="COPY 和 ADD 功能"></a><code>COPY</code> 和 <code>ADD</code> 功能</h2><p>在这种新的 Dockerfile 语法中，<code>COPY</code> 和 <code>ADD</code> 也有更细微的变化和改进，以新选项的形式出现。</p><p><code>COPY</code> 现在支持 <code>--parents</code> 选项：</p><pre class=" language-Dockerfile"><code class="language-Dockerfile"># syntax=docker/dockerfile:1.7.0-labsFROM ubuntuCOPY ./one/two/some.txt /normal/RUN find /normal#10 [3/5] RUN find /normal#10 0.223 /normal#10 0.223 /normal/some.txtCOPY --parents ./one/two/some.txt /parents/RUN find /parents#12 [5/5] RUN find /parents#12 0.509 /parents#12 0.509 /parents/one#12 0.509 /parents/one/two#12 0.509 /parents/one/two/some.txt</code></pre><p>如果你使用普通的 <code>COPY</code> 复制一个嵌套文件，镜像将只包含文件本身，而不包含父目录，使用 <code>--parents</code> 将复制整个文件树，类似于 <code>cp --parents</code> 的工作方式。</p><p>与 <code>--parents</code> 选项类似，你也可以使用 <code>--exclude</code>：</p><pre class=" language-Dockerfile"><code class="language-Dockerfile">COPY --exclude=*.txt ./some-dir/* ./some-dest</code></pre><p>这将在复制时省略排除的文件（和模式）。</p><p>最后，<code>ADD</code> 命令也得到了改进，现在可以直接添加 Git 仓库：</p><pre class=" language-Dockerfile"><code class="language-Dockerfile"># syntax=docker/dockerfile:1.7.0-labsFROM ubuntuADD git@github.com:kelseyhightower/helloworld.git /repoRUN ls -la /repo</code></pre><p>并且在为此 Dockerfile 运行构建时，我们将获得：</p><pre class=" language-shell"><code class="language-shell">docker buildx build --ssh default --progress=plain .</code></pre><pre class=" language-text"><code class="language-text">#8 [2/3] ADD git@github.com:kelseyhightower/helloworld.git /repo#8 0.478 Warning: Permanently added 'github.com' (ED25519) to the list of known hosts.#8 1.738 ref: refs/heads/master HEAD#8 1.738 96a652519d1aaca11085ca3a7806bead4d2c273f HEAD#8 3.478 96a652519d1aaca11085ca3a7806bead4d2c273f refs/heads/master#8 1.829 ref: refs/heads/master HEAD#8 1.829 96a652519d1aaca11085ca3a7806bead4d2c273f HEAD#8 3.838 From github.com:kelseyhightower/helloworld#8 3.838  * [new branch]      master     -&gt; master#8 3.838  * [new branch]      master     -&gt; origin/master#8 DONE 7.4s#9 [2/3] ADD git@github.com:kelseyhightower/helloworld.git /repo#9 DONE 0.0s</code></pre><p>这同样适用于<a href="https://docs.docker.com/reference/dockerfile/#adding-private-git-repositories" target="_blank" rel="noopener">私有仓库</a>。</p><p>在<a href="https://docs.docker.com/reference/dockerfile/#add" target="_blank" rel="noopener">文档</a>中查看更多有趣的选项，例如用于验证工件校验和的 <code>ADD --keep-git-dir</code> 或 <code>ADD --checksum</code>。</p><h2 id="额外奖励：缩进"><a href="#额外奖励：缩进" class="headerlink" title="额外奖励：缩进"></a>额外奖励：缩进</h2><p>虽然不是 BuildKit 功能，但我最近发现的一件事是，你可以在 Dockerfile 中缩进行，并且它可以正常工作，这允许更好的可读性，尤其是在多阶段构建中：</p><pre class=" language-Dockerfile"><code class="language-Dockerfile"># syntax=docker/dockerfile:1FROM golang:1.21  WORKDIR /src  COPY main.go .  RUN go build -o /bin/hello ./main.goFROM scratch  COPY --from=0 /bin/hello /bin/hello  CMD ["/bin/hello"]</code></pre><p>乍一看可能很奇怪，但我认为这样可读性更高，可以更清楚地看出每个阶段从哪里开始以及哪些命令属于它。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文中的示例仅展示了我认为最有用的功能，但还有更多功能，因此请务必查看官方 <a href="https://docs.docker.com/reference/cli/docker/buildx/" target="_blank" rel="noopener">Docker 文档</a>，以及包含最新更改的 <a href="https://github.com/moby/buildkit/tree/master/docs" target="_blank" rel="noopener">BuildKit 文档</a>。Docker 博客也是一个很好的资源，特别是打了 <em><a href="https://www.docker.com/blog/tag/buildkit/" target="_blank" rel="noopener">buildkit</a></em> 或 <em><a href="https://www.docker.com/blog/tag/buildx/" target="_blank" rel="noopener">buildx</a></em> 标签的帖子。</p></code></code></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;随着 BuildKit 的引入，Docker 的构建后端得到了显著改进，并增添了许多强大的新功能。然而，很多用户并不了解这些新功能。因此，本文将向你介绍那些你绝对应该了解并开始使用的 BuildKit 功能，助你更好地利用 Docker。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="Article" scheme="https://fcc-cd.dev/categories/Article/"/>
    
      <category term="Translation" scheme="https://fcc-cd.dev/categories/Article/Translation/"/>
    
    
  </entry>
  
  <entry>
    <title>AI时代前沿的创新与实践</title>
    <link href="https://fcc-cd.dev/activity/workshop/ai-events/"/>
    <id>https://fcc-cd.dev/activity/workshop/ai-events/</id>
    <published>2024-04-14T08:53:00.000Z</published>
    <updated>2025-11-11T17:23:20.600Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>本次AI 技术分享会汇聚多位技术专家与教育创新者，共同探索人工智能时代下的技术应用与教学变革。</p><h2 id="📢-活动亮点"><a href="#📢-活动亮点" class="headerlink" title="📢 活动亮点"></a>📢 活动亮点</h2><ul><li>🔧 技术实践：获得可立即应用的 AI 技术实操方法。</li><li>🎓 趋势洞察：了解智能教育的最新发展趋势。</li><li>💡 思维拓展：激发跨领域创新思维与合作机会。</li></ul><h2 id="🔥-明星嘉宾阵容"><a href="#🔥-明星嘉宾阵容" class="headerlink" title="🔥 明星嘉宾阵容"></a>🔥 明星嘉宾阵容</h2><p><strong>📚 AI 编程教育的探索之旅</strong></p><blockquote><p>彭雪梅 | 创业者 | 全栈工程师 | fCC 活动组织者</p></blockquote><ul><li>AI高效提取内容，助力学习复盘</li><li>自动生成教学视频，提升课堂体验</li><li>复杂知识点一键图解</li></ul><p><strong>🤖 DeepSeek 创新点与本地化部署</strong></p><blockquote><p>何静 | AI 技术研究者｜AFE AI 社群主理人</p></blockquote><ul><li>DeepSeek 创新点</li><li>本地部署大模型以及应用</li><li>Agent 前沿发展趋势</li></ul><p><strong>🗃️ 数据库技术及应用·从原理到实战</strong></p><blockquote><p>孙瑜 | 西南石油大学教授 | 华为 ICT 学院负责人</p></blockquote><ul><li>数据库基础原理精讲</li><li>openGauss数据库架构及关键技术解析</li><li>SQL语言实战演练</li></ul><p><strong>🎨 AI绘图魔法升级·图片也能当指令！</strong></p><blockquote><p>王润林 | 软件工程师 | AI 技术探索者</p></blockquote><ul><li>零门槛”图生图”技巧，新手友好创作</li><li>文字提示词精髓，精准指挥AI生成</li><li>快速落地应用（如海报设计）</li><li>揭秘 GPT-4o 等模型的图像能力提升</li></ul><h2 id="⏳-活动日程"><a href="#⏳-活动日程" class="headerlink" title="⏳ 活动日程"></a>⏳ 活动日程</h2><table><thead><tr><th align="center">时间</th><th align="center">环节</th></tr></thead><tbody><tr><td align="center">14:00-14:30</td><td align="center">签到 领取福利</td></tr><tr><td align="center">14:30-14:45</td><td align="center">介绍环节</td></tr><tr><td align="center">14:45-15:15</td><td align="center">AI 编程教育的探索之旅</td></tr><tr><td align="center">15:20-16:00</td><td align="center">数据库技术及应用·从原理到实战</td></tr><tr><td align="center">16:10-16:50</td><td align="center">DeepSeek 创新点与本地化部署</td></tr><tr><td align="center">17:00-18:00</td><td align="center">AI 绘图魔法升级·图片也能当指令！</td></tr></tbody></table><h2 id="🚀-活动信息"><a href="#🚀-活动信息" class="headerlink" title="🚀 活动信息"></a>🚀 活动信息</h2><ul><li>时间：2025 年 4 月 26 号 14:00-18:00</li><li>地点：天府五街 200 号菁蓉汇 2A 栋 5 层少颢厅  </li><li>模式：线下为主，线上为辅</li><li>设备：自带电脑</li><li>费用：免费</li></ul><h2 id="🎁-特别惊喜"><a href="#🎁-特别惊喜" class="headerlink" title="🎁 特别惊喜"></a>🎁 特别惊喜</h2><ul><li>✔ 价值 382 元洁牙卡</li><li>✔ AI 工具资源大礼包</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      本次 AI 技术分享会汇聚多位技术专家与教育创新者,共同探索人工智能时代下的技术应用与教学变革。
    
    </summary>
    
    
      <category term="Activity" scheme="https://fcc-cd.dev/categories/Activity/"/>
    
      <category term="Workshop" scheme="https://fcc-cd.dev/categories/Activity/Workshop/"/>
    
    
      <category term="online" scheme="https://fcc-cd.dev/tags/online/"/>
    
      <category term="offline" scheme="https://fcc-cd.dev/tags/offline/"/>
    
      <category term="AI实战" scheme="https://fcc-cd.dev/tags/AI%E5%AE%9E%E6%88%98/"/>
    
      <category term="Agent" scheme="https://fcc-cd.dev/tags/Agent/"/>
    
      <category term="DeepSeek" scheme="https://fcc-cd.dev/tags/DeepSeek/"/>
    
      <category term="AI时代编程教育" scheme="https://fcc-cd.dev/tags/AI%E6%97%B6%E4%BB%A3%E7%BC%96%E7%A8%8B%E6%95%99%E8%82%B2/"/>
    
  </entry>
  
  <entry>
    <title>关于 Git 错误信息的说明</title>
    <link href="https://fcc-cd.dev/article/translation/notes-on-git-error-messages/"/>
    <id>https://fcc-cd.dev/article/translation/notes-on-git-error-messages/</id>
    <published>2024-04-09T16:00:00.000Z</published>
    <updated>2024-05-22T19:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>在写关于 Git 的文章时，我注意到很多人都在纠结 Git 的错误信息。我已经习惯这些错误信息很多年了，所以花了很长时间才明白大家为什么会困惑：</p><ol><li>有时我确实被错误信息弄糊涂了，我只是习惯了被弄糊涂而已</li><li>当 Git 给我的错误信息不是很有参考价值时，我有很多策略来获取更多信息。</li></ol><p>所以，在这篇文章里，我将逐一分析 Git 的错误信息，列出每条信息中我认为容易混淆的地方，并谈谈当我被错误信息弄糊涂时该怎么做。</p><a id="more"></a><h2 id="改进错误信息并不容易"><a href="#改进错误信息并不容易" class="headerlink" title="改进错误信息并不容易"></a>改进错误信息并不容易</h2><p>在开始之前，我想说的是，通过思考这些错误信息令人困惑的原因，让我对维护 Git 的难度肃然起敬。几个月来我一直在思考 Git 的问题，但对于其中一些错误信息，我真的不知道该如何改进。</p><p>在我看来，改进错误信息有以下几点困难：</p><ul><li>如果你想出一个新信息的创意，很难说它是否真的更好！</li><li>改进错误信息之类的工作经常<a href="https://lwn.net/Articles/959768/" target="_blank" rel="noopener">得不到资助</a></li><li>错误信息必须翻译（Git 的错误信息被翻译成 <a href="https://github.com/git/git/tree/master/po" target="_blank" rel="noopener">19 种语言</a>）</li></ul><p>也就是说，如果你觉得这些消息令人困惑，希望这些注释能够在一定程度上帮助澄清它们。</p><h2 id="error-git-push-on-a-diverged-branch"><a href="#error-git-push-on-a-diverged-branch" class="headerlink" title="error: git push on a diverged branch"></a>error: <code>git push</code> on a diverged branch</h2><pre class=" language-shell"><code class="language-shell">git push</code></pre><pre class=" language-text"><code class="language-text">To github.com:jvns/int-exposed! [rejected]        main -&gt; main (non-fast-forward)error: failed to push some refs to 'github.com:jvns/int-exposed'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details.</code></pre><pre class=" language-shell"><code class="language-shell">git status</code></pre><pre class=" language-text"><code class="language-text">On branch mainYour branch and 'origin/main' have diverged,and have 2 and 1 different commits each, respectively.</code></pre><p>我觉得有些事情令人困惑:</p><ol><li>无论分支是 <strong>behind（落后）</strong> 还是 <strong>diverged（偏离）</strong>，您都会收到完全相同的错误信息。从这条信息中无法判断是哪个分支：您需要运行 <code>git status</code> 或 <code>git pull</code> 才能知道。</li><li>它说 <code>failed to push some refs（推送某些引用失败）</code>，但并不完全清楚推送失败的是哪些引用。我相信所有推送失败的引用都会以 <code>！[rejected]</code>在前一行，在本例中，只有 <code>main</code> 分支。</li></ol><h3 id="困惑时我喜欢做的事"><a href="#困惑时我喜欢做的事" class="headerlink" title="困惑时我喜欢做的事"></a>困惑时我喜欢做的事</h3><ul><li>我会运行 <code>git status</code> 来了解当前分支的状态。</li><li>我想我几乎从来没有尝试过一次推送多个分支，所以我通常会完全忽略 Git 关于哪个分支推送失败的说明 - 我只是假设它就是我的当前分支</li></ul><h2 id="error-git-pull-on-a-diverged-branch"><a href="#error-git-pull-on-a-diverged-branch" class="headerlink" title="error: git pull on a diverged branch"></a>error: <code>git pull</code> on a diverged branch</h2><pre class=" language-shell"><code class="language-shell">git pull</code></pre><pre class=" language-text"><code class="language-text">hint: You have divergent branches and need to specify how to reconcile them.hint: You can do so by running one of the following commands sometime beforehint: your next pull:hint:hint:   git config pull.rebase false  # mergehint:   git config pull.rebase true   # rebasehint:   git config pull.ff only       # fast-forward onlyhint:hint: You can replace "git config" with "git config --global" to set a defaulthint: preference for all repositories. You can also pass --rebase, --no-rebase,hint: or --ff-only on the command line to override the configured default perhint: invocation.fatal: Need to specify how to reconcile divergent branches.</code></pre><p>我认为这里最令人困惑的是，git 给你提供了大量的选项：它说，你可以任选其一：</p><ol><li>在本地配置 <code>pull.rebase false</code>, <code>pull.rebase true</code>, 或者 <code>pull.ff only</code></li><li>或全局配置</li><li>或运行 <code>git pull --rebase</code> 或者 <code>git pull --no-rebase</code></li></ol><p>很难想象一个初学 git 的人如何能轻松地利用这个提示，自己整理出所有这些选项。</p><p>如果我向朋友解释这个问题，我会说 “你可以用<code>git pull --rebase</code> 或<code>git pull --no-rebase</code> 来解决这个问题。如果你想设置一个永久的偏好，你可以用<code>git config pull.rebase false</code> 或<code>git config pull.rebase true</code>。</p><p>我觉得 <code>git config pull.ff only</code> 有点多余，因为这是 git 的默认行为（虽然并不总是这样）。</p><h3 id="我喜欢在这里做"><a href="#我喜欢在这里做" class="headerlink" title="我喜欢在这里做"></a>我喜欢在这里做</h3><ul><li>运行 <code>git status</code> 查看当前分支的状态</li><li>也许运行 <code>git log origin/main</code> 或 <code>git log</code> 查看分支提交的情况</li><li>通常会运行 <code>git pull --rebase</code> 来解决它</li><li>如果我想丢弃本地提交（local work）或远程提交（remote work ），有时会运行 <code>git push --force</code> 或 <code>git reset --hard origin/main</code>（例如，因为我不小心提交到了错误的分支，或者因为我在一个只有我在用的个人分支上运行了 <code>git commit --amend</code> 并想强制推送）。</li></ul><h2 id="error-git-checkout-asdf-a-branch-that-doesn’t-exist"><a href="#error-git-checkout-asdf-a-branch-that-doesn’t-exist" class="headerlink" title="error: git checkout asdf (a branch that doesn’t exist)"></a>error: <code>git checkout asdf</code> (a branch that doesn’t exist)</h2><pre class=" language-shell"><code class="language-shell">git checkout asdf</code></pre><pre class=" language-text"><code class="language-text">error: pathspec 'asdf' did not match any file(s) known to git</code></pre><p>这有点奇怪，因为我的意图是检出一个<strong>分支</strong>，但<code>git checkout</code>却在抱怨一个不存在的<strong>文件路径（path）</strong>。</p><p>出现这种情况是因为 <code>git checkout</code> 的第一个参数既可以是分支也可以是文件路径，而 git 无法知道你的意图是哪个。要改进这一点似乎很棘手，但我可能会期待类似 <code>No such branch, commit, or path: asdf（没有这样的分支、提交或路径：asdf）</code>这样的提示。</p><h3 id="我喜欢在这里做-1"><a href="#我喜欢在这里做-1" class="headerlink" title="我喜欢在这里做"></a>我喜欢在这里做</h3><ul><li>理论上，用 <code>git switch</code> 代替会更好，切换分支，但我还是一直用 <code>git checkout</code>。</li><li>一般来说，我只记得我需要把它理解为分支 <code>asdf</code> 不存在。</li></ul><h2 id="error-git-switch-asdf-a-branch-that-doesn’t-exist"><a href="#error-git-switch-asdf-a-branch-that-doesn’t-exist" class="headerlink" title="error: git switch asdf (a branch that doesn’t exist)"></a>error: <code>git switch asdf</code> (a branch that doesn’t exist)</h2><pre class=" language-shell"><code class="language-shell">git switch asdf</code></pre><pre class=" language-text"><code class="language-text">fatal: invalid reference: asdf</code></pre><p><code>git switch</code> 只接受分支作为参数（除非你传递了 <code>-d</code>），那它为什么会说 <code>invalid reference: asdf</code> 而不是 <code>invalid branch: asdf</code> 呢？</p><p>我认为原因在于，在内部，<code>git switch</code> 试图在其错误信息中提供帮助：如果你运行 <code>git switch v0.1</code> 来切换到一个标签，它会说：</p><pre class=" language-shell"><code class="language-shell">git switch v0.1</code></pre><pre class=" language-text"><code class="language-text">fatal: a branch is expected, got tag 'v0.1'`</code></pre><p>所以，git 试图通过 <code>fatal: invalid reference: asdf</code> 传达的意思是“<code>asdf</code>不是一个分支，但也不是一个标签，或者其他任何引用”。从我的各种<a href="https://jvns.ca/blog/2024/03/28/git-poll-results/" target="_blank" rel="noopener">git polls</a>来看，我的印象是很多 git 用户根本不知道什么是 git 中的 <code>reference（引用）</code>，所以我不确定他们是否理解了这一点。</p><h3 id="我喜欢在这里做-2"><a href="#我喜欢在这里做-2" class="headerlink" title="我喜欢在这里做"></a>我喜欢在这里做</h3><p>90% 的情况下，当 git 错误信息中出现 <code>reference</code> 时，我都会在脑海中把它替换成 <code>branch</code>。</p><h2 id="error-git-checkout-HEAD"><a href="#error-git-checkout-HEAD" class="headerlink" title="error: git checkout HEAD^"></a>error: <code>git checkout HEAD^</code></h2><pre class=" language-shell"><code class="language-shell">git checkout HEAD^</code></pre><pre class=" language-text"><code class="language-text">Note: switching to 'HEAD^'.</code></pre><p>您处于 <code>detached HEAD（分离的 HEAD）</code>状态。您可以四处看看，进行试验性改动并提交，还可以通过切换回分支来放弃在此状态下所做的任何提交，而不会影响任何分支。<br>状态下的任何提交，而不会影响任何分支。</p><p>如果你想创建一个新的分支来保留你创建的提交，可以在 switch 命令中使用 -c 来实现（现在或以后）。示例</p><pre class=" language-shell"><code class="language-shell">git switch -c</code></pre><p>或者使用:</p><pre class=" language-shell"><code class="language-shell">git switch -</code></pre><p>通过将配置变量 <code>advice.detachedHead</code> 设为 <code>false</code> 关闭该建议</p><p>HEAD 现在的位置是 <code>182cd3f</code>，添加 <code>swap byte order</code> 按键</p><p>这是一个难题。肯定有很多人对这条信息感到困惑，但显然也有很多人在努力改进它。对于这个问题，我没什么好说的。</p><h3 id="我喜欢在这里做-3"><a href="#我喜欢在这里做-3" class="headerlink" title="我喜欢在这里做"></a>我喜欢在这里做</h3><ul><li>我的 shell 提示会告诉我是否处于分离的 HEAD 状态，一般来说，在这种状态下我不会提交新的内容。</li><li>当我看完我想看的旧提交后，我会运行 <code>git checkout main</code> 或其他命令返回到某个分支</li></ul><h2 id="message-git-status-when-a-rebase-is-in-progress"><a href="#message-git-status-when-a-rebase-is-in-progress" class="headerlink" title="message: git status when a rebase is in progress"></a>message: <code>git status</code> when a rebase is in progress</h2><p>这不是一条错误信息，但我还是觉得它本身有点令人困惑:</p><pre class=" language-shell"><code class="language-shell">git status</code></pre><pre class=" language-text"><code class="language-text">interactive rebase in progress; onto c694cf8Last command done (1 command done):   pick 0a9964d wipNo commands remaining.You are currently rebasing branch 'main' on 'c694cf8'.  (fix conflicts and then run "git rebase --continue")  (use "git rebase --skip" to skip this patch)  (use "git rebase --abort" to check out the original branch)Unmerged paths:  (use "git restore --staged ..." to unstage)  (use "git add ..." to mark resolution)  both modified:   index.htmlno changes added to commit (use "git add" and/or "git commit -a")</code></pre><p>我认为有两点可以说得更清楚:</p><ol><li>如果把 <code>You are currently rebasing branch 'main' on 'c694cf8'.（您正在重定向 ‘c694cf8’ 上的分支main）</code> 放在第一行而不是第五行，我觉得会更好。现在第一行并没有说明您正在重定向哪个分支。</li><li>在本例中， <code>c694cf8</code> 实际在 <code>origin/main</code>， 所以我觉得 <code>You are currently rebasing branch 'main' on 'origin/main'（您正在‘origin/main’上重定向分支‘main’）</code>可能更清楚。</li></ol><h3 id="我喜欢在这里做-4"><a href="#我喜欢在这里做-4" class="headerlink" title="我喜欢在这里做"></a>我喜欢在这里做</h3><p>我的 shell 提示包括了当前正在重置（rebasing）的分支，所以我依赖它而不是 <code>git status</code> 的输出。</p><h2 id="error-git-rebase-when-a-file-has-been-deleted"><a href="#error-git-rebase-when-a-file-has-been-deleted" class="headerlink" title="error: git rebase when a file has been deleted"></a>error: <code>git rebase</code> when a file has been deleted</h2><pre class=" language-shell"><code class="language-shell">git rebase main</code></pre><pre class=" language-text"><code class="language-text">CONFLICT (modify/delete): index.html deleted in 0ce151e (wip) and modified in HEAD.  Version HEAD of index.html left in tree.error: could not apply 0ce151e… wip</code></pre><p>我仍然感到困惑的是，<code>index.html</code> 是在 <code>HEAD</code> 中修改的。但什么是 <code>HEAD</code>？是我开始合并（merge）/重置（rebase）时的提交，还是另一个分支的提交？ 答案是如果是合并，<code>HEAD</code> 就是你的分支，如果是重置，它就是 <code>另一个分支</code>，但我总觉得很难记住。</p><p>我个人认为，如果能在信息中列出分支名称，会更容易理解，就像这样：</p><pre class=" language-text"><code class="language-text">CONFLICT (modify/delete): index.html deleted on `main` and modified on `mybranch`</code></pre><h2 id="error-git-status-during-a-merge-or-rebase-who-is-“them”"><a href="#error-git-status-during-a-merge-or-rebase-who-is-“them”" class="headerlink" title="error: git status during a merge or rebase (who is “them”?)"></a>error: <code>git status</code> during a merge or rebase (who is “them”?)</h2><pre class=" language-shell"><code class="language-shell">git status</code></pre><pre><code>On branch masterYou have unmerged paths.  (fix conflicts and run “git commit”)  (use “git merge –abort” to abort the merge)Unmerged paths:  (use “git add/rm …” as appropriate to mark resolution)    deleted by them: the\_fileno changes added to commit (use “git add” and/or “git commit -a”)</code></pre><p>我觉得这条信息和上一条信息一样让人困惑：上面写着 <code>deleted by them:</code>，但 <code>they</code> 指的是什么，取决于你是进行了合并（merge）、重置（rebase）还是 <code>cherry-pick</code>。</p><ul><li>对于 merge，<code>them</code> 是您合并进来的另一个分支</li><li>对于 rebase，<code>them</code> 是您运行 <code>git rebase</code> 时所在的分支</li><li>对于 cherry-pick， 我猜这是你 cherry-picked 的提交</li></ul><h3 id="困惑时我喜欢做的事-1"><a href="#困惑时我喜欢做的事-1" class="headerlink" title="困惑时我喜欢做的事"></a>困惑时我喜欢做的事</h3><ul><li>努力回忆我做过的事</li><li>如果我不记得了，运行 <code>git show main --stat</code> 或别的什么，看看我在 <code>main</code> 分支上做了什么</li></ul><h2 id="error-git-clean"><a href="#error-git-clean" class="headerlink" title="error: git clean"></a>error: <code>git clean</code></h2><pre class=" language-shell"><code class="language-shell">git clean</code></pre><pre class=" language-text"><code class="language-text">fatal: clean.requireForce defaults to true and neither -i, -n, nor -f given; refusing to clean</code></pre><p>我只是觉得这有点令人困惑，你需要查一下 <code>-i</code>、<code>-n</code> 和 <code>-f</code> 是什么意思才能理解这个错误信息。我个人太懒了，所以即使我用了 10 年的 <code>git clean</code> 也不知道 <code>-i</code> 代表什么（<code>interactive</code>），直到我写下这篇文章。</p><h3 id="困惑时我喜欢做的事-2"><a href="#困惑时我喜欢做的事-2" class="headerlink" title="困惑时我喜欢做的事"></a>困惑时我喜欢做的事</h3><p>通常，我只是胡乱运行 <code>git clean -f</code> 来删除所有未跟踪的文件，并寄希望于最好的结果，不过现在我知道了 <code>-i</code> 代表什么，也许会改用 <code>git clean -i</code>。看起来安全多了。</p><h2 id="就这样！"><a href="#就这样！" class="headerlink" title="就这样！"></a>就这样！</h2><p>希望这些内容对您有所帮助！</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;在写关于 Git 的文章时，我注意到很多人都在纠结 Git 的错误信息。我已经习惯这些错误信息很多年了，所以花了很长时间才明白大家为什么会困惑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有时我确实被错误信息弄糊涂了，我只是习惯了被弄糊涂而已&lt;/li&gt;
&lt;li&gt;当 Git 给我的错误信息不是很有参考价值时，我有很多策略来获取更多信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，在这篇文章里，我将逐一分析 Git 的错误信息，列出每条信息中我认为容易混淆的地方，并谈谈当我被错误信息弄糊涂时该怎么做。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="Article" scheme="https://fcc-cd.dev/categories/Article/"/>
    
      <category term="Translation" scheme="https://fcc-cd.dev/categories/Article/Translation/"/>
    
    
  </entry>
  
  <entry>
    <title>你应该使用的现代 Git 命令和功能</title>
    <link href="https://fcc-cd.dev/article/translation/modern-git-commands-and-features-you-should-be-using/"/>
    <id>https://fcc-cd.dev/article/translation/modern-git-commands-and-features-you-should-be-using/</id>
    <published>2024-03-04T06:30:00.000Z</published>
    <updated>2024-04-05T11:25:00.000Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>我们所有软件工程师每天都在使用 <code>git</code>，但大多数人只接触过最基本的命令，如 <code>add</code>、<code>commit</code>、<code>push</code> 或者 <code>pull</code>，好像还停留在 2005 年。</p><p>不过，Git 从那时起引入了许多功能，使用它们能让你的生活变得更轻松，下面就让我们来了解一下最近添加的一些现代 Git 命令。</p><a id="more"></a><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>自 2019 年以来，或者更准确地说，自 Git 2.23 版引入以来，我们可以使用 <code>git switch</code> 来切换分支：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> switch other-branch<span class="token function">git</span> switch -  <span class="token comment" spellcheck="true"># 切换回上一个分支，类似于 "cd -"</span><span class="token function">git</span> switch remote-branch  <span class="token comment" spellcheck="true"># 直接切换到远程分支并开始跟踪</span></code></pre><p><code>git checkout</code> 是一个非常灵活的命令。它可以（除其他外）签出或恢复特定文件甚至特定提交，而新的 <code>git switch</code> 只能切换分支。此外，<code>switch</code> 还会执行额外的正确性检查，而 <code>checkout</code> 则不会，例如，如果会导致本地改动丢失，<code>switch</code> 就会中止操作。</p><h2 id="Restore"><a href="#Restore" class="headerlink" title="Restore"></a>Restore</h2><p>Git 2.23 版新增的另一个子命令/功能是 <code>git restore</code>，我们可以用它将文件恢复到上次提交的版本：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取消对文件的修改，与 "git reset some-file.py" 相同</span><span class="token function">git</span> restore --staged some-file.py<span class="token comment" spellcheck="true"># 取消并丢弃对文件所做的更改，与 "git checkout some-file.py" 相同</span><span class="token function">git</span> restore --staged --worktree some-file.py<span class="token comment" spellcheck="true"># 将文件恢复到之前的某个提交，与 "git reset commit -- some-file.py" 相同</span><span class="token function">git</span> restore --source HEAD~2 some-file.py</code></pre><p>上述代码段中的注释解释了各种 <code>git restore</code> 使用。一般来说， <code>git restore</code> 替换和简化 <code>git reset</code> 和 <code>git checkout</code> 的使用场景，它们的功能过于复杂。关于 <code>revert</code>、<code>restore</code> 和 <code>reset</code> 的比较，请参阅本文档。</p><h2 id="Sparse-Checkout"><a href="#Sparse-Checkout" class="headerlink" title="Sparse Checkout"></a>Sparse Checkout</h2><p>下一个是 <code>git sparse-checkout</code>，这是在 2020 年 1 月 13 日发布的 Git 2.25 中添加的一个不起眼的功能。</p><p>比方说，你有一个大的 <code>monorepo</code>，其中的微服务被分隔到各个目录中，由于版本库太大，<code>checkout</code> 或 <code>status</code> 等命令执行起来超级慢，但也许你真的只需要处理单个子树/目录。那么，<code>git sparse-checkout</code> 就能帮到你：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> clone --no-checkout https://github.com/derrickstolee/sparse-checkout-example$ <span class="token function">cd</span> sparse-checkout-example$ <span class="token function">git</span> sparse-checkout init --cone  <span class="token comment" spellcheck="true"># 配置 git， 只匹配根目录下的文件</span>$ <span class="token function">git</span> checkout main  <span class="token comment" spellcheck="true"># 只检出根目录中的文件</span>$ <span class="token function">ls</span>bootstrap.sh  LICENSE.md  README.md$ <span class="token function">git</span> sparse-checkout <span class="token keyword">set</span> service/common$ <span class="token function">ls</span>bootstrap.sh  LICENSE.md  README.md  <span class="token function">service</span>$ tree <span class="token keyword">.</span><span class="token keyword">.</span>├── bootstrap.sh├── LICENSE.md├── README.md└── <span class="token function">service</span>    ├── common    │   ├── app.js    │   ├── Dockerfile    <span class="token punctuation">..</span>. <span class="token punctuation">..</span>.</code></pre><p>在上面的例子中，我们首先 <code>clone repo</code>，但并没有 <code>checkout</code> 所有文件。然后使用 <code>git sparse-checkout init --cone</code> 配置 git 只匹配仓库根目录下的文件。这样，在运行签出后，我们只有 3 个文件，而不是整棵树。要下载/检出特定目录，我们使用 <code>git sparse-checkout set ....</code></p><p>如前所述，这在本地处理庞大的版本库时非常方便，但在 CI/CD 中，当你只想构建/部署 <code>monorepo</code> 的一部分，而不需要检出所有内容时，这对提高流水线性能同样有用。</p><p>有关 <code>sparse-checkout</code> 的详细介绍，请参阅本文。</p><h2 id="Worktree"><a href="#Worktree" class="headerlink" title="Worktree"></a>Worktree</h2><p>一个人可能需要同时在单个应用程序（版本库）中开发多个功能，或者当你正在处理某个功能请求时，可能会出现一个 <code>critical</code> 级别的错误，这种情况并不少见。</p><p>在这种情况下，您要么需要克隆多个版本/分支的版本库，要么就需要隐藏/丢弃当时正在处理的内容。2018 年 9 月 24 日发布的 <code>git worktree</code> 就是解决这些情况的办法：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> branch<span class="token comment" spellcheck="true"># * dev</span><span class="token comment" spellcheck="true"># master</span><span class="token function">git</span> worktree list<span class="token comment" spellcheck="true"># /.../some-repo  ews5ger [dev]</span><span class="token function">git</span> worktree add -b hotfix ./hotfix master<span class="token comment" spellcheck="true"># 准备 worktree (new branch 'hotfix')</span><span class="token comment" spellcheck="true"># HEAD 现在是 5ea9faa 已签名提交。</span><span class="token function">git</span> worktree list<span class="token comment" spellcheck="true"># /.../test-repo         ews5ger [dev]</span><span class="token comment" spellcheck="true"># /.../test-repo/hotfix  5ea9faa [hotfix]</span><span class="token function">cd</span> hotfix/  <span class="token comment" spellcheck="true"># 干净的 worktree, 你可以在其中进行修改并推送</span></code></pre><p>该命令允许我们同时签出同一版本库的多个分支。在上面的例子中，我们有两个分支 dev 和 master。假设我们正在开发分支中开发功能，但有人告诉我们要进行紧急错误修复。与其将更改存储起来并重置分支，不如在主分支的 ./hotfix 子目录下创建一个新的 worktree。然后，我们就可以移动到该目录，进行修改、推送并返回到原始 worktree。</p><p>更多详细内容，请参阅本文。</p><h2 id="Bisect"><a href="#Bisect" class="headerlink" title="Bisect"></a>Bisect</h2><p>最后但并非最不重要的是 <code>git bisect</code>，它并不新鲜（Git 1.7.14，2012 年 5 月 13 日发布），但大多数人只使用 2005 年左右的 git 功能，所以我觉得还是值得展示一下。</p><p>正如文档页面所描述的：<code>git bisect</code>，使用二进制搜索查找引入错误的提交：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> bisect start<span class="token function">git</span> bisect bad HEAD  <span class="token comment" spellcheck="true"># 提供出问题的提交</span><span class="token function">git</span> bisect good 479420e  <span class="token comment" spellcheck="true"># 提供你知道正常运行的提交</span><span class="token comment" spellcheck="true"># Bisecting: 2 revisions left to test after this (roughly 1 step)</span><span class="token comment" spellcheck="true"># [3258487215718444a6148439fa8476e8e7bd49c8] Refactoring.</span><span class="token comment" spellcheck="true"># 测试当前提交...</span><span class="token function">git</span> bisect bad  <span class="token comment" spellcheck="true"># If the commit doesn't work</span><span class="token function">git</span> bisect good <span class="token comment" spellcheck="true"># If the commit works</span><span class="token comment" spellcheck="true"># 根据最后一条命令，Git 在 bad 与 good 之间进行二分查找</span><span class="token comment" spellcheck="true"># 继续测试直到找原因</span><span class="token function">git</span> bisect reset  <span class="token comment" spellcheck="true"># 重置为初始提交</span></code></pre><p>我们先用 <code>git bisect start</code> 显式启动分段会话，然后提供不工作的提交（bad 的提交，很可能是 HEAD）和最后一次已知的正常运行提交或标记。有了这些信息，git 就会检查出介于 <code>bad</code> 和 <code>good</code> 提交之间的一个提交。这时，我们需要测试该版本是否存在漏洞，然后用 git bisect good 告诉 git 它能正常工作，或用 git bisect bad 告诉 git 它不能正常工作。我们不断重复这个过程，直到没有提交，git 就会告诉我们哪个提交引入了问题。</p><p>我建议你去文档页面看看，那里有更多关于 <code>git bisect</code> 的选项，包括可视化、重放或跳过提交。</p><p>如果你搜索一些与 <code>git</code> 相关的问题，你很可能会在 StackOverflow 上找到有几千个向上投票的答案的问题。虽然这个答案很可能仍然有效，但很可能已经过时，因为它是 10 年前写的。因此，可能还有更好、更简单、更容易的方法。因此，当遇到一些 <code>git</code> 问题时，我建议查看 <code>git</code> 文档，了解最新的命令，这些命令都有很多很好的示例，或者浏览 <code>man</code> 页面，了解多年来添加到老命令中的很多标记（flags）和选项（options）。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;我们所有软件工程师每天都在使用 &lt;code&gt;git&lt;/code&gt;，但大多数人只接触过最基本的命令，如 &lt;code&gt;add&lt;/code&gt;、&lt;code&gt;commit&lt;/code&gt;、&lt;code&gt;push&lt;/code&gt; 或者 &lt;code&gt;pull&lt;/code&gt;，好像还停留在 2005 年。&lt;/p&gt;
&lt;p&gt;不过，Git 从那时起引入了许多功能，使用它们能让你的生活变得更轻松，下面就让我们来了解一下最近添加的一些现代 Git 命令。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="Article" scheme="https://fcc-cd.dev/categories/Article/"/>
    
      <category term="Translation" scheme="https://fcc-cd.dev/categories/Article/Translation/"/>
    
    
  </entry>
  
  <entry>
    <title>我不再使用 React.setState 的 3 个理由</title>
    <link href="https://fcc-cd.dev/article/translation/3-reasons-why-i-stopped-using-react-setstate/"/>
    <id>https://fcc-cd.dev/article/translation/3-reasons-why-i-stopped-using-react-setstate/</id>
    <published>2024-02-09T14:05:00.000Z</published>
    <updated>2024-02-12T08:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p><a href="https://medium.com/@mweststrate?source=post_page-----ab73fc67a42e--------------------------------" target="_blank" rel="noopener"><img src="https://miro.medium.com/v2/resize:fill:88:88/1*XWCjUzWvB5KUrmXT1kxOOA.jpeg" alt="Michel Weststrate"></a></p><p><a href="https://blog.cloudboost.io/?source=post_page-----ab73fc67a42e--------------------------------" target="_blank" rel="noopener"><img src="https://miro.medium.com/v2/resize:fill:48:48/1*a8_IkAXKt7ff5oUv_QmQSw.png" alt="CloudBoost"></a></p><p><a href="https://medium.com/@mweststrate?source=post_page-----ab73fc67a42e--------------------------------" target="_blank" rel="noopener">Michel Weststrate</a> published in <a href="https://blog.cloudboost.io/?source=post_page-----ab73fc67a42e--------------------------------" target="_blank" rel="noopener">CloudBoost</a> · Jun 15, 2016</p><p>自几个月前，我已在所有我新写的 React 组件弃用 React 的 <em>setState</em> 。别误会我，我没有弃用本地组件状态，我只是不再用 React 去管理它，并且令人愉快！</p><p>使用 <em>setState</em> 对初学者来说很棘手。即使经验丰富的 React 程序员在使用 React 自有状态机制时，也很容易引入微妙的 bug，例如：</p><img src="/article/translation/3-reasons-why-i-stopped-using-react-setstate/React-state.gif" class=""><p>忘记 React 状态是异步的而引入了 bug，日志输出总是在后面一项。</p><p>这篇优秀的 React <a href="https://facebook.github.io/react/docs/component-api.html" target="_blank" rel="noopener">文档</a>总结了错误使用 <em>setState</em> 的各种情况：</p><img src="/article/translation/3-reasons-why-i-stopped-using-react-setstate/React-docs.webp" class=""><a id="more"></a><p>总的来说，使用 <em>setState</em> 有三种问题：</p><h2 id="1-setState-是异步的"><a href="#1-setState-是异步的" class="headerlink" title="1. setState 是异步的"></a>1. setState 是异步的</h2><p>很多开发者一开始没有意识到这一点，但 setState 是 <em>异步的</em> 。如果你设置一些状态后再查看一下，你将仍看到旧状态。这是 setState 最棘手的部分。setState 调用看起来不像异步的，天真地调用 setState 会引入非常微妙的 bug。接下来的 gist 非常好地演示了这一点：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">class</span> <span class="token class-name">Select</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>      selection<span class="token punctuation">:</span> props<span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">onKeyDown</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>onKeyDown<span class="token punctuation">}</span></span> <span class="token attr-name">tabIndex</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span>        <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span>            <span class="token attr-name">className</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>value <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>selection <span class="token operator">?</span> <span class="token string">"selected"</span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">}</span></span>            <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span></span>            <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onSelect</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span></span>          <span class="token punctuation">&gt;</span></span>            <span class="token punctuation">{</span>value<span class="token punctuation">}</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">onSelect</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      selection<span class="token punctuation">:</span> value    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fireOnSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  onKeyDown <span class="token operator">=</span> e <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> values <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>    <span class="token keyword">const</span> idx <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>selection<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>keyCode <span class="token operator">===</span> <span class="token number">38</span> <span class="token operator">&amp;&amp;</span> idx <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* 上 */</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        selection<span class="token punctuation">:</span> values<span class="token punctuation">[</span>idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>keyCode <span class="token operator">===</span> <span class="token number">40</span> <span class="token operator">&amp;&amp;</span> idx <span class="token operator">&lt;</span> values<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* 下 */</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        selection<span class="token punctuation">:</span> values<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fireOnSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">fireOnSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>onSelect <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">onSelect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>selection<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 不是你预期的…… */</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Select</span>    <span class="token attr-name">values</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token string">"状态"</span><span class="token punctuation">,</span> <span class="token string">"应该"</span><span class="token punctuation">,</span> <span class="token string">"是"</span><span class="token punctuation">,</span> <span class="token string">"同步的"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>    <span class="token attr-name">onSelect</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>value <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span></span>  <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span>  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>猛地一看，这可能看起来还不错。两个事件处理器和一个工具函数在 <em>onSelect</em> 存在时触发事件。然而，这个 <em>Select</em> 组件有个 bug，在上面的 GIF 图中被很好地演示。 <em>onSelect</em> 总是带着 <em>state.selection</em> 旧值被触发，因为 <em>fireOnSelect</em> 工具函数执行时，<em>setState</em> <em>还</em> 没做完他的工作。我认为此处 React 至少可以把这个方法改名为 _scheduleState_，或让回调参数变成必填。</p><blockquote><p>这个 bug 很容易修复，最棘手的部分是意识到它在这儿。</p></blockquote><p><strong><em>编辑于 2018 年 1 月 25 日：</em></strong> <a href="https://medium.com/u/a3a8af6addc1?source=post_page-----ab73fc67a42e--------------------------------" target="_blank" rel="noopener"><strong><em>Dan Abramov</em></strong></a> <strong><em>已经热心地写下一个广为人知而有力的</em></strong> <a href="https://github.com/facebook/react/issues/11527#issuecomment-360199710" target="_blank" rel="noopener"><strong><em>解释</em></strong></a> <strong><em>，从设计的角度讲为什么 setState 是异步的。</em></strong></p><h2 id="2-setState-引起没必要的渲染"><a href="#2-setState-引起没必要的渲染" class="headerlink" title="2. setState 引起没必要的渲染"></a>2. setState 引起没必要的渲染</h2><p>使用 <em>setState</em> 的第二个问题是，它总会触发重渲染。通常这些重渲染是不必要的。你可以使用 React 性能工具中的 <a href="https://facebook.github.io/react/docs/perf.html#perf.printwastedmeasurements" target="_blank" rel="noopener"><em>printWasted</em></a> 方法来找出它什么时间发生。但粗略地讲，有几种原因是一次重渲染为什么可能是不必要的：</p><ul><li>新状态实际上和之前的一模一样。这通常可以通过实现 <em>shouldComponentUpdate</em> 来解决。你可能已经使用了一个（纯渲染）库来解决。</li><li>有时改变的状态与渲染有关，但并不是所有情况都是。比如当有些数据只条件性可见。</li><li>第三，正如 Aria Buckles <a href="https://youtu.be/2Qu-Ulrsfl8?t=12m09s" target="_blank" rel="noopener">在 React Europe 2015 上的演讲</a>所指出的那样，有时候实例状态根本与渲染无关！这通常是与管理事件监听器、计时器 ID 等相关的家务状态。</li></ul><h2 id="3-setState-无法捕获所有组件状态"><a href="#3-setState-无法捕获所有组件状态" class="headerlink" title="3. setState 无法捕获所有组件状态"></a>3. setState 无法捕获所有组件状态</h2><p>接上面最后一点，不是所有组件状态都应该用 <em>setState</em> 存储和更新。更多复杂组件通常有基于生命周期钩子的管理需求，去管理计时器、网络请求和事件等。用 <em>setState</em> 管理这些不仅引起不必要的渲染，还会引起相关生命周期钩子被重新触发，引起奇怪的问题。</p><h1 id="用-MobX-管理本地组件状态"><a href="#用-MobX-管理本地组件状态" class="headerlink" title="用 MobX 管理本地组件状态"></a>用 MobX 管理本地组件状态</h1><p>（惊喜，惊喜）在 <a href="http://www.mendix.com/" target="_blank" rel="noopener">Mendix</a>，我们已经依赖 MobX 管理我们所有的状态存储。然而，我们曾使用 React 自有状态机制来处理本地组件状态。最近，我们已经切换到用 MobX 管理本地组件状态。它看起来就像这样：</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"mobx"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> observer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"mobx-react"</span><span class="token punctuation">;</span>@observer<span class="token keyword">class</span> <span class="token class-name">Select</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  @observable selection <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* MobX 管理的实例 state */</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>selection <span class="token operator">=</span> props<span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">onKeyDown</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>onKeyDown<span class="token punctuation">}</span></span> <span class="token attr-name">tabIndex</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span>        <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>values<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span>            <span class="token attr-name">className</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>value <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selection <span class="token operator">?</span> <span class="token string">"selected"</span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">}</span></span>            <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span></span>            <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onSelect</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span></span>          <span class="token punctuation">&gt;</span></span>            <span class="token punctuation">{</span>value<span class="token punctuation">}</span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">onSelect</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>selection <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fireOnSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  onKeyDown <span class="token operator">=</span> e <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> values <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>    <span class="token keyword">const</span> idx <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>selection<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>keyCode <span class="token operator">===</span> <span class="token number">38</span> <span class="token operator">&amp;&amp;</span> idx <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* 上 */</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>selection <span class="token operator">=</span> values<span class="token punctuation">[</span>idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>keyCode <span class="token operator">===</span> <span class="token number">40</span> <span class="token operator">&amp;&amp;</span> idx <span class="token operator">&lt;</span> values<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* 下 */</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>selection <span class="token operator">=</span> values<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fireOnSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">fireOnSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>onSelect <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">onSelect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>selection<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 解决啦！ */</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Select</span>    <span class="token attr-name">values</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token string">"状态"</span><span class="token punctuation">,</span> <span class="token string">"应该"</span><span class="token punctuation">,</span> <span class="token string">"是"</span><span class="token punctuation">,</span> <span class="token string">"同步的"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>    <span class="token attr-name">onSelect</span><span class="token script language-javascript"><span class="token punctuation">=</span><span class="token punctuation">{</span>value <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span></span>  <span class="token punctuation">/&gt;</span></span><span class="token punctuation">,</span>  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>为了完整性的缘故：</p><img src="/article/translation/3-reasons-why-i-stopped-using-react-setstate/MobX-state.gif" class=""><p>当使用一个同步状态机制时，没有未预期的 bug。</p><p>上面的代码片段不但更简洁，MobX 也解决了所有 setState 相关问题：</p><p>对状态的改变被立即反应到本地组件状态，让我们的逻辑更简单、代码复用更容易。你不必找补“状态可能还没更新”的事实。</p><p>MobX 在运行时确定哪些可观察量与渲染相关。所以，暂时与渲染无关的可观察量将不会触发重渲染，直到它们重新相关为止。因此，当把渲染无关的类属性变为 <em>@observable</em>时，也完全不存在渲染惩罚（或生命周期问题）。</p><p>所以，可渲染和不可渲染的状态都能被统一处理。同时，现在我们组件存储的状态和存在其它存储的状态工作方式一模一样。这让重构组件有些琐碎，并移动本地组件状态进一个独立存储，反之亦然。详见这个 <a href="https://egghead.io/lessons/javascript-mobx-and-react-intro-syncing-the-ui-with-the-app-state-using-observable-and-observer" target="_blank" rel="noopener">egghead</a> 教程的演示。</p><blockquote><p>MobX 高效地把你的组件转化为小型 store</p></blockquote><p>此外，当为 state 应用 observable 时，不会再犯直接向 <em>state</em> 对象赋值的菜鸟错误了。哦，不再操心实现 <em>shouldComponentUpdate</em> 或 <em>PureRenderMixin_，MobX 已处理好这些。最后，你可能好奇，如果我想等到 _setState</em> 完成呢？嗯，你仍可用 <em>compentDidUpdate</em> 生命周期钩子来实现。</p><h2 id="听起来好酷！我如何开始使用-MobX？"><a href="#听起来好酷！我如何开始使用-MobX？" class="headerlink" title="听起来好酷！我如何开始使用 MobX？"></a>听起来好酷！我如何开始使用 MobX？</h2><p>非常简单，照着 <a href="https://mobxjs.github.io/mobx/getting-started.html" target="_blank" rel="noopener">10 分钟交互介绍</a> 或观看前述视频。你可以简单地从你的代码库挑一个组件，把 <em>@observer</em> 拍在上面，并引入一些 <em>@observable</em> 属性。你甚至都不需要替换你现有的 <em>setState</em> 调用，当使用 MobX 时它们依然可用。尽管不出几分钟你可能就会发现它们是如此复杂，无论如何你将会把它们换掉 🙂。（哦，如果你不喜欢装饰器，不用担心，它也<a href="https://github.com/mobxjs/mobx/blob/gh-pages/docs/best/syntax.md#react-components" target="_blank" rel="noopener">适用于 ES5</a>）。</p><h2 id="长话短说："><a href="#长话短说：" class="headerlink" title="长话短说："></a>长话短说：</h2><p>我已不再用 React 管理本地组件状态，我用 MobX 代替，现在 React 就真的成了“仅为视图”🙂。MobX 现在同时管理本地组件状态和 store 状态。它是简洁的、同步的、高效的和统一的。从经验来看，我发现 MobX 比 React 自有 <em>setState</em> 更容易向 React 初学者解释，它让我们的组件干净而简单。</p><ul><li>把 <em>setState</em> 用于状态管理的 <a href="http://jsbin.com/yelazuvamo/edit?js%2Cconsole%2Coutput=" target="_blank" rel="noopener">JSBin</a></li><li>把 <em>MobX observables</em> 用于状态管理的 <a href="http://jsbin.com/sofezamavi/1/edit?js%2Cconsole%2Coutput=" target="_blank" rel="noopener">JSBin</a></li></ul><hr><h2 id="译者后记"><a href="#译者后记" class="headerlink" title="译者后记"></a>译者后记</h2><p>MobX 之父这篇文章给我的启发不限于废弃 React 类组件的 <code>this.setState()</code>，更提醒我 ——</p><blockquote><p><strong>MobX 装饰器 API</strong> 的设计是为了增强 ECMAScript class，<strong>为面向对象前端代码提供响应式状态管理</strong>，而非发明一套全新的写法。</p></blockquote><p>因此，一切基于 <code>class</code> 的组件引擎均可用 MobX 管理组件内外部状态。而<strong>基于类继承的 Web components</strong> 不但完全兼容 MobX 装饰器 API，其 DOM props（元素对象属性）的<strong>可变数据</strong>特性则更是与 MobX 的响应式状态完美契合！</p><p>于是，在通读全文、醍醐灌顶之后，我遵循上述思路，一气呵成地在 2022 年正月十五重写出了 <a href="https://github.com/EasyWebApp/WebCell/commit/91ee45e7f951c28819bbe93c52139b34dd45f053" target="_blank" rel="noopener">WebCell v3 原型版</a>。接下来的两年虽因忙于创业公司而搁置开发，但在 React 生态中<a href="https://github.com/orgs/idea2app/repositories?q=mobx&amp;type=all" target="_blank" rel="noopener">对原文 MobX 思想的深入实践</a>，为 2024 新年一个月的闭关重写提供了<a href="https://www.zhihu.com/question/456685038/answer/3142780397" target="_blank" rel="noopener">丰富的设计经验</a>。</p><p>最后，原文中的 React + MobX + JS 代码若改写为 <a href="https://web-cell.dev/" target="_blank" rel="noopener">WebCell</a> + MobX + TS，同样简洁清晰：</p><p><a href="https://codesandbox.io/p/devbox/webcell-mobx-state-pjk262?file=%2Fsrc%2Fselect.tsx&amp;embed=1&amp;showConsole=true" target="_blank" rel="noopener"><img src="https://codesandbox.io/static/img/play-codesandbox.svg" alt="Edit WebCell + MobX state"></a></p><pre class=" language-ts"><code class="language-ts"><span class="token keyword">import</span> <span class="token punctuation">{</span> DOMRenderer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"dom-renderer"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"mobx"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> WebCell<span class="token punctuation">,</span> attribute<span class="token punctuation">,</span> component<span class="token punctuation">,</span> observer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"web-cell"</span><span class="token punctuation">;</span><span class="token keyword">interface</span> <span class="token class-name">SelectProps</span> <span class="token punctuation">{</span>  values<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">Select</span> <span class="token keyword">extends</span> <span class="token class-name">WebCell</span><span class="token operator">&lt;</span>SelectProps<span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>@<span class="token function">component</span><span class="token punctuation">(</span><span class="token punctuation">{</span> tagName<span class="token punctuation">:</span> <span class="token string">"wc-select"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>@observer<span class="token keyword">class</span> <span class="token class-name">Select</span> <span class="token keyword">extends</span> <span class="token class-name">HTMLElement</span> <span class="token keyword">implements</span> <span class="token class-name">WebCell</span><span class="token operator">&lt;</span>SelectProps<span class="token operator">&gt;</span> <span class="token punctuation">{</span>  @attribute  @observable  accessor values<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* MobX 管理的实例 props */</span>  @observable  accessor selection <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* MobX 管理的实例 state */</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> values<span class="token punctuation">,</span> selection <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>ul tabIndex<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span> onKeydown<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>onKeyDown<span class="token punctuation">}</span><span class="token operator">&gt;</span>        <span class="token punctuation">{</span>values<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>          <span class="token operator">&lt;</span>li            key<span class="token operator">=</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span>            className<span class="token operator">=</span><span class="token punctuation">{</span>value <span class="token operator">===</span> selection <span class="token operator">?</span> <span class="token string">"selected"</span> <span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">}</span>            onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onSelect</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span>          <span class="token operator">&gt;</span>            <span class="token punctuation">{</span>value<span class="token punctuation">}</span>          <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">onSelect</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>selection <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fireOnSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  onKeyDown <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> key <span class="token punctuation">}</span><span class="token punctuation">:</span> KeyboardEvent<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span> values <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> index <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>selection<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">"ArrowUp"</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>selection <span class="token operator">=</span> values<span class="token punctuation">[</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">"ArrowDown"</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> values<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>selection <span class="token operator">=</span> values<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fireOnSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token function">fireOnSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">"select"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selection<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">new</span> <span class="token class-name">DOMRenderer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>  <span class="token operator">&lt;</span>Select    values<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token string">"状态"</span><span class="token punctuation">,</span> <span class="token string">"应该"</span><span class="token punctuation">,</span> <span class="token string">"是"</span><span class="token punctuation">,</span> <span class="token string">"同步的"</span><span class="token punctuation">]</span><span class="token punctuation">}</span>    onSelect<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">{</span> detail <span class="token punctuation">}</span><span class="token punctuation">:</span> CustomEvent<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>detail<span class="token punctuation">)</span><span class="token punctuation">}</span>  <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>  document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#app"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;a href=&quot;https://medium.com/@mweststrate?source=post_page-----ab73fc67a42e--------------------------------&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://miro.medium.com/v2/resize:fill:88:88/1*XWCjUzWvB5KUrmXT1kxOOA.jpeg&quot; alt=&quot;Michel Weststrate&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.cloudboost.io/?source=post_page-----ab73fc67a42e--------------------------------&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://miro.medium.com/v2/resize:fill:48:48/1*a8_IkAXKt7ff5oUv_QmQSw.png&quot; alt=&quot;CloudBoost&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@mweststrate?source=post_page-----ab73fc67a42e--------------------------------&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Michel Weststrate&lt;/a&gt; published in &lt;a href=&quot;https://blog.cloudboost.io/?source=post_page-----ab73fc67a42e--------------------------------&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CloudBoost&lt;/a&gt; · Jun 15, 2016&lt;/p&gt;
&lt;p&gt;自几个月前，我已在所有我新写的 React 组件弃用 React 的 &lt;em&gt;setState&lt;/em&gt; 。别误会我，我没有弃用本地组件状态，我只是不再用 React 去管理它，并且令人愉快！&lt;/p&gt;
&lt;p&gt;使用 &lt;em&gt;setState&lt;/em&gt; 对初学者来说很棘手。即使经验丰富的 React 程序员在使用 React 自有状态机制时，也很容易引入微妙的 bug，例如：&lt;/p&gt;
&lt;img src=&quot;/article/translation/3-reasons-why-i-stopped-using-react-setstate/React-state.gif&quot; class=&quot;&quot;&gt;

&lt;p&gt;忘记 React 状态是异步的而引入了 bug，日志输出总是在后面一项。&lt;/p&gt;
&lt;p&gt;这篇优秀的 React &lt;a href=&quot;https://facebook.github.io/react/docs/component-api.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文档&lt;/a&gt;总结了错误使用 &lt;em&gt;setState&lt;/em&gt; 的各种情况：&lt;/p&gt;
&lt;img src=&quot;/article/translation/3-reasons-why-i-stopped-using-react-setstate/React-docs.webp&quot; class=&quot;&quot;&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="Article" scheme="https://fcc-cd.dev/categories/Article/"/>
    
      <category term="Translation" scheme="https://fcc-cd.dev/categories/Article/Translation/"/>
    
    
      <category term="Web" scheme="https://fcc-cd.dev/tags/Web/"/>
    
      <category term="React" scheme="https://fcc-cd.dev/tags/React/"/>
    
      <category term="front-end" scheme="https://fcc-cd.dev/tags/front-end/"/>
    
      <category term="state" scheme="https://fcc-cd.dev/tags/state/"/>
    
      <category term="MobX" scheme="https://fcc-cd.dev/tags/MobX/"/>
    
  </entry>
  
  <entry>
    <title>AI 网页爬虫实验（用 GPT-4 解析 HTML）</title>
    <link href="https://fcc-cd.dev/article/translation/web-scraping-and-parsing-experiment-with-ai-openai/"/>
    <id>https://fcc-cd.dev/article/translation/web-scraping-and-parsing-experiment-with-ai-openai/</id>
    <published>2023-11-09T16:00:00.000Z</published>
    <updated>2023-11-12T02:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<html><head><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"></head><body><p>从网络搜索结果中解析数据往往是一件麻烦事。但如果有一种方法能让这一艰苦的过程变得轻而易举呢？让我们尝试一下 OpenAI 的新人工智能模型吧。</p><p><a href="https://serpapi.com/blog/author/hilman/" target="_blank" rel="noopener"><img src="/blog/content/images/size/w100/2023/10/profile-picture.png" alt="Hilman Ramadhan"></a></p><p><strong>Hilman Ramadhan</strong></p><a id="more"></a><p>我一直很惊讶 OpenAI 的 chatGPT 在回答问题方面的表现，以及 Dall-e 3 制作精美图片的能力。现在，有了新的模型，让我们看看人工智能如何处理我们的网络搜索任务，特别是解析搜索引擎结果。我们都知道，从原始 HTML 中提取解析数据通常会很麻烦。但是，如果有一种方法可以将这一艰苦的过程变得轻而易举呢？</p><blockquote><p>最近（2023 年 11 月），OpenAI 团队召开了 <a href="https://www.youtube.com/watch?v=U9mJuUkhUzk" target="_blank" rel="noopener">首次开发者大会：DevDay（欢迎先观看）</a>。其中一个令人兴奋的公告是 GPT-4 的更大的上下文窗口。新的 GPT-4 Turbo 型号功能更强、更便宜，而且支持 128K 上下文窗口。</p></blockquote><p><img src="https://serpapi.com/blog/content/images/2023/11/web-scraping-search-results-with-AI-1.webp" alt=""></p><p>封面插图：OpenAI 的 AI 网络爬虫。</p><h2 id="我们的小实验"><a href="#我们的小实验" class="headerlink" title="我们的小实验"></a>我们的小实验</h2><p>在过去，我们<a href="https://serpapi.com/blog/llms-vs-serpapi/" target="_blank" rel="noopener">比较了一些开源和付费 LLM 将纯文本数据转换成简单格式的能力</a>，并开发了一个<a href="https://serpapi.com/blog/real-world-example-of-ai-powered-parsing/" target="_blank" rel="noopener">人工智能驱动的解析器</a>。</p><p>这一次，我们将提升挑战的难度。</p><ul><li>直接从原始 HTML 数据中抓取。</li><li>转换成我们需要的特定 JSON 格式。</li><li>只用很少的开发时间。</li></ul><h3 id="我们的目标"><a href="#我们的目标" class="headerlink" title="我们的目标"></a>我们的目标</h3><ul><li>抓取一个结构良好的网站（作为热身）。</li><li>从 Google 搜索结果页面返回自然搜索结果（organic results）。</li><li>从谷歌 SERP 返回 “人们还问（相关问题）”部分。</li><li>从 Google MAPS 返回当地搜索结果。</li></ul><blockquote><p>请记住，人工智能的任务只是解析原始 HTML 数据，而不是自己进行 <code>网页抓取</code>。</p></blockquote><h2 id="TLDR-简而言之"><a href="#TLDR-简而言之" class="headerlink" title="TLDR(简而言之)"></a>TLDR(简而言之)</h2><p>如果您不想阅读整篇文章，下面是我们使用 OpenAI API（新 GPT-4）模型进行网页抓取实验的利弊总结：</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>新模型 <code>gpt-4-1106-preview</code> 能够完美地抓取原始 <code>HTML</code> 数据。更大的令牌窗口使得只需传递原始 <code>HTML</code> 数据即可进行抓取。</li><li><code>OpenAI</code> 的 <code>函数调用</code> 可以准确返回我们需要的响应格式。</li><li>OpenAI 的 <code>多函数调用</code> 可以从多个数据点返回数据。</li><li>与手动解析所需的开发时间相比，能够抓取原始 HTML 绝对是一个巨大优势。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>与使用其他 SERP API 提供商相比，成本很高。</li><li>在传递整个原始 HTML 时要注意成本。我们仍然需要进行修剪 HTML，以便只抓取相关部分。否则，你必须为使用 token（口令）支付高额费用。.</li><li>将其用于生产时，速度太慢。</li><li>对于通常在脚本标签、额外的 AJAX 请求或执行操作（如点击、滚动）时发现的 “隐藏数据”，我们仍然需要手动操作。</li></ul><h2 id="工具和准备"><a href="#工具和准备" class="headerlink" title="工具和准备"></a>工具和准备</h2><ul><li>由于我们要使用 OpenAI 的 API，因此请务必先注册并获得您的 api_key。您可能还需要 OpenAI 组织 ID。</li><li>我在这个实验中使用的是 Python，但你也可以随意使用任何编程语言。</li><li>由于我们希望返回统一的 JSON 格式，因此我们将使用 <a href="https://platform.openai.com/docs/guides/function-calling" target="_blank" rel="noopener">OpenAI 的函数调用功能</a>，在这里我们可以用顺眼的格式定义响应的键和值。</li><li>我们将使用以下模型 <code>gpt-4-1106-preview .</code></li></ul><h2 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h2><p>确保先安装 <a href="https://github.com/openai/openai-python" target="_blank" rel="noopener">OpenAI 库</a>。由于我使用的是 Python，我需要</p><pre class=" language-shell"><code class="language-shell">pip install openai</code></pre><p>我还将安装 <code>requests</code> 包，以获取原始 HTML 代码</p><pre class=" language-shell"><code class="language-shell">pip install requests</code></pre><p>我们的代码库如下所示</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> json<span class="token keyword">import</span> requests<span class="token keyword">from</span> openai <span class="token keyword">import</span> OpenAIclient <span class="token operator">=</span> OpenAI<span class="token punctuation">(</span>  organization<span class="token operator">=</span><span class="token string">'YOUR-OPENAI-ORG-ID'</span><span class="token punctuation">,</span>  api_key<span class="token operator">=</span><span class="token string">'YOUR-OPENAI-API-KEY'</span><span class="token punctuation">)</span>targetUrl <span class="token operator">=</span> <span class="token string">'https://books.toscrape.com/'</span> <span class="token comment" spellcheck="true"># Target URL will always changes</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>targetUrl<span class="token punctuation">)</span>html_text <span class="token operator">=</span> response<span class="token punctuation">.</span>text</code></pre><p>注：国内用户可能要设置 <code>base_url</code>，来使用代理或者第三方 API。</p><h2 id="第-1-级：使用人工智能对漂亮-简单的结构化网页进行抓取"><a href="#第-1-级：使用人工智能对漂亮-简单的结构化网页进行抓取" class="headerlink" title="第 1 级：使用人工智能对漂亮/简单的结构化网页进行抓取"></a>第 1 级：使用人工智能对漂亮/简单的结构化网页进行抓取</h2><p>让我们先热热身。我们首先针对 <a href="https://books.toscrape.com/" target="_blank" rel="noopener">https://books.toscrape.com/</a>网站，因为它的结构非常简洁，便于阅读。</p><p><img src="https://serpapi.com/blog/content/images/2023/11/web-scraping-target-from-toscrape-books.webp" alt=""></p><p>截图 toscrape books，是第一个网络抓取目标</p><p>下面是我们的代码（下面有解释）</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 来自 OpenAI 的 ChatCompletion API</span>completion <span class="token operator">=</span> client<span class="token punctuation">.</span>chat<span class="token punctuation">.</span>completions<span class="token punctuation">.</span>create<span class="token punctuation">(</span>  model<span class="token operator">=</span><span class="token string">"gpt-4-1106-preview"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 请将模型改为 gpt-3.5-turbo-1106</span>  messages<span class="token operator">=</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span><span class="token string">"role"</span><span class="token punctuation">:</span> <span class="token string">"system"</span><span class="token punctuation">,</span> <span class="token string">"content"</span><span class="token punctuation">:</span> <span class="token string">"You are a master at scraping and parsing raw HTML."</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"role"</span><span class="token punctuation">:</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"content"</span><span class="token punctuation">:</span> html_text<span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  tools<span class="token operator">=</span><span class="token punctuation">[</span>          <span class="token punctuation">{</span>            <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"function"</span><span class="token punctuation">,</span>            <span class="token string">"function"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>              <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"parse_data"</span><span class="token punctuation">,</span>              <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"Parse raw HTML data nicely"</span><span class="token punctuation">,</span>              <span class="token string">"parameters"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'object'</span><span class="token punctuation">,</span>                <span class="token string">'properties'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                    <span class="token string">'data'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                        <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'array'</span><span class="token punctuation">,</span>                        <span class="token string">'items'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                            <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'object'</span><span class="token punctuation">,</span>                            <span class="token string">'properties'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                                <span class="token string">'title'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                                <span class="token string">'rating'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'number'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                                <span class="token string">'price'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'number'</span><span class="token punctuation">}</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>   tool_choice<span class="token operator">=</span><span class="token punctuation">{</span>       <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"function"</span><span class="token punctuation">,</span>       <span class="token string">"function"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"parse_data"</span><span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 数据结果的调用</span>argument_str <span class="token operator">=</span> completion<span class="token punctuation">.</span>choices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>message<span class="token punctuation">.</span>tool_calls<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>function<span class="token punctuation">.</span>argumentsargument_dict <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>argument_str<span class="token punctuation">)</span>data <span class="token operator">=</span> argument_dict<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 打印格式化</span><span class="token keyword">for</span> book <span class="token keyword">in</span> data<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>book<span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> book<span class="token punctuation">[</span><span class="token string">'rating'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> book<span class="token punctuation">[</span><span class="token string">'price'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><ul><li>我们使用 OpenAI 的 <code>ChatCompletion</code> API</li><li>使用模型: gpt-4-1106-preview</li><li>使用提示语 <code>您是抓取和解析原始 HTML 的高手</code>，并传递要分析的 <code>raw_html</code>。</li><li>在 <code>tools</code> 参数中，我们定义了用于解析原始数据的虚函数（imaginary function）。不要忘记调整参数的属性，以准确返回您想要的格式。</li></ul><h3 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下"></a>结果如下</h3><p>我们可以抓取每本书的标题、评分和价格 _（正是我们在上述__函数参数中定义的数据）_。</p><h3 id="运行完成时间-15s"><a href="#运行完成时间-15s" class="headerlink" title="运行完成时间: ~15s"></a>运行完成时间: ~15s</h3><p><img src="https://serpapi.com/blog/content/images/2023/11/Compare-web-scraping-results.webp" alt=""></p><p>比较网络抓取结果</p><h3 id="使用-gpt-3-5"><a href="#使用-gpt-3-5" class="headerlink" title="使用 gpt-3.5"></a>使用 gpt-3.5</h3><p>当切换到 <code>gpt-3.5-turbo-1106</code> 时，我必须调整提示词，使其更加具体：</p><pre class=" language-json"><code class="language-json">messages<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"role"</span><span class="token operator">:</span> <span class="token string">"system"</span><span class="token punctuation">,</span> <span class="token property">"content"</span><span class="token operator">:</span> <span class="token string">"You are a master at scraping and parsing raw HTML. Scrape ALL the book data results"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>#  function 描述<span class="token property">"function"</span><span class="token operator">:</span> <span class="token punctuation">{</span>              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"parse_data"</span><span class="token punctuation">,</span>              <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"Get all books data from raw HTML data"</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre><p>如果不提及 “抓取所有图书数据”，就只能得到前几个结果。</p><h3 id="运行完成时间-9s"><a href="#运行完成时间-9s" class="headerlink" title="运行完成时间: ~9s"></a>运行完成时间: ~9s</h3><h2 id="第-2-层：利用人工智能解析-Google-SERP-中的自然搜索结果（Organic-results）"><a href="#第-2-层：利用人工智能解析-Google-SERP-中的自然搜索结果（Organic-results）" class="headerlink" title="第 2 层：利用人工智能解析 Google SERP 中的自然搜索结果（Organic results）"></a>第 2 层：利用人工智能解析 Google SERP 中的自然搜索结果（Organic results）</h2><p>谷歌搜索结果页面与之前的网站不同。它的结构更复杂，CSS 类名不清晰，原始 HTML 中包含许多未知数据。</p><p>目标 URL: ‘<a href="https://www.google.com/search?q=coffee&amp;gl=us'" target="_blank" rel="noopener">https://www.google.com/search?q=coffee&amp;gl=us'</a></p><blockquote><p>警告！起初，我只是解析 Google 原始 HTML 中的所有内容，结果发现其中包含太多字符，这意味着需要更多 token 和更多成本！</p></blockquote><p><img src="https://serpapi.com/blog/content/images/2023/11/openai-usage-billing.webp" alt=""></p><p>注意您的 OpenAI 账单使用情况</p><p>因此，在尝试了几次之后，我决定只要 <code>body</code> 部分，并删除 <code>style</code> 和 <code>script</code> 标记的内容。</p><p>我这样调整了提示词和功能参数：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> re <span class="token comment" spellcheck="true">#导入 regex</span>response <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://www.google.com/search?q=coffee&amp;gl=us'</span><span class="token punctuation">)</span>html_text <span class="token operator">=</span> response<span class="token punctuation">.</span>text<span class="token comment" spellcheck="true"># 删除不必要的部分，以避免巨额 TOKEN 费用！</span><span class="token comment" spellcheck="true"># 删除 &lt;head&gt; 和 &lt;/head&gt; 之间的所有内容</span>html_text <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">'&lt;head.*?&gt;.*?&lt;/head&gt;'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> html_text<span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>DOTALL<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 删除 &lt;script&gt; 和 &lt;/script&gt; 之间出现的所有内容</span>html_text <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">'&lt;script.*?&gt;.*?&lt;/script&gt;'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> html_text<span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>DOTALL<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 删除 &lt;style&gt; 和 &lt;/style&gt; 之间的所有内容</span>html_text <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">'&lt;style.*?&gt;.*?&lt;/style&gt;'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> html_text<span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>DOTALL<span class="token punctuation">)</span>completion <span class="token operator">=</span> client<span class="token punctuation">.</span>chat<span class="token punctuation">.</span>completions<span class="token punctuation">.</span>create<span class="token punctuation">(</span>  model<span class="token operator">=</span><span class="token string">"gpt-4-1106-preview"</span><span class="token punctuation">,</span>  messages<span class="token operator">=</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span><span class="token string">"role"</span><span class="token punctuation">:</span> <span class="token string">"system"</span><span class="token punctuation">,</span> <span class="token string">"content"</span><span class="token punctuation">:</span> <span class="token string">"You are a master at scraping Google results data. Scrape top 10 organic results data from Google search result page."</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"role"</span><span class="token punctuation">:</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"content"</span><span class="token punctuation">:</span> html_text<span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  tools<span class="token operator">=</span><span class="token punctuation">[</span>          <span class="token punctuation">{</span>          <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"function"</span><span class="token punctuation">,</span>          <span class="token string">"function"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"parse_data"</span><span class="token punctuation">,</span>            <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"Parse organic results from Google SERP raw HTML data nicely"</span><span class="token punctuation">,</span>            <span class="token string">"parameters"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>              <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'object'</span><span class="token punctuation">,</span>              <span class="token string">'properties'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                  <span class="token string">'data'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                      <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'array'</span><span class="token punctuation">,</span>                      <span class="token string">'items'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                          <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'object'</span><span class="token punctuation">,</span>                          <span class="token string">'properties'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                              <span class="token string">'title'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'original_url'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'snippet'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'position'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'integer'</span><span class="token punctuation">}</span>                          <span class="token punctuation">}</span>                      <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>   tool_choice<span class="token operator">=</span><span class="token punctuation">{</span>       <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"function"</span><span class="token punctuation">,</span>       <span class="token string">"function"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"parse_data"</span><span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span>argument_str <span class="token operator">=</span> completion<span class="token punctuation">.</span>choices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>message<span class="token punctuation">.</span>tool_calls<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>function<span class="token punctuation">.</span>argumentsargument_dict <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>argument_str<span class="token punctuation">)</span>data <span class="token operator">=</span> argument_dict<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token keyword">for</span> result <span class="token keyword">in</span> data<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token string">'original_url'</span><span class="token punctuation">]</span> <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token string">'snippet'</span><span class="token punctuation">]</span>  <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token string">'position'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'---'</span><span class="token punctuation">)</span></code></pre><ul><li>首先，我们只修剪（trim）选中的部分。</li><li>将提示词调整为 <code>您是 Google 搜索结果数据的高手。从 Google 搜索结果页面抓取前 10 条自然搜索结果数据（You are a master at scraping Google results data. Scrape top 10 organic results data from Google search result page.）</code>。</li><li>将功能参数调整为所需的格式。</li></ul><p><img src="https://serpapi.com/blog/content/images/2023/11/basic-google-SERP-scraping-with-AI.webp" alt=""></p><p>利用人工智能对谷歌 SERP 进行基本的网络抓取</p><p>哒哒哒！尽管谷歌原始 HTML 格式复杂，我们还是准确地获得了所需的数据。</p><h3 id="运行完成时间-28s"><a href="#运行完成时间-28s" class="headerlink" title="运行完成时间: ~28s"></a>运行完成时间: ~28s</h3><blockquote><p>备注： 我最初的提示词是 <code>很好地解析 Google SERP 原始 HTML 数据中的自然搜索结果(Parse organic results from Google SERP raw HTML data nicely)</code>，但只能返回前 3-5 个结果，因此我调整了提示词，以获得更多的结果。</p></blockquote><h3 id="使用-gpt-3-5-模型"><a href="#使用-gpt-3-5-模型" class="headerlink" title="使用 gpt-3.5 模型"></a>使用 gpt-3.5 模型</h3><p>我无法做到这一点，因为原始 HTML 数据量超过了 token 窗口长度。</p><h2 id="第-3-层：利用人工智能解析谷歌地图中的本地地点结果"><a href="#第-3-层：利用人工智能解析谷歌地图中的本地地点结果" class="headerlink" title="第 3 层：利用人工智能解析谷歌地图中的本地地点结果"></a>第 3 层：利用人工智能解析谷歌地图中的本地地点结果</h2><p>现在，让我们抓取另一个 Google 产品，即 Google 地图。这是我们的目标页面： <a href="https://www.google.com/maps/search/coffee/@40.7455096,-74.0083012,14z?hl=en&amp;entry=ttu" target="_blank" rel="noopener">https://www.google.com/maps/search/coffee/@40.7455096,-74.0083012,14z?hl=en&amp;entry=ttu</a></p><p><img src="https://serpapi.com/blog/content/images/2023/11/Google-maps-target-page.webp" alt=""></p><p>谷歌地图截图</p><p>如您所见，每个项目都包含许多信息。我们将进行搜索：<br>- Name<br>- Rating average<br>- Total rating<br>- Price<br>- Address<br>- Extras<br>- Hours<br>- Additional service<br>- Thumbnail image</p><blockquote><h3 id="警告！-原来，谷歌地图是通过-Javascript-来加载这些数据的，所以我必须改变获取原始网页的方法，从使用-requests-改为使用-selenium-来获取"><a href="#警告！-原来，谷歌地图是通过-Javascript-来加载这些数据的，所以我必须改变获取原始网页的方法，从使用-requests-改为使用-selenium-来获取" class="headerlink" title="警告！ 原来，谷歌地图是通过 Javascript 来加载这些数据的，所以我必须改变获取原始网页的方法，从使用 requests 改为使用 selenium 来获取"></a>警告！ 原来，谷歌地图是通过 Javascript 来加载这些数据的，所以我必须改变获取原始网页的方法，从使用 <code>requests</code> 改为使用 <code>selenium</code> 来获取</h3></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在 Python 上安装 Selenium。更多安装说明请参阅 <a href="https://selenium-python.readthedocs.io/installation.html#introduction" target="_blank" rel="noopener">此处</a>。</p><pre class=" language-shell"><code class="language-shell">pip install selenium</code></pre><p>导入 Selenium</p><pre class=" language-Python"><code class="language-Python">from selenium import webdriverfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.common.by import By</code></pre><p>创建一个无头浏览器实例来浏览网页</p><pre class=" language-python"><code class="language-python">target_url <span class="token operator">=</span> <span class="token string">'https://www.google.com/maps/search/coffee/@40.7455096,-74.0083012,14z?hl=en'</span>op <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>ChromeOptions<span class="token punctuation">(</span><span class="token punctuation">)</span>op<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'headless'</span><span class="token punctuation">)</span>driver <span class="token operator">=</span> webdriver<span class="token punctuation">.</span>Chrome<span class="token punctuation">(</span>options<span class="token operator">=</span>op<span class="token punctuation">)</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span>target_url<span class="token punctuation">)</span>driver<span class="token punctuation">.</span>implicitly_wait<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># seconds</span><span class="token comment" spellcheck="true"># 获取的原始网页</span>html_text <span class="token operator">=</span> driver<span class="token punctuation">.</span>page_source<span class="token comment" spellcheck="true"># 您可以继续使用之前的方法，先只修剪 body 部分</span></code></pre><p>我使用 <code>implicitly_wait</code> 等待 1 秒钟，以确保数据已经在那里，可以进行抓取。</p><p>下面是 OpenAI API 函数：</p><pre class=" language-python"><code class="language-python">completion <span class="token operator">=</span> client<span class="token punctuation">.</span>chat<span class="token punctuation">.</span>completions<span class="token punctuation">.</span>create<span class="token punctuation">(</span>  model<span class="token operator">=</span><span class="token string">"gpt-4-1106-preview"</span><span class="token punctuation">,</span>  messages<span class="token operator">=</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span><span class="token string">"role"</span><span class="token punctuation">:</span> <span class="token string">"system"</span><span class="token punctuation">,</span> <span class="token string">"content"</span><span class="token punctuation">:</span> <span class="token string">"You are a master at scraping Google Maps results. Scrape all local places results data"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"role"</span><span class="token punctuation">:</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"content"</span><span class="token punctuation">:</span> html_text<span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  tools<span class="token operator">=</span><span class="token punctuation">[</span>          <span class="token punctuation">{</span>          <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"function"</span><span class="token punctuation">,</span>          <span class="token string">"function"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"parse_data"</span><span class="token punctuation">,</span>            <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"Parse local results detail from Google MAPS raw HTML data nicely"</span><span class="token punctuation">,</span>            <span class="token string">"parameters"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>              <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'object'</span><span class="token punctuation">,</span>              <span class="token string">'properties'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                  <span class="token string">'data'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                      <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'array'</span><span class="token punctuation">,</span>                      <span class="token string">'items'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                          <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'object'</span><span class="token punctuation">,</span>                          <span class="token string">'properties'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                              <span class="token string">'position'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'integer'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'title'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'rating'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'total_reviews'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'price'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'address'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'phone'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'hours'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'service_options'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'image_url'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                          <span class="token punctuation">}</span>                      <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>   tool_choice<span class="token operator">=</span><span class="token punctuation">{</span>       <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"function"</span><span class="token punctuation">,</span>       <span class="token string">"function"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"parse_data"</span><span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span>argument_str <span class="token operator">=</span> completion<span class="token punctuation">.</span>choices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>message<span class="token punctuation">.</span>tool_calls<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>function<span class="token punctuation">.</span>argumentsargument_dict <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>argument_str<span class="token punctuation">)</span>data <span class="token operator">=</span> argument_dict<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></code></pre><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://serpapi.com/blog/content/images/2023/11/local-maps-AI-scraping-results.webp" alt=""></p><p>利用人工智能进行本地地图 API 搜索的结果</p><p>结果很完美！我可以获得每个 local_results 的准确数据。</p><h3 id="运行完-Selenium-时间-47s"><a href="#运行完-Selenium-时间-47s" class="headerlink" title="运行完 Selenium 时间: ~47s"></a>运行完 Selenium 时间: ~47s</h3><h3 id="运行时间-除了-Selenium-34s"><a href="#运行时间-除了-Selenium-34s" class="headerlink" title="运行时间 (除了 Selenium ): ~34s"></a>运行时间 (除了 Selenium ): ~34s</h3><h2 id="第-4-层次：-利用人工智能解析来自-Google-SERP-的两种不同数据（自然搜索结果和人们询问相关问题的部分）"><a href="#第-4-层次：-利用人工智能解析来自-Google-SERP-的两种不同数据（自然搜索结果和人们询问相关问题的部分）" class="headerlink" title="第 4 层次： 利用人工智能解析来自 Google SERP 的两种不同数据（自然搜索结果和人们询问相关问题的部分）"></a>第 4 层次： 利用人工智能解析来自 Google SERP 的两种不同数据（自然搜索结果和人们询问相关问题的部分）</h2><p>如您所知，谷歌 SERP 不仅显示自然搜索结果，还显示其他数据，如广告、people-also-ask（相关问题）、知识图谱等。</p><p><em>让我们来看看如何利用调用 OpenAI 的多个函数处理多个数据。</em></p><p>代码如下</p><pre class=" language-python"><code class="language-python">completion <span class="token operator">=</span> client<span class="token punctuation">.</span>chat<span class="token punctuation">.</span>completions<span class="token punctuation">.</span>create<span class="token punctuation">(</span>  model<span class="token operator">=</span><span class="token string">"gpt-4-1106-preview"</span><span class="token punctuation">,</span>  messages<span class="token operator">=</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span><span class="token string">"role"</span><span class="token punctuation">:</span> <span class="token string">"system"</span><span class="token punctuation">,</span> <span class="token string">"content"</span><span class="token punctuation">:</span> <span class="token string">"You are a master at scraping Google results data. Scrape two things: 1st. Scrape top 10 organic results data and 2nd. Scrape people_also_ask section from Google search result page."</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"role"</span><span class="token punctuation">:</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"content"</span><span class="token punctuation">:</span> html_text<span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  tools<span class="token operator">=</span><span class="token punctuation">[</span>          <span class="token punctuation">{</span>          <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"function"</span><span class="token punctuation">,</span>          <span class="token string">"function"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"parse_organic_results"</span><span class="token punctuation">,</span>            <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"Parse organic results from Google SERP raw HTML data nicely"</span><span class="token punctuation">,</span>            <span class="token string">"parameters"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>              <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'object'</span><span class="token punctuation">,</span>              <span class="token string">'properties'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                  <span class="token string">'data'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                      <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'array'</span><span class="token punctuation">,</span>                      <span class="token string">'items'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                          <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'object'</span><span class="token punctuation">,</span>                          <span class="token string">'properties'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                              <span class="token string">'title'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'original_url'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'snippet'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'position'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'integer'</span><span class="token punctuation">}</span>                          <span class="token punctuation">}</span>                      <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span>          <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"function"</span><span class="token punctuation">,</span>          <span class="token string">"function"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"parse_people_also_ask_section"</span><span class="token punctuation">,</span>            <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"Parse `people also ask` section from Google SERP raw HTML"</span><span class="token punctuation">,</span>            <span class="token string">"parameters"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>              <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'object'</span><span class="token punctuation">,</span>              <span class="token string">'properties'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                  <span class="token string">'data'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                      <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'array'</span><span class="token punctuation">,</span>                      <span class="token string">'items'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                          <span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'object'</span><span class="token punctuation">,</span>                          <span class="token string">'properties'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                              <span class="token string">'question'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'original_url'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                              <span class="token string">'answer'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'type'</span><span class="token punctuation">:</span> <span class="token string">'string'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                          <span class="token punctuation">}</span>                      <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    tool_choice<span class="token operator">=</span><span class="token string">"auto"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Organic_results（自然搜索结果）</span>argument_str <span class="token operator">=</span> completion<span class="token punctuation">.</span>choices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>message<span class="token punctuation">.</span>tool_calls<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>function<span class="token punctuation">.</span>argumentsargument_dict <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>argument_str<span class="token punctuation">)</span>organic_results <span class="token operator">=</span> argument_dict<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Organic results:'</span><span class="token punctuation">)</span><span class="token keyword">for</span> result <span class="token keyword">in</span> organic_results<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token string">'original_url'</span><span class="token punctuation">]</span> <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token string">'snippet'</span><span class="token punctuation">]</span>  <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token string">'position'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'---'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># People also ask （相关问题）</span>argument_str <span class="token operator">=</span> completion<span class="token punctuation">.</span>choices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>message<span class="token punctuation">.</span>tool_calls<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>function<span class="token punctuation">.</span>argumentsargument_dict <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>argument_str<span class="token punctuation">)</span>people_also_ask <span class="token operator">=</span> argument_dict<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'People also ask:'</span><span class="token punctuation">)</span><span class="token keyword">for</span> result <span class="token keyword">in</span> people_also_ask<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token string">'question'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token string">'original_url'</span><span class="token punctuation">]</span> <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token string">'answer'</span><span class="token punctuation">]</span>  <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'---'</span><span class="token punctuation">)</span></code></pre><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ul><li>调整提示词，使其包含关于抓取内容的具体信息： <code>您是搜索 Google 结果数据的高手。搜索两样东西： 第一。抓取排名前 10 的自然搜索结果数据；第二。从 Google 搜索结果页面中抓取 _the_ people_also_ask 部分（You are a master at scraping Google results data. Scrape two things: 1st. Scrape top 10 organic results data and 2nd. Scrape the _the_ people_also_ask section from the Google search result page）</code>。</li><li>添加并分离函数（separating functions），一个用于自然搜索结果，另一个用于 people-also-ask 部分。</li><li>测试两种不同格式的输出。</li></ul><p>结果如下:</p><p><img src="https://serpapi.com/blog/content/images/2023/11/multiple-data-points-on-AI-scraping.webp" alt=""></p><p>利用人工智能获取多个数据点</p><h3 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h3><p>我可以分别搜索自然搜索结果和 people_also_ask。OpenAI 功不可没！</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><p>我无法为 people_also_ask 部分提取答案和原始网址。原因是这些信息隐藏在脚本标签的某处。我们可以通过提供脚本内容的特定部分来尝试，但我认为这对本实验来说是 <code>作弊</code>，因为我们要传递的是原始网页内容，而不是精确定位或给出提示。</p><h3 id="运行时间-30s"><a href="#运行时间-30s" class="headerlink" title="运行时间: ~30s"></a>运行时间: ~30s</h3><p>如果您想了解如何更低代价、更快速、更准确地搜索这些数据。您可以阅读以下文章：</p><ul><li><a href="https://serpapi.com/blog/how-to-scrape-google-search-results-with-python/" target="_blank" rel="noopener">使用 Python 对 Google 搜索结果进行抓取</a></li><li><a href="https://serpapi.com/blog/using-google-maps-place-results-api-from-serpapi/" target="_blank" rel="noopener">使用 Python 抓取 Google 地图的地点结果</a></li></ul><h2 id="与-SerpApi-的表格比较"><a href="#与-SerpApi-的表格比较" class="headerlink" title="与 SerpApi 的表格比较"></a>与 SerpApi 的表格比较</h2><p>以下是使用 OpenAI 新的 GPT-4 模型进行网络抓取与<a href="https://serpapi.com/?ref=web-scraping-with-ai-experiment-blog" target="_blank" rel="noopener">SerpApi</a>的时间表对比。我们使用 <code>正常速度</code> 进行比较；SerpApi 在使用<a href="https://serpapi.com/ludicrous-speed" target="_blank" rel="noopener">Ludicrous Speed</a>时速度更快（大约是正常速度的两倍）。</p><table><thead><tr><th>Subject</th><th>gpt-4-1106-preview</th><th>SerpApi</th></tr></thead><tbody><tr><td>Organic results</td><td>15s</td><td>2.4s</td></tr><tr><td>Organic results with Related questions</td><td>30s</td><td>2.4s</td></tr><tr><td>Maps local results</td><td>47s</td><td>2.7s</td></tr></tbody></table><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>随着时间的推移，OpenAI 肯定会有很大改进。现在，我们可以通过应用程序接口（API）抓取网站并收集相关数据。但从所花费的时间来看，它还不能用于生产、商业目的或规模化。虽然数据的准确性和响应格式都很完美，但在成本和速度方面还远远不够。</p><p>如果您有任何想法、发现任何错误，或想补充与本文章相关的其他实验，请发送邮件至 <a href="mailto:hilman@serpapi.com">hilman@serpapi.com</a>。</p><p>感谢您阅读此文！</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;从网络搜索结果中解析数据往往是一件麻烦事。但如果有一种方法能让这一艰苦的过程变得轻而易举呢？让我们尝试一下 OpenAI 的新人工智能模型吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://serpapi.com/blog/author/hilman/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;/blog/content/images/size/w100/2023/10/profile-picture.png&quot; alt=&quot;Hilman Ramadhan&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hilman Ramadhan&lt;/strong&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="Article" scheme="https://fcc-cd.dev/categories/Article/"/>
    
      <category term="Translation" scheme="https://fcc-cd.dev/categories/Article/Translation/"/>
    
    
  </entry>
  
</feed>
