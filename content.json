{"pages":[{"title":"","text":"freeCodeCamp 成都社区 官方数据库本仓库通过 Git 子模块链接到 Hexo 网站的 source 文件夹 开源文章翻译计划本计划是 freeCodeCamp 中文社区文章翻译计划的扩展项目，在相同的宗旨和工作流程下翻译 freeCodeCamp 社区之外的优秀开源、技术文章。 新增原文 翻译文章： 进度看板 内容授权 freeCodeCamp 成都社区官方网站由freeCodeCamp 成都社区采用知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议进行许可。基于https://github.com/FreeCodeCamp-Chengdu/Wiki上的作品创作。","link":"/ReadMe.html"},{"title":"活动时空","text":"","link":"/activity/index.html"},{"title":"社群伙伴","text":"","link":"/community/index.html"},{"title":"精彩瞬间","text":"","link":"/gallery/index.html"},{"title":"撰写文章","text":"添加文章 多媒体文件上传图片、视频、PDF、PPT 等二进制文件上传必须在本地编辑！ Front-matter 规范（点右下角按钮复制模板） title: # 文章主题（翻译成英文后设为本文件的文件名） date: # 开篇日期 updated: # 修订日期 categories: # 分类名应为一个首字母大写的英文单词 # 每级分类对应一级目录，写在本文件的文件名前面 tags: # 与内容相关的更多标签 authors: # 原作者们的 GitHub 账号 original: # 文章出处链接 toc: true thumbnail: # 封面图片","link":"/write/index.html"},{"title":"联系我们","text":"微信服务号 QQ 群","link":"/contact/index.html"},{"title":"发起活动","text":"多媒体文件上传图片、视频、PDF、PPT 等二进制文件上传必须在本地编辑！ Front-matter 规范（点右下角按钮复制模板） title: # 活动主题（翻译成英文后设为本文件的文件名） date: # 发起日期 categories: - Activity # 二级分类：Salon、Workshop 或 Conference tags: # online 或 offline # 与内容相关的更多标签 toc: true # Activity meta description: # 活动简介 start: # 活动开始时间 end: # 活动结束时间 address: # 线下活动地址（市州、区县、路街、楼栋） links: 报名: # https://jinshuju.net/f/xxxxxx mentors: # 讲师、教练们的 GitHub 账号 workers: # 组织者、志愿者们的 GitHub 账号 partners: # 合办方、场地方、赞助方 # Attachment meta photos: - # 第一张为活动封面图 - # 第二张开始为活动结束后上传的现场照片 files: - # 活动结束后上传的 PDF、PPT 等非纯文本文件","link":"/activity/launch/index.html"}],"posts":[{"title":"Hello Hexo-Wiki !","text":"Generate this Web-site by just one command: npm init hexo-wiki CDC/OWS \\ --theme Icarus --plugins hexo-permalink-pinyin --remote https://github.com/FreeCodeCamp-Chengdu/FreeCodeCamp-Chengdu.github.io.git","link":"/hello-hexo-wiki/"},{"title":"3RD 共享生活方式空间","text":"为企业员工提供工作 8 小时外的具有社交、娱乐功能的社群互动平台，将音乐、体育、生活美学、文化 IP 融入其中，打造企业员工专属的兴趣 x 社交 x 实用美学的生活方式社区。","link":"/partner/3rd-slss/"},{"title":"阿里云 ACE 成都同城会","text":"我在青城山巅、峨眉云端，还有那四姑娘山间，期待所有成都技术爱好者的到来！ACE 成都同城会带你畅游美景，尝遍美食，享尽云计算的魅力，让我们一起云海弄潮！","link":"/partner/ace-cd/"},{"title":"紫荆谷众创空间","text":"紫荆谷众创空间（上海）于 2017 年 12 月 29 日在上海宝山区纬地路正式开园落地，该众创空间总面积达 3500 平方米，共有 2 层，集国际联合办公、孵化空间、创业服务、创业投资、创业导师培训工作室，打造创业环境一流、创业氛围和谐的新一代国际孵化器和加速器。不仅如此，紫荆谷众创空间细节之处还体现了国际化的要素，概念设计单位 Lifestyle Creating 是拥有国际视野的顶尖设计公司，成功开发并打造了新天地及诸多新概念商业地产项目。同时紫荆谷众创空间运营团队也都拥有丰富的国际化运作模式的专业背景。未来运营团队将结合技术资源、专业导师指导、全球市场接入、产业化落地、投融资服务等领域，为全世界的创业项目提供专项的垂直加速运作，帮助创业者突破发展瓶颈，将“紫荆谷”打造成为国家科技创新的“东方硅谷”，将“紫荆谷+”打造成为传统产业创新的高端平台。","link":"/partner/bauhinia-valley/"},{"title":"创客+ 咖啡","text":"","link":"/partner/cd-ckplus/"},{"title":"乡愁故事馆","text":"天华社区乡愁故事馆是由桂溪街道天华社区居委会主办，桂溪街道办事处支持，爱有戏社会工作服务中心运营的公益性社区营造项目。 天华故事馆以“文化艺术”作为社区营造的切入，建立生活与文化艺术之间的桥梁关系；深度发掘社区地域文化特质，推进人文、特色社区建设；搭建平台，激活辖区资源参与基层社会治理，激活辖区企业与个人，参与社区公共事务。让不同乡音、不同肤色、不同职业和谐共融，培育社区社会资本，建立有活力的自组织，持续开展在地文化生产。 开展项目青年导演计划组建微电影社团，自编自导自演。邀请著名作家莫然、腾讯视频签约导演高书雷、本土笑星棒棒娃赵艺等人参与指导，开展剧本创作及拍摄技术教习。社团首部反应当代都市代际冲突与和解的微电影正在拍摄中。 天华曲艺荟特邀哈哈曲艺社将精彩的传统曲艺带到社区，居民在家门口不仅能享受到高质量的文化演出，更有机会与演员作零距离的交流。曲艺荟激发了居民对在地民间文化的兴趣与关注，推动本土文化的复兴与传承，营造多彩公共生活。 天华读书会由社区文学爱好者组成的居民自组织，线上线下常态化开展阅读与文化交流活动，丰富多彩的主题吸引了社区老、中、青、幼各年龄群体的参与。不定期邀请社区能人举办讲座沙龙，开展文学作品的征集与发布。 戏剧工作坊每周五晚，戏剧爱好者在专业老师的带领下进行表演练习，妙趣横生的环节让参与者在爆笑中过足戏瘾，在飙戏中提升演技。通过戏剧学习增强人与人之间的连接，共享互助理念，孵化以戏剧为核心的公益团队。 方志文化进社区联合成都市地志办，开展方志文化讲座与读书会，解读成都的悠久历史，探讨历史表象背后流淌在成都人血液里乐观向上的生活态度，让蓉漂触摸成都的历史年轮，更加了解成都、热爱成都，传承巴蜀文明，发展天府文化。 梦想之家艺术工坊废弃的瓦楞纸箱，承载了个人生活的记忆，也象征着乡愁的传递。居民在紧张忙碌的工作之余，进行天马行空的创作，打造梦想中的家。这些纸屋经过澳籍艺术家的重构，现身成都•蓬皮杜国际艺术双年展。 你好邻居公益挑战以新颖活泼的公益挑战赛，让参与者身体力行感受公益力量。拉近人与人的距离，增加心与心的温度，宣传义仓互助理念，倡导健康生活方式。 艺术家工作坊邀请外籍艺术家陈业亮、本土艺术家陈建军、杨然等，举办公共艺术工作坊，串联起社区与社会公共文化资源的纽带，建立生活与艺术的连接，打通居民私人空间与公共空间的边界。","link":"/partner/cdth-storyevents/"},{"title":"四川大学智锐科创计算机协会","text":"智锐科创计算机协会，简称智锐科创（Covariant Innovation），挂靠于四川大学计算机学院分团委，是成都知锐科技有限公司旗下的开源社区。智锐科创的口号是“用最优秀的理论，做最出色的工程”，目标是普及计算机编程教育、传播开源理念以及促进 C++ 编程语言在国内的发展。","link":"/partner/cics/"},{"title":"成都谷歌开发者社区","text":"https://chinagdg.org/p/gdg-chengdu/","link":"/partner/gdg-cd/"},{"title":"华为云 HDZ","text":"HDZ 是 Huawei Developer Zone 的英文缩写，是华为开发者生态面向全球开发者建立开放、创新、多元的开发者社区组织，完全由各地 HDZ 组织者、志愿者自发组建和领导。 HDZ 携手全球开发者 共建开放、创新、多元的开发者社区组织致力于帮助开发者学习提升、互动交流、挖掘机会，推动 ICT、互联网等产业生态的建立和发展。 对于对云计算、IoT、人工智能、5G、区块链、鲲鹏、昇腾、软件开发与运维、开源等各技术领域感兴趣的开发者、软件工程师、创业者、运营人、产品人、大学生、老师等都可以参与到 HDZ。 HDZ 秉承开放、自由、创新的社区文化，完全由各地 HDZ 组织者、志愿者自发组建和领导。华为公司不直接参与 HDZ 组织建设和领导，只按需对 HDZ 社区活动提供必要的方向指导、资源支持、学习支撑等，并为各地 HDZ 组织者提供与全国组织者互动交流的机会。","link":"/partner/hdz/"},{"title":"SKFI 中韩未来革新孵化器","text":"","link":"/partner/skfi/"},{"title":"freeCodeCamp 社区行为准则","text":"为了营造、维护良好的公益技术社区环境，更好地服务广大开发者，特立此《社区行为准则》。 禁止的行为 发布非技术类商业营销推广（软文广告、集赞分享、拼团秒杀等） 传播未经证实且引起恐慌的消息 发起缺乏事实根据的论战，乃至人身攻击 性别歧视、性取向歧视、性骚扰 侵犯知识产权，违反开源协议 宣扬违反《中华人民共和国劳动法》的用工制度（诸如 996、克扣社保等） 其它违反国际公约、《中华人民共和国宪法》及中国其它法律法规的行为 凡触犯以上禁令，各平台管理员[1]有权直接删除违规内容、清退违规人员，恕不警告！ 需审核的行为 公司招聘请联系各平台管理员[1]，在【FCC 成都社区】微信服务号统一发布推文，并在各群群发推广 推荐的行为 技术疑难请详述问题场景、运行环境、尝试过程，并附上代码/报错截图 技术、公益类活动可联系各平台管理员[1]，在【FCC 成都社区】微信服务号统一发布推文，并在各群群发推广 本准则即日起开始试行，如有任何修改建议，可直接发起 Pull request。 1.如 微信群小助手 panky 账号 ↩","link":"/profile/code-of-conduct/"},{"title":"关于 freeCodeCamp 成都社区","text":"原文链接：https://github.com/FreeCodeCamp-Chengdu/FCC-chengdu 什么是 FCCfreeCodeCamp（简称 FCC）是由美国人 Quincy Larson 发起的开源项目，截止 2018-02-03，在 Github 上获得 29+万 Star（教育类排名第一）。有长达 1600 小时的课程， 并且是基于浏览器、课程免费、证书免费、结合了游戏化闯关的乐趣。FCC 是一个在 160 多个国家和 2000 多个城市的拥有与 1000k+ 开发者的社区。 2016 年 4 月，由 DevEco （晋剑 + Miya）将 FCC 引入中国，并举办了 2000+ 开发者参与的在线全民编程活动，到目前为止，已成功举办了 100+ 场 Coffee &amp; Code / 编程黑客松 / 编程静修日等活动。在 FCC China ， 有 20+% 的女性加入到了社区学习、提升编程能力。 FCC 中国 2017 年度总结 FCC 成都社区FCC 成都社区, 成立于 2016 年 6 月，是一个非营利性的公益性技术社区，是由一群热血有志青年爱好者，利用个人业余休息时间组建而成的技术社区，目的是为了搭建一个友好的交流、学习、互助的社区，帮助成都市众多的开发者，技术爱好者提升个人技术能力。社区致力于做西南地区首个有温度与情怀的技术社区，鼓励人人皆可编程实现个人梦想。 FCC 成都社区成立以来做了那些事情大型活动FCC 成都社区 React 技术专场交流活动 2017 成都首届 Web 前端交流大会 新耀杯 Code for City 黑客松大赛 历史活动 序号 日期 主题 形式 1 20160609 线下活动开启，宣布社区成立 编程讨论 2 20160703 携手编程-成都社区主页初版 动手编程 3 20160911 结对编程的理念 个人分享 + 结对编程 4 20161106 Console 的九大命令 + 学习路线分享 个人分享 5 20161119 Git 的使用与个人简历制作 分享 + 编程 6 20161204 Chrome 开发者工具全解 个人分享 7 20161217 结对编程 - 保龄球积分 + FizzBuzz 结对编程 8 20161231 一个平凡程序员的自述 + CSS 布局那些事 个人分享 9 20170115 JSpace Plane 小游戏 分享 + 编程 10 20170212 BootStrap + xMemory 家用云服务器 个人分享 11 20170305 半程黑客松 - 春季 编程黑客松 12 20170318 Bitmap &amp; Sort + 技术文档导读 个人分享 13 20170402 React + 虚拟 DOM 个人分享 14 20170415 HTTP 与 RESTful API + GraphQL 个人分享与讨论 15 20170429 编程的思想 —— 解决现实生活中的问题 分享与引导 16 20170506 全球开发者关系大会（成都分会场） 直播观影 + 现场分享 17 20170521 Python + Django 快速搭建 Blog 编程指导 18 20170603 Game of Life. React? 个人分享 + 结对编程 19 20170618 半程黑客松 - 夏季 编程黑客松 20 20170624 WebAssembly 微信群问答式交流 21 20170702 程序员如何提高职业竞争力 + 程序员创业 &amp; 项目管理 个人分享 22 20170715 DevOps 从理论到实践 + 敏捷四把刀 分享讨论 23 20170730 社区主页改造 结对编程 24 20170806 编程静修日 自习、交流 25 20170812 浅谈如何提高工作效率 + 现场答疑 个人分享 + 现场答疑 26 20170827 H5 在线编辑器工具开发详解 个人分享 27 20170910 TypeScript 在项目中的应用 个人分享 28 20170924 有趣的 Three.js + 逐步在 Docker 中构建 CI 流程 个人分享 29 20171021 Jetbrains 插件开发入门 + 一小时入门 Web 应用开发 个人分享 30 20171105 用算法解决实际问题 + 前端实用算法串烧 个人分享 31 20171119 2017 成都 Web 前端大会 大型交流活动 32 20171210 编程道场 个人分享 + 结对编程 33 20180120 Code for City 黑客松 编程比赛 + 路演 + 主题分享 34 20180311 《我是谁：没有绝对安全的系统》观影会 观影 + 系统开发安全科普 35 20180331 React 技术专场交流活动 大型交流活动 + 现场招聘 36 20180513 《重温经典-黑客帝国》 观影 + 特效开发科普 37 20180526 跟点融和咕咚聊聊软件架构与认证 个人分享 + 现场答疑 38 20180602 大前端的动态化与可用性建设 分享 + 现场答疑 倡导人人皆可编程活动龙泉洪安中学普及编程 为什么是 FCC 成都社区来做这些事情在成都众多的技术大会、技术分享活动当中，很多的活动以技术分享为幌子，做着产品推广与宣传的事情，这导致了成都 IT 圈子技术分享的氛围越来越差，大家参与分享的热情越来越低。 FCC 成都社区的众多小伙伴，一致认为是时候为这座热爱的城市做一份自己的贡献了，社区提出所有活动全部免费参加、嘉宾分享内容中广告零容忍，成立嘉宾分享内容审查团队，确保每一次分享都是 100% 的干货。 FCC 成都社区的小伙伴们一直明白社区所肩负的使命，带动成都 IT 圈子技术交流的氛围，让更多的技术牛人帮助到更多的开发者，让成都成为全国 IT 行业的先锋，让成都吸引更多 IT 人才蓉漂。进入更多的校园普及更多的次的编程知识，倡导人人皆可编程，让成都这座城市未来充满无限可能。 FCC 成都社区 18 年规划是什么 走进更多校园，普及人人皆可编程思想帮助更多的孩子们。 继续坚持做好两周一次的【Coffee and Code】的结对编程活动、编程道场活动，一对一指导开发者提升个人技术能力。 做好季度技术专场活动，让成都众多 IT 公司加入其中进行分享，带动成都 IT 圈子技术分享的热情。 做好 2018 成都 Web 前端交流大会，让国内一线技术大咖来到成都，给成都众多开发者带来国内一线开发公司的技术心得与经验。 联合成都众多大型 IT 公司，做好 2018 编程马拉松活动，让成都的众多开发者进行技术火花的碰撞。 外部媒体对 FCC 成都社区的报道与采访四川电视台报道四川电视台黑客松报道 成都市高新电视台报道（6 分 53 秒处）2017 成都 Web 前端交流大会 四川财富广播 FM94.0 采访FCC 成都社区：“人人皆可编程”，以独特的方式为城市带来美好改变 四川日报报道揭秘“黑客马拉松”：喝 6 瓶红牛、24 小时里只睡 2 小时","link":"/profile/about/"},{"title":"社区参与指南","text":"《公益技术社区的术与道》 术 线下技术社区的优势主要在于线下技术活动 线下技术社区的成就主要以一次次活动来体现 个人、公司对社区的贡献也主要以一次次活动为单位 一个活动是怎样的？首先体现在它的宣传文案上 一篇宣传文案可以是一篇博客文章 title: # 文章主题（翻译成英文后设为本文件的文件名） date: # 开篇日期 updated: # 修订日期 categories: # 分类名应为一个首字母大写的英文单词 # 每级分类对应一级目录，写在本文件的文件名前面 tags: # 与内容相关的更多标签 authors: # 原作者们的 GitHub 账号 original: # 文章出处链接 toc: true thumbnail: # 封面图片 一篇博客文章又可以附带自定义元数据 title: # 活动主题（翻译成英文后设为本文件的文件名） date: # 发起日期 categories: - Activity # 二级分类：Salon、Workshop 或 Conference tags: # online 或 offline # 与内容相关的更多标签 toc: true # Activity meta description: # 活动简介 start: # 活动开始时间 end: # 活动结束时间 address: # 线下活动地址（市州、区县、路街、楼栋） links: 报名: # https://jinshuju.net/f/xxxxxx mentors: # 讲师、教练们的 GitHub 账号 workers: # 组织者、志愿者们的 GitHub 账号 partners: # 合办方、场地方、赞助方 一次活动的反馈可直接在活动博文下方进行 建议：社会化评论框 捐助：支付二维码 一次活动的总结文字可以就近写在同一篇文章中 现场照片、演示文稿也可放在同级同名文件夹，并用附加元数据关联 photos: - # 第一张为活动封面图 - # 第二张开始为活动结束后上传的现场照片 files: - # 活动结束后上传的 PDF、PPT 等非纯文本文件 一场演讲的演示文稿也可以是一篇博文 title: Hello World slidehtml: true 社区贡献统计基于现代静态网站生成器的二次开发能力实现 https://fcc-cd.dev/activity/ https://fcc-cd.dev/community/ 道 团队的运作模式负责人自上而下的领导 社区的运作模式社群自下而上的生长 开源软件运动现代社群的最成功探索 类 GitHub 平台技术型社区的最佳协作工具 版本控制记录成长点滴，杜绝胡乱删改 开源政务透明、财务公开 Issue, Milestone &amp; Project任务安排、缺陷管理、进度跟踪 Fork &amp; Pull request人人皆可发起、参与活动 公益技术社区就成了一个开源文档项目 开源运动的一切最佳实践、基础设施 皆可为线下社群所用 文献翻译、工具开发不但本身可以开源项目的模式运作 也可同时做成工作坊活动 https://github.com/freeCodeCamp/news-translation/blob/master/Contributing.md https://fcc-cd.dev/activity/workshop/hexo-web-app/ https://fcc-cd.dev/activity/workshop/nodejs-web-crawler/ 战 安装基础软件Windowschoco install nodejs-lts git Mac OS Xbrew install node 创建网站项目npm init hexo-wiki ~/Desktop/FCC \\ --theme NexT \\ --plugins hexo-generator-slidehtml \\ --remote https://github.com/FCC/FCC.github.io.git 配置更新服务branches: only: - hexo language: node_js node_js: - lts/* cache: directories: - node_modules before_install: - export TZ=${TIME_ZONE} install: - npm install script: - npm run build - cd ${FOLDER} - git init - git config user.name ${UID} - git config user.email ${EMAIL} - git add . - git commit -m \"${MESSAGE}\" - git push --force --quiet https://${TOKEN}@${GIT_URI}.git master:${BRANCH} Enjoy your Community!","link":"/profile/guide/"},{"title":"freeCodeCamp 成都社区大事记","text":"本文是 freeCodeCamp 中国社区在首届 2050 大会团聚时水歌代表成都社区做的汇报 星星之火 2016 年 6 月始 余煊 (@Yasic) 连续主持 3 场技术沙龙 燎原之势 2016 年 11 月始 姜姜 (@jiangyuzhen) 接过负责人重任 首次主持技术沙龙便遇上技术宅 水歌 (@TechQuery) 欣然加入 FCC 成都从此步入快速成长期 精彩的 小型技术分享 每半月一次雷打不动 刘博兄 (@too) 开的 拾级咖啡也成了我们第一个长期根据地 小型黑客松、编程静修日等创新活动也相继吸引了 AK (@Akagilnc)、书香 (@demongodYY) 等加入组织者团队 炉火纯青 2017 年 10 月 青松 (@Heqingsong) 与姜姜偶遇，办一场【成都 Web 前端大会】的想法不谋而合 虽首次举办大会，但伴随着更多小伙伴的加入，特别是青松沟通、联络、协调、执行的有力，11 月 19 日便惊艳了成都 Web 开发界 2018 年 1 月 20 日 AK 趁热打铁，迎难而上 有惊无险地完成了首次 FCC 中国【Code for City 黑客松大赛】 在 视频直播、商业合作方面做出不错的探索与尝试 也发掘了会务达人 小山 (@HillChen3)、设计小牛 王波、文案高手 民成 (@Dean266) 2018 年 3 月 31 日 青松 再接再厉，匠心独运 【React 专场技术交流大会】办成了 主题分享、现场招聘相得益彰的新型活动 也为 微信公众号-招聘专栏的建立铺平了道路，奠定了 FCC 在 成都 IT 社招领域的优势地位 至此，青松众望所归，顺利完成 组织者团队壮大后的首次 换届 百炼成钢 倩玉 (@Lmagic16) 厚积薄发，开创 微信公众号-技术周刊 民成 首当其冲，在团队壮大后第一个非负责人主办小型沙龙，而且是 IT 观影、编程入门相结合的新形式 王波、佳琪的 UI 设计沙龙也在筹划…… 水歌一直向往的【JavaScript 全栈技术大会】也获得了 NodeParty 创始人 小芋头君 (@xinyu198736)的授权","link":"/profile/history/"},{"title":"编程大学 —— freeCodeCamp.org","text":"FCC 成都社区校园行 认识编程 程序是什么？ 做一件事的流程（算法）、材料的规格（数据结构）和 结果的预期 程序是一种“说明文” 程序 = 数据结构 + 算法 编程语言又是什么？ 用英文单词、数学符号描述程序，再用编译程序翻译成计算机能懂的 0 和 1 英语、数学很好才能编程？ 初级工程师 —— 逻辑 &gt; 数学 &gt; 英语 逻辑：多数应用开发重在描述程序的前因后果 数学：多数应用开发早期不需要复杂计算 英语：计算机词汇比较简单直白，中学英语 + 翻译工具足以应付 学编程有什么好处？ 学习编程很酷的一点是，你会同时获得两个专长。一个专长是计算机科学和编程，另一个是需要你来编程的那个专门领域。除非你是编译器作者，否则你总是会有自己的专门领域。 —— Rich Hickey，Clojure 语言发明者 女生不适合搞 IT ？ 姓名 成就 轶事 艾达·拜伦 世上首个程序员 大诗人拜伦之女 海蒂·拉玛 3G 通讯创立者 好莱坞女星 葛丽丝·霍普 首个编译器作者 bug 词义提出人 玛格丽特·汉密尔顿 软件工程创立者 阿波罗登月软件开发负责人 王小云 MD5、SHA-1 加密算法破解者 山东大学女博士团队 科班没上只能去培训班？ 互联网最不缺的就是技术学习的资料、平台 收费课程才靠谱？ 要相信全球开放社群的力量！ 认识 freeCodeCamp 全球最大的公益编程学习平台，致力于帮助人们从零基础成长为合格软件工程师 在线网站https://freecodecamp.org 注册用户：全球 300+ 万 全球网站 Alexa 排名：超越同类商业平台 Udacity GitHub 源代码：全球星标第一 Medium 专栏：全球最大 YouTube 频道：编程类最火 全球 7 个全职员工靠着社群捐款，与千千万万业余贡献者一起，完成了这个壮举！ 线下社群 FCC 城市社区遍布世界各地 FCC 中文社区https://chinese.freecodecamp.org 英文编程在线课程翻译 英文编程语言学习指南翻译 英文优秀技术博客翻译 英文优秀技术视频翻译 中文技术学习论坛 FCC 成都社区 https://fcc-cd.dev 活动丰富 技术分享会 结对编程/翻译工作坊 黑客马拉松 代码直播 社群活跃 半月度小型技术活动 不定期中型技术活动 年度大型技术会议 友军众多 开源社：COSCon（中国开源年会）主办方 开源工场：SOSConf（学生开源年会）主办方 成都 Google 开发者社区 成都 Linux 用户组 重庆前端社区 NodeParty 基金会 个人案例 加入我们 吃瓜群众 运营团队","link":"/profile/university-for-programming/"},{"title":"开源年会成都场丨码农在 1024 技术趴上可以做什么？","text":"可爱的程序猿/媛们： 你好！COVID-19 肆虐后，居家办公后的你感觉如何呢？1024 程序员节即将到来，在这专属于程序猿/媛的节日，有没有想出来和大家见见面，到现场和小伙伴们面对面畅聊开源、编程话题呢？ 在此，非常诚挚地邀请你参与成都线下的 1024 技术 Party，用你的开源项目及热情来和大家一起愉快地玩耍吧！ 我们的活动有哪些玩法呢？且看我“报菜名”~👇 听演讲 —— 今年 2 天 5 城联动，大咖云集~ 中国大陆最具影响力的开源年度盛会 2020 年 10 月 24 ~ 25 日 程序员节 实时直播 北京、上海、深圳、成都、长沙 5 城分会场邀你一起嗨！~ 摆摊摊 —— 开源项目、开源社区、开放社群，尽情展示~ 2018 成都 Web 前端大会 WebCell 展位 2018 成都 Web 前端大会 Deepin 展位 2019 成都 Web 全栈大会 CovScript 展位 吹牛皮 —— 5 分钟即兴闪电演讲，够胆就来~ 2019 成都 Web 全栈大会 CovScript 作者闪电演讲 吃颜饭 —— 汉服、JK、Lolita，女装也可！ TEDxChengdu Live 2020 水歌着汉服闪电演讲 争奖品 —— 直播提问、市集展位、闪电演讲，先到先得~ 水歌“钦定”的 COSCon 抱枕 超精美的 freeCodeCamp 限量款双肩包 FCC 成都社区 Panky 公仔 今年 FCC 成都办三无大会 —— 无收费、无广告、无主咖…… 因为在技术趴体上 —— 人人都是小咖！ 你来就有展位！ 上就有讲台！ 立刻进入官网注册展位吧！ Web 全栈应用分论坛 ECharts、Midway、DevUI 等明星项目 —— 核心成员，在线教学~ 第二天也有 JavaScript 标准委员会中国代表 —— 带你折腾 TypeScript 编译器 freeCodeCamp.org 创始人 Quincy Larson 主题演讲Quincy Larson 于 2014 年创立 freeCodeCamp.org。目前，该开源项目的规模已发展到每月有超过 600 万用户访问，成千上万名志愿者参与贡献。 在本次演讲中，Quincy 将分享如何将一个开源项目从创始人独立运营发展成大型志愿者团队共同贡献。 Quincy 将分享如何确定项目愿景，如何规划路线图，如何构建项目的第一个版本，以及在发布第一个版本之后，如何吸引一些用户参与进来，成为项目的贡献者。 Quincy 将讨论以下方面的策略： 保证项目财务可持续 赋能贡献最多的贡献者 从社区获得反馈，并划分优先级 选择战略合作伙伴 Quincy 还将分享更多他从构建 freeCodeCamp.org 中学到的经验教训。 感受往届氛围 成都 Web 开发者大会 - 品牌官网 2018 成都 Web 前端大会 - 总结 2019 成都 Web 全栈大会 - 图集 2019 成都 Web 全栈大会 - CovScript 参展方","link":"/activity/conference/coscon-2020-chengdu/"},{"title":"COSCon'21 中国开源年会成都场日程丨共赴一场开源派对！","text":"简介 活动名称：COSCon 2021 中国开源年会 活动主题：“开心开源 Happy Hacking” 活动理念：开放式协作 活动时间：10 月 30 - 31 日，每天 9:00 - 17:00 活动地点（成都分会场）：成都高新区天府五街菁蓉国际广场 序言人称“耍都”的成都，自身气质完全符合 COSCon’21「开心开源」的主题，承办方 fCC 成都社区也将尝试 3 年的「开源市集」模式在今年发扬光大，把会场办成“草坪上的开源派对”！ 同时，我们也把开源的核心理念「开放式协作」推而广之，邀请各类有趣的非技术「开放社区」来跨界交流，并邀请乐队和汉服舞蹈嘉宾，备好成都本地美食、饮品、糕点…… 所有活动向参会者免费开放，让大家体验那句俗话 —— 成都是个来了就不想走的城市~ 在一个多月的时间里，社区志愿者们头脑风暴活动创意、邀请共创伙伴、策划内容、拍摄宣传视频…… 这是一个有趣的尝试：与大家熟悉的活动不同，在这场开源派对里，没有主角，每个参与者 —— 不管是组织者、参展方，还是演讲人、参会观众 —— 都是活动的共创者。这正是开源社区“开放协作”精神的体现。 千言万语汇成一句话：希望大家玩得开心！ 活动一览这场开源派对主要包括直播演讲、展区、中央舞台、工作坊四个部分，同时穿插开源街访、寻宝赢好礼、收纳术修炼、相亲角等趣味活动，一起来学知识、炼技能、交朋友、脱单吧！ 扫描二维码进入成都场活动群，观看/参加各项活动 我们主要在菁蓉国际广场 2 号和 3 号楼举办本次活动。 菁蓉国际广场俯瞰图 注意：工作坊需扫描下方二维码单独预约。重要提醒：参加工作坊的小伙伴需要自带电脑！ 扫码预约工作坊 演讲直播本届年会征集的演讲主题涵盖开源教育、开源治理、开源硬件、开源操作系统、开源公益、Web 应用开发、开源商业等。 活动现场我们将在中央舞台或 3 号楼 1 层实时播放演讲，大家可以选择观看自己感兴趣的演讲内容。 展区 地点：2 号楼 2 层露天草坪 各种软/硬件开源项目、原创编程语言/框架、电脑博物馆、全球最大的开源公益编程教育社区……将参与布展，丰富多彩！各个展台还准备了精美的周边礼品，欢迎大家交流互动赢取礼品。详见下方具体介绍。 中央舞台 地点：2 号楼 2 层露天草坪 日程： 乐队表演（10 月 30 日 10:30-12:00） 开源 logo 你画我猜（10 月 30 日 13:40-14:00） 华为云 GaussDB(for Influx) 从被动跟随转向主动探索（10 月 30 日） 开放麦克风（10 月 30 日 14:00-15:30，10 月 31 日 10:30-12:00） 汉服舞蹈表演（10 月 30 日 15:30-15:35，10 月 31 日 14:00-14:05） 开源街坊（10 月 30 日 15:40-16:50，10 月 31 日 14:30-16:00） 开源龙门阵多城联动（10 月 30 日 17:00-18:00） 开源硬件教育分享（10 月 31 日） 开源人物快问快答（10 月 31 日 14:10-14:25） 开源影院（10 月 31 日 16:15-18:00） 最终日程以活动前一天在成都场活动群的通知为准。 工作坊 地点：3 号楼 1 层 入门 Web 前端开发（10 月 30 日 14:00-15:30，限 30 人） 时序数据库实操（10 月 31 日 14:10-16:00，限 30 人） 活动与嘉宾介绍展区Linux 电脑博物馆 布展人：周蓬岸、沈博文 官网：https://compumuseum.com/（网页里的电脑博物馆） 开源硬件焊接工作坊 组织名：DFRobot 布展人：蘑菇云 官网：https://www.dfrobot.com.cn/ 成立于 2008 年 11 月的 DFRobot，是国际领先的从事开源硬件、机器人产品、人工智能和创客 教育产品的高科技企业。 开源公益编程教育社区 组织名：freeCodeCamp 布展人：喵喵喵/牛牛 官网：https://chinese.freecodecamp.org/ freeCodeCamp.org 自 2014 年成立以来，以“帮助人们免费学习编程”为使命，创建了大量优质的编程教程，包括交互式课程、视频课程、专栏文章等，所有内容向公众免费开放。学员在世界各地自发成立数千个 freeCodeCamp 学习小组。我们的开源社区正在帮助全球数百万人学习编程，希望让世界上每个人都有机会获得免费的优质的编程教育资源，成为开发者或者运用编程去解决问题。 Web 原生组件引擎 组织名：WebCell 布展人：水歌 官网：https://web-cell.dev/ 基于 TypeScript 和 JSX 实现的优雅、轻量的 Web 标准组件框架；让 Web 组件像细胞、蜂巢、元素一般简单而可靠。 大学生原创编程语言 组织名：CovScript 布展人：金霄 官网：https://covariant.cn/covscript/ Covariant Script 编程语言，诞生于 2017 年，创始人为李登淳。CovScript 是一门跨平台、开放源代码的动态类型脚本编程语言，具有高效、易懂、可靠的特点，充分吸收了现代编程语言研究的成果，与 C、C++ 等现代语言有良好的可交互性。 大学生编写的微服务框架 组织名：UESTC-LUG 布展人：龙则灵，大一学生、电子科技大学 LUG 成员，不喜欢 OI，喜欢实现聪明的、愚蠢的、有趣的想法。 Hive 是使用 Rust 编写的（超）轻量级 microservice（玩具）框架，使用 Lua 开发前端，注重轻松的开发体验和快速部署能力。可在 https://github.com/hackerer1c/hive 了解详情。 开源自主无人机软件平台 Prometheus 组织名：阿木实验室 布展人：李家勇 成都铂贝科技有限公司（品牌：阿木实验室），成立于 2016 年，是一家研发和销售智能无人系统硬件相关产品的机器人科技公司，致力于建立以机器人开源项目、机器人软硬件开发工具、人工智能教育及社区服务三位一体的科研教育生态体系。可在 https://github.com/amov-lab/Prometheus 了解详情。 猪齿鱼 组织名：汉得信息 布展人：Rachel 官网：https://choerodon.io/ 猪齿鱼 Choerodon 是一款全场景效能平台，致力于传递体系化方法论，提供协作、测试、DevOps 及容器工具，让团队效能更快更强更稳定。 学生开源年会 &amp; 电子科技大学 Linux 用户组 布展人：朱芮捷/杨畅 官网：https://sosconf.org 学生开源年会（SOSConf）由开源工场和息壤开源生活方式平台创办，致力于纯粹的技术交流和多元的思想碰撞，为学生群体建立活跃、多元、纯粹、关注学习和未来的技术社区，让不同国家学生积极交流，站上国际舞台，展示在实验室和书本之外的无尽创想。该会议旨在积极推动学生参与开放源代码运动的历史进程，2018 年成功地在重庆举办第 0 届学生开源年会，2020 年于电子科技大学举办第 1 届学生开源年会，2021 年于南方科技大学举办第 2 届学生开源年会；并计划未来在不同国家举办当地语言版本的学生开源年会。 华为云数据库 GuassDB 组织名：华为云 布展人：向宇 官网：https://www.huaweicloud.com/product/gaussdb_mysql.html 华为 GaussDB 是一个企业级 AI-Native 分布式数据库。GaussDB 采用 MPP(Massive Parallel Processing) 架构，支持行存储与列存储，提供 PB(Petabyte，2 的 50 次方字节)级别数据量的处理能力。可以为超大规模数据管理提供高性价比的通用计算平台，也可用于支撑各类数据仓库系统、BI(Business Intelligence)系统和决策支持系统，为上层应用的决策分析提供服务。华为 GaussDB 将 AI 能力植入到数据库内核的架构和算法中，为用户提供更高性能、更高可用、更多算力支持的分布式数据库。 开源读书会图灵教育是人民邮电出版社旗下的 IT 品牌，专注出版优质的 IT 图书，是程序员钟爱的 IT 图书出版商，将为大家带来各类最新开源好书，参会观众也可上台分享自己的开源读书心得~ 开源茶馆成都的「茶馆文化」几乎与「麻将文化」并驾齐驱，成为天府之国闲适、安逸的集中体现。今年开源市集，让我们一起喝着「让茶」，闲话开源的东西南北中。 开源收纳术我们的收纳术，是让环境更有秩序、消除生活空间中 bug 的高阶技能。我们将在开源市集上开源收纳术，并组织游戏、抽奖等互动活动。让我们一起成为收纳修炼师，一起来开心开整。 中央舞台开源龙门阵来自开源社、freeCodeCamp、阿里云开发者社区等的经验丰富的开源贡献者将带来： 大会内容点评 行业热点探讨 城市分会场连线 开源人宣言：https://github.com/kaiyuanshe/Open-Source-Fans-Manifesto 开放麦克风/闪电演讲 任何人都可以上台介绍自己，或者作任何话题的分享（比如分享开源相关的书籍） 开源记录影片播放 开源纪录片、电影片段展播 开源 Up 主：https://space.bilibili.com/489667127 开源硬件教育分享 讲师：沈博文 组织：BURNlab/锐梵互动 官网：http://www.burncg.cn/ 成立于 2009 年，团队从艺术与科技的角度出发，将视觉、音乐、算法、电子、机械、材料融合到新媒介艺术的创作中。跨学科协同创新，以全新的动态艺术形式助力公园城市新场景的文化与商业升级，创造面向未来体验的消费型 IP。并围绕产品与服务，探索与景观、展示、广告、表演、文娱、运动、健康、教育、旅游、时尚以及生活周边等泛行业的品牌合作，构建全新的艺术与科技生产力。 华为云 GaussDB (for Influx) 从被动跟随转向主动探索 讲师：向宇，华为云数据库创新实验室布道师 官网：https://www.huaweicloud.com/lab/clouddb/home.html 如今我们正处在云计算、5G 和物联网的快速发展期，指标监控项数量和采集数据量出现剧增，时序数据库面临巨大技术挑战。华为云 GaussDB(for Influx) 时序数据库应运而生，面对 PB 级数据量和亿级时间线问题提出了自己的解决方案，现正在攻克支持万亿时间线规模的内存型时序数据库，设计了全新的技术架构，真正从一个跟随者的角色转向探索者。 南街乐团“让音乐离生活更近一点”是南街乐团一直以来的理念，相信音乐可以给人舒适，在疲惫、难过、伤心的时候有个可以随时出现在你耳旁的陪伴，在开心、激动的时候可以更点燃那股冲动。 表演者 Ladd 是南街乐团主唱兼吉他手，游走于成都南区街头的音乐玩家，也是一名在成都做了 7 年开发的 Java 程序员，喜欢在工作之余，用音乐治愈自己。Ladd 将和乐队的伙伴一起表演一些曲目，也欢迎现场的朋友一起上台玩。 汉服舞蹈表演旧祠（左一）、织和（右一）、坤九九（中间），均为汉服爱好者、戏曲古典舞者、古琴修习者，风格清丽雅正，注重舞蹈韵味表达，擅长剧情排演。 工作坊 再次提醒：参加工作坊的小伙伴需要自带电脑。 Web 前端开发入门工作坊 时间：10 月 30 日 14:00-15:30 地点：3 号楼 1 层 导师：喵喵喵/牛牛 简介：回归 freeCodeCamp 最初的使命，用最直接的方式带你了解学习前端，一起闯关前进 🐛🦷 人群：前端初学者 准备：个人电脑，注册 freeCodeCamp 账户（网址：https://chinese.freecodecamp.org/） 时序数据库实操 时间：10 月 31 日 14:10-16:00 地点：3 号楼 1 层 导师：向宇 人群：运维人员、数据库开发工程师 准备：个人电脑，提前阅读 https://bbs.huaweicloud.com/blogs/279990，熟悉实验流程和软件下载。 简介：如何使用 GaussDB (for Influx) + Grafana 搭建监控系统？ 我们日常工作中都需要用到时序数据库存储后台服务的监控数据，再通过监控系统和大数据处理系统利用时序数据库的数据查询和计算分析功能将业务监控和分析结果实时展现出来。本实验将教会你使用华为云数据库 GaussDB (for Influx) + Grafana 搭建亿级时间线数据的监控系统。 共创伙伴","link":"/activity/conference/coscon-2021-chengdu/"},{"title":"【2019 成都 Web 全栈大会】首批讲师来袭！","text":"2019 年刚过一半，就有小伙伴通过各种渠道来问：今年前端大会还有吗？ 很遗憾，没有了…… 但是！ 我们今年办 —— 全栈大会！！知识面拓宽不止一倍！！！ 西南地区的程序员小哥哥、小姐姐们，你们有没有兴奋地搓起小手手呢？ 先来看看一些 FCC 成都社区的新老朋友吧~ 内容剧透《聊聊 Node.js 构建部署时我们要关心的数据》在 DevOps 的时代，构建和部署都已经自动化了。我们可以在构建时和部署时收集一些我们可能要关心的数据，用于以后排错、预警等等。本 Topic 为我在蚂蚁金服做这些数据的收集和实践的一些总结。 死月 蚂蚁金服 Node.js 工程师；Node.js Core Collaborator 之一；《Node.js：来一打 C++ 扩展》作者。 《从 Angular Ivy 认识前端框架》作为新一代的 Angular 渲染引擎，Ivy 对编译器与运行时代码进行了整体重构，在保证编译和运行效率的基础上，实现了全功能按需引入及开发者友好的代码调试支持。这里将从 Ivy 的完整工作流程入手，结合编译器及运行时实现，介绍 Angular 的完整工作流程以及与其它框架的异同分析。 余泽江 ThoughtWorks 咨询师，95 后，Angular 项目的社区活跃贡献者及国内早期 Angular 布道者，主要专注于 Web 前端框架、JavaScript 语言以及 Web 规范相关领域。 《Thoughts In Deno》销声匿迹的 Deno 如今已经如何了？它身世背后的故事是什么？聊一聊我眼中的 Deno，以及我认为值得称赞的设计思想。 满远荣 来自重庆的 IT 难民，刚到成都讨饭吃的伪全栈工程狮。新晋的开源爱好者，Deno contributor，Deno 中国社区发起人。 《城市大脑地图可视化技术实践》 背景 组件库设计 生态建设 最佳实践 陈森森 中国科学技术大学毕业，计算机专业硕士。任职阿里巴巴高级前端工程师；擅长前端自动化、工程化，前端架构方向。目前在参与城市大脑前端项目建设，地图可视化组件库 gas.gl 的核心开发者。 《DevCloud Web Components 实践》Web Components 在华为云 DevCloud 如何落地？解决了什么问题？为什么要选用 Web Components？ 慕阳 曾经在美团、人人网等互联网公司担任前端开发工程师，目前是华为云 DevCloud 高级前端工程师，负责前端架构、技术预研、性能优化，热爱开源，喜欢折腾新技术。 《SoLiD 社交互联数据 —— 万维网之父的数据主权革命》 谢扬 蒸汽记忆创始人，曾任字节跳动 Hacker，领导开发过容器云、WebIDE、知识图谱等多个项目。现在在研发以身份为中心的操作系统，Authing 已服务海内外上千名开发者，托管超过百万用户。 全栈大会只有这些内容吗？ 不，我们今年办两天！~ 还有好多位大咖正在百忙之中为大家准备演讲主题，敬请期待哦~ 成都首届 Web 全栈大会 时间：2019 年 11 月 16~17 日 地点：成都市高新区天府软件园 共创伙伴招募品牌共创换言之，即是我们的赞助商。 我们的需求：现金赞助，或者场地、酒店、餐食、礼品、交通、搭建、设计、印刷、制作等物资或服务。 我们的回馈：全面的品牌广告价值，可能包括：联名主办、专属企业展台、企业资料入袋、企业与观众互动环节等。 体验共创本次活动外场设计有企业产品体验展台、企业招聘展台以及开源项目市集。 我们的需求：良好的企业产品体验展示、企业招聘者、开源项目宣传者 我们的回馈：精准的社区资源、较大的品牌广告价值。 媒体共创除了传统的媒体合作外，还需要新媒体领域的合作。 我们的需求：稿件采写、活动报道与分发、照片拍摄、创意短片策划、动画制作等。 我们的回馈：良好的品牌广告价值。 共创联络人有意者请联系 FCC 成都社区对外合作理事： 余先生","link":"/activity/conference/web-conf-2019-0/"},{"title":"【2019 成都 Web 全栈大会】门票开售！","text":"最近越来越多的小伙伴在问：“全栈大会完整议程啥时出啊？等着买票呢！” 那就准备好你的付款二维码，绝对物超所值哦！~ 【时间】2019 年 11 月 16 ~ 17 日 09:00 ~ 18:00 【地点】成都市高新区天府五街 菁蓉国际广场 7 号楼主会场 【议程】https://web-conf.dev/#2019/ 【报名】http://fcc-chengdu.mikecrm.com/7pG2aOh 【前情提要】https://fcc-cd.dev/activity/conference/web-conf-2019-0/ 第二波主题/* 贺老主题专用占位符 */ 领域 难度 ECMAScript 进阶 JS 最新的 proposal 介绍，包括提案的目的、用例、对开发者的影响、尚待解决的问题、采纳中需要注意的点等。 贺师俊 贺老 360 技术委员会 Web 前端 TC 委员，ECMA TC39 代表，W3C Chinese Web IG 成员。 《蚂蚁前端研发最佳实践》 领域 难度 前端框架、技术架构 入门 前端的发展真是太快了，每个月都会有新技术，大家普遍抱怨“学不动”。大到框架可以选 Vue、React 和 Angular，选了框架之后才会有很多子领域，前端轮子多的说法不是盖的，比如 CSS in JS 就有十多个方案，数据流方案有数十个方案，怎么选？ 然后选择其实对于个人和团队也会不同，个人可以选择最酷的最前沿的，而团队的选择则还需要考虑整体成本、研发提效等，抹平差异，让大家有差不多的项目、差不多的代码、差不多的目录结构等等，每个人切到另一个项目都有种熟悉感。 本次将和大家介绍蚂蚁前端的最佳实践的选择，比如语言、CSS、目录组织、路由、数据流、Mock、微前端、构建工具、组件开发、测试、性能优化等，以及最佳实践的迭代，遇到的问题、挑战和我们的思考。 陈成 蚂蚁金服 - 高级技术专家 花名云谦，入职阿里已有 11 年。之前在淘宝，负责过淘宝首页、宝贝详情、购物车、下单等很多重要业务的前端部分。然后转岗到支付宝，曾负责 SPM、支付宝开发者工具的开发，以及创建了 Dva、Roadhog、babel-plugin-import、Umi 等。擅长的领域有工具、前端框架以及前端性能等，热衷于开源，大家可以在 https://github.com/sorrycc 找到我。 《无服务器计算架构》 领域 难度 Serverless 入门 无服务器计算是云原生架构，使您能够将更多的运营职责转移到云平台，从而提高灵活性和创新能力。无服务器计算让您可以在不考虑服务器的情况下构建并运行应用程序和服务。它消除了基础设施管理任务，例如服务器或集群配置、修补、操作系统维护和容量预置。您能够为几乎任何类型的应用程序或后端服务构建无服务器应用程序，并且运行和扩展具有高可用性的应用程序所需的所有操作都可由您负责。 蒙维 亚马逊 AWS - 高级解决方案架构师 拥有 15 年以上电信级企业应用系统开发、设计和架构经验。擅长分布式和高可用软件系统设计，擅长微服务和无服务器应用架构设计，熟悉 CMMI 和 Scrum 敏捷开发流程，熟悉 DevOps。 “Brand New Things in WebAssembly Post-MVP Standard” 领域 难度 WebAssembly 进阶 WebAssembly 作为一种新的二进制格式，它可以方便地将 C/C++/Rust 等其他静态语言代码快速的“运行”在浏览器中，这一特性为前端密集计算场景提供了无限的可能。不仅如此，基于 WebAssembly 技术，我们可以快速的将基于 Unity 游戏引擎开发的大型游戏快速的移植到 Web 端，这一切都要归功于 WebAssembly 技术带来的前端运算性能的大幅度提升。 WebAssembly 技术现在已经成为 W3C 的标准，众多浏览器厂商已经提供了对其 MVP 版本特性的支持。在 Google IO 2017/18/19 连续三届大会上，谷歌也将 WebAssembly 技术作为重点进行了公开的演讲介绍和推广。 Post-MVP 版本标准更是会对诸如复杂类型引用（如 DOM 对象）、多线程和 GC 等特性提供支持。WebAssembly 技术所带来的、不仅仅局限于 Web 层面的技术变革在未来将变得势不可挡。 于航 PayPal - Web 前端工程师 曾在阿里巴巴本地生活、TapaTalk 等国内外企业工作，现在 PayPal 上海负责 Global GRT 平台相关的技术研发工作；FCC (freeCodeCamp China) 上海技术社区负责人；多次 QCon、GMTC 大会讲师。研究领域主要为前端基础技术架构、 Serverless、WebAssembly、LLVM 及编译器等相关方向。 作为 WebAssembly 技术布道者，2017 年注册成为 W3C 官方 CG 成员，定期参与 CG 组织的各种在线视频研讨会议，在跟进 Wasm 最新发展情况的同时也为 Wasm 的标准化提出自己的建议和意见。2018 年深度参与到 Emscripten 编译器工具链项目的研发工作中，同年出版名为《深入浅出 WebAssembly》的国内第一本 Wasm 技术书籍，为推动国内 Wasm 技术的发展和落地实践做出了微小的贡献。 《基于 Node.js 打造研发团队的瑞士军刀》 领域 难度 Node.js、工作流 入门 不断提高研发效率（快）与提升研发体验（爽）应该是一个团队成长所必需的两个点。团队无论大小，实际工作中总会遇上公司特有的各种重复性工作，这些脏活儿累活儿交给工具去做无疑会极大提高效率。类似我们用到的各种框架会提供 CLI，而面向团队内部工作流以及公司业务的 CLI，就需要我们自己去开发定制了。 我来分享的就是基于 Node.js，打造及持续沉淀一个团队内部工具集 Dev Tools 的过程中，所需要考虑的工具配置、用户配置、守护进程、文件操作、shell 交互、异常处理、优雅退出、团队协作、命令补全等事项，这可以是一个脚手架，也可以是个框架，目的是分享如何高效的打造这个瑞士军刀，让我们更专注去实现军刀的功能！ 陈洋彬 麦麦养老 - 软件研发负责人 在研发团队搭建与管理、技术体系持续演进与渐进增强、团队工作流设计等方面有一定心得和经验。多年服务后端、Web 前端研发及架构设计经验，关注技术的原理与融会贯通，主张编码与工程的专业、规范、极简。 《基于 GraphQL 的业务中台实践》 领域 难度 GraphQL、中台架构 进阶 面对公司内部老旧的权限服务，我们在只有两个开发人力的情况下，大胆依托 GraphQL 的便利性和工程化，通过 CQRS 模式拆解复杂度，形成了一套基于三种技术栈（基于 React + Antd + ApolloClient 的前端交互，基于 TypeScript + Mongoose + ApolloServer 的后台配置，基于 Spring Boot 2.0 Webflux + ApolloAndroid 的接口输出），支持多租户/多模式/高性能/灵活配置/实时生效的，垂直领域的业务中台。在此，我将向大家介绍我们对 GraphQL 的工程实践。 尹吉峰 原贝壳找房基础架构部工程师，多语言爱好者，偏向异步和函数式编程，酷爱原型搭建。 《Rust 语言全栈开发》 领域 难度 Rust、WebAssembly 进阶 使用 Rust 和 Seed，利用 WebAssembly 进行前后端全栈开发，充分利用 rust 的高性能和安全性，开启一种新的应用开发模式。实现无（手写）JS 的全栈开发新体验。 唐刚 Mike Rust 资深开发者，RustCC 社区联合创始人，在 Rust 的应用层面有一定探索。 “Enhanced Privacy with Decentralized Identity” 领域 难度 浏览器扩展、OpenPGP 进阶 Maskbook 是一个浏览器插件，可以让用户在正常使用 Facebook、Twitter 等社交网络的情况下，保护用户的个人隐私。为此，Maskbook 使用了密码学原理（对称加密与非对称加密），帮助用户对他们的数据进行了加密；也使用了许多前端技术来确保去中心化和隐私安全，包括 GunDB（一个去中心化图数据库）、@holoflows/kit （一个自己造的浏览器扩展开发工具包）、ShadowRoot（Web 标准）。 Jack Works Dimension - 现代前端魔法使 共创伙伴十分感谢共创伙伴们多方面的大力支持！也期待更多伙伴加入成都首届全栈大会的共赢共创！ 钻石赞助阿里云计算 金牌赞助（虚位以待） 银牌赞助（虚位以待） 铜牌赞助亚马逊 AWS 主办方FCC 成都社区 协办方四川捷云信通","link":"/activity/conference/web-conf-2019-1/"},{"title":"React 技术专场交流活动","text":"小伙伴们元宵节快乐！ 既 2017 前端大会 和刚刚谢幕的 黑客松 之后，FCC 成都社区 马不停蹄地开启了新的活动—— React 技术专场交流活动 ，旨在为刚刚燃起来的成都技术氛围再添新彩。 活动信息本次 React 技术专场交流活动 将是一场主要围绕 React 技术的高质量、高标准、高干货的技术分享与交流的活动，同时也是一场行业高度垂直、人才高度集中、明星企业高度集结的一场大型招聘盛会。 类型：技术分享 + 现场招聘 时间：2018-03-31 周六 12:40 地点：成都市高新区天府五街 200 号菁蓉国际广场 7 栋 1 楼主会场 费用：免费 报名：点击这里报名 签到：活动当天凭 签到凭证 进入会场 技术交流嘉宾腾讯云 郭庆 腾讯云 Web 前端工程师，负责云数据库多个产品，长期从事前端框架设计、规范化和工程化工作。 陈津 腾讯云 web 前端架构师，现负责腾讯云 web 前端/node 平台框架设计和研发，曾先后负责 WP/WIN10 QQ，腾讯云诊断 App；擅长混合开发，web 网络问题定位，平时喜欢玩玩音乐。 蚂蚁金服 简念 蚂蚁金服前端工程师，07 年即加入百度成为一名前端工程师。10 年间撸过从活动页面到复杂 SPA 等各种前端项目。 美团 吴浩麟 一线前端工程师，曾就职于腾讯，现就职于美团。专注于 Web 开发，参与过众多大型 Web 项目的构建、设计和开发，喜欢探索 Web 前沿技术。也是 Golang 和音视频技术的爱好者，活跃于 GitHub，ID 为 gwuhaolin，著有《深入浅出 Webpack》一书。 京东 唐超 8 年前端从业经历，京东无线店铺以及装修平台、智慧店铺、海外站、无线店铺\\活动、618 实时大屏等项目中担任核心开发，热爱前端，拥有丰富的前端开发经验，广泛涉猎于 web 端、RN、游戏、动画等不同平台开发领域，对前端大规模复杂应用、电商平台前端架构、性能优化、游戏活动等有丰富的心得和经验，乐于分享 知道创宇 范卿麟 知道创宇全栈工程师，研发平台负责人；8 年软件从业经验，从业务复杂的巨型企业项目到高效迭代的小微创业产品都有深度参与，重度工作爱好者；现专注研发团队效率提升、通用研发平台打造；希望能给大家带来平静和快乐。 神秘嘉宾 88 年狮子男，7 年攻城经验，曾就职于阿里妈妈用户体验中心、后联合创立硅谷某留学创业公司、目前是国内生鲜 No.1 创业公司大前端负责人，他来自杭州、他是慕课网精英讲师、教学视频累计学习人数达到 48.7 万，开创了 Node 系列教学视频的先河，拥有大量开发者粉丝。 活动流程12:40 - 13:00 活动开始签到 现场交流 13:00 - 13:40 腾讯云成都 React 前端架构 &amp; 大数据可视化应用 分享嘉宾：腾讯云 郭庆、陈津 分享内容一：【腾讯云业务 React 前端生态和架构】任何开发团队都遇到团队与项目扩张，代码质量不统一，逻辑复用困难等问题，这次分享主要介绍腾讯云成都团队在基于 React 生态方面的探索和落地实践，包括 React 常用编程模式、自有框架和设计思想以及工程化实践等内容。 分享内容二：【腾讯云基于 React 的大数据可视化应用实践】随着大数据行业的爆炸发展，数据可视化在前端逐渐成为一个比较热门的方向，这次主要分享腾讯云基于 React 在可视化方向上架构的实践，包含可视化组件架构设计，以及可视化编辑架构设计 。 13:40 - 13:50 提问时间13:50 - 14:30 用 TypeScript 开发大型 React 应用 分享嘉宾：美团: 吴浩麟 分享内容：React 通过组件化和虚拟 DOM 简化代码复杂度，TypeScript 通过工程化手段保证大型项目代码的质量，作为前端技术堆中的两大明星，它们可以结合互补用来解决开发大型前端应用的一些问题和难点。 嘉宾将分享美团在开发大型前端应用时使用 TypeScript 和 React 的经验，涵盖构建、性能、代码质量等主题。 14:30 - 14:40 提问时间14:40 - 15:20 React 快乐开发与安全生产 分享嘉宾：知道创宇 范卿麟 React 作为前端开发生态的代表作，围绕其周有着许许多多的技术框架及最佳实践。本次分享将从 React 出发，介绍编码、测试、审计、部署等等阶段中 “快乐开发” 的秘密，以及在开发的过程中所需要注意的安全问题。 15:20 - 15:30 提问时间15:30 - 16:00 现场简历投递环节 招聘企业信息发布 休息 16:00 - 16:40 React Form 指南 分享嘉宾：蚂蚁金服 简念 分享内容：表单处理在前端开发中一直占据重要位置，本次分享以日常开发中各种典型的表单应用场景为例，介绍基于 react 的表单解决方案,并深入介绍 ant design 中 form 模块的实现原理。 16:40 - 16:50 提问时间16:50 - 17:30 ReactNative 开发实践及在京东业务中的运用 分享嘉宾：京东 唐超 分享内容：在分享中嘉宾会对 ReactNative 的技术架构、开发基础进行介绍，让大家有一个全方位的认识,然后将分享该技术在京东项目实战中运用的方案，以及如何进行性能优化等等，对很多问题将会进行具体的分析。 17:30 - 17:40 提问时间17:40 - 18:10 神秘嘉宾分享环节18:10 集体拍照留念&amp;技术分享环节结束18:20 现场招聘环节报名方式方式一：点击这里报名方式二：扫描下方二维码，填写报名信息 活动单位 支持企业特别鸣谢 鸣谢 感谢 合作社区 参与招聘企业 腾讯云、美团、京东、蚂蚁金服、知道创宇 BBD、企鹅医生、乐车邦、ThoughtWorks、麦麦养老 麦客、tap4fun、货车帮、医联、果小美、23 魔方、汇通天下 招聘与商务合作请联系微信: h994154036 社区介绍FCC 成都社区, 即 freeCodeCamp 成都社区。是一个非营利性的公益性技术社区，是由一群热血有志青年爱好者，利用个人业余休息时间组建而成的技术社区，目的是为了搭建一个友好的交流、学习、互助的社区，帮助成都市众多的开发者，技术爱好者提升个人技术能力。社区致力于做西南地区首个有温度与情怀的技术社区，鼓励人人皆可编程实现个人梦想。 如果您想在 2018 年里： 第一时间了解最新高质量的技术交流活动 查看每周一的技术周刊 和成都更多的开发者进行技术交流 随时掌握成都最新明星企业的招聘 让技术大牛带你装逼带你飞 可扫码关注技术社区微信公众号！","link":"/activity/conference/react-conf-chengdu-2018/"},{"title":"2018 重庆前端大会","text":"​ 献给前端的少年们前端的少年们，你们是否和我们一样，发现重庆的前端技术交流存在肥沃的土壤？ 是否也渴盼已久，想要一场专属自己的、独一无二的前端技术交流会？ 那你们是否知道， 2015 年，大批热衷前端的开发者，曾共同策划举办了首届重庆前端交流会。 当时，许多行业组织、互联网大牛帮助有志的互联网人才雄起，变得有“前”又有“钱”，找到了奋斗方向。 2016 年，众多重庆前端从业者集结，参加了第二届前端交流会。 不仅奉献了一场技术盛宴，还共同探讨了开发者及初创企业如何在互联网技术浪潮中稳步前进的问题。 如今，经过两年的积累和沉淀，我们理性归来—— 大数据、可视化、区块链…… 2018，我们想和你一起聊聊这些面向未来的黑科技和前端开发之间千丝万缕的关系。同时也借此机会和大家分享职业成长，一起展望更美好的未来。 活动概况 活动主题：2018 重庆前端开发者交流大会 活动时间：2018.08.18 09:00-18:00 活动地点：混沌星球 1687（重庆市渝中区贰厂文创公园 7 号楼 2 楼） 活动目的 前端布道，传播前沿的技术知识 营造氛围，提供更多的交流机会 持续发展，让沉淀和传播更久远 活动定位 传承 —— 让知识和经验得以沉淀，让分享精神延续 交流 —— 提供交流渠道，探讨前沿技术 归属感 —— 凝聚日益壮大的新鲜的队伍 主办方：混沌重庆、孔明科技 年度赞助方：WEWIN 金牌赞助：孔明科技 铜牌赞助： 重庆卓米科技有限公司 重庆常朝科技有限公司 合作媒体： 人邮异步社区 freeCodeCamp 3W 企服 其它赞助：图灵出版社 ​ 活动流程 时刻 议程 09:00 主办方致辞 09:10 孟之杰《DApp 开发入门》 10:05 姜姜姜《一个技术社区的使命》 11:00 唐友华《怎样让薪资 10 年涨超 30 倍》 11:55 午餐、休息、现场招聘、自由活动 13:40 圆桌《给大家的职业成长建议》 14:40 熊洋《如何参与开源项目》 15:35 水歌《Node.JS 与无界面浏览器》 16:30 月影《基于 Canvas 的跨平台绘图对象模型》 17:25 抽奖 17:45 会后自由交流、合影、聚餐 活动嘉宾月影 《基于 Canvas 的跨平台绘图对象模型》 —— 给对 Canvas、跨平台、可视化和国产开源感兴趣的你 对于我们的吴亮——月影大大，是不是早就久仰大名啦！他曾在微软亚洲研究院做过访问学生，先后在金蝶软件有限公司、百度电子商务事业部、盛大创新院任职。并且早在 2008 年，他的《JavaScript 王者归来》一书就由清华大学出版社出版，豆瓣评分高达 7.5！现在，月影大大正在 360 做总监，带领 360 最大的前端团队——奇舞团。 多年来，月影大大致力于 JavaScript 技术和 Web 标准的推广，活跃于国内极有影响力的 JavaScript 专业网站——无忧脚本，并担任 JavaScript 版的版主！ 这样一位业界堪称“大神”的人物，就要来到我们的现场啦。这一次，他的分享主题是《基于 Canvas 的跨平台绘图对象模型》，将会围绕国产开源、跨平台、可视化分享自己的最新观点，热爱前端的你，是不是已经心动了呢？！ 孟之杰 《Dapp 开发入门》 —— 给想要了解、掌握区块链应用开发的你 孟之杰是奇舞团的成员之一，360 区块链实验室成员，前端跨界程序员，技术翻译爱好者，极客。 他在区块链的开发方面很有经验。这次活动，他计划分享有关 DApp 开发入门的干货，帮助前端开发从业者了解区块链应用（DApp）的开发流程，以及如何用前端熟悉的技术开发 DApp。 所以，想要掌握区块链应用开发技能的小伙伴，一定不要错过这次分享噢！ 唐友华 《怎样让薪资 10 年涨超 30 倍》 —— 给有上进心、有进取心，想要努力改变命运的你 他是孔明科技的前端架构师，个人经历可以用“传奇”来描述：本科学习生物专业，与计算机技术没有多大关系；单出于对前端开发的兴趣，他完全零基础自学，并且在没有个人电脑的情况下，进入前端开发行业，并坚持从业 11 年。 他曾先后在新华社、人人网、新浪网、猪八戒网任职。现在的他，从买不起电脑的农村孩子，到有车有房有事业，薪资涨幅超过 30 倍。 2014 年 3 月，他发起了重庆地区的非盈利性质前端技术交流活动，并逐步演变成了现在的重庆前端交流会。 关于如何提升自我驱动力、如何更好地自我认知、如何建立有效的决策机制，以及对前端开发的认识，他有很多思考和感悟，想要和你分享。 水歌 《Node.js 与无界面浏览器》 —— 给喜欢小众话题、热爱自动化测试的你 他现在是 tap4fun Web 前端工程师，FCC 成都、中国社区理事会成员，也是 JavaScript 全栈开发者、开源软件作者、freeCodeCamp 中文社区技术布道师和 jQuery 贡献者。 如果你对自动化测试感兴趣，不妨来听一听他的分享，说不定会发现，他是你的同道中人呢！ 熊洋 《如何参与开源项目》 —— 给想要了解开源世界中那些精彩故事，以及想要作为个人开发者参与其中的你 熊洋是美团前端工程师，Vue 开发组成员，Babel 代码贡献者。 想知道如何参与到世界一流的、有 10 万+关注人数的 Vue.js 开源项目中去吗？如何赢得创始人的认可、受邀加入核心团队，和行业内国际一流顶尖高手一起工作吗？ 这些，他做到了，在这次的分享会中，他会毫无保留地与你分享。 姜姜姜 《一个技术社区的使命》 —— 给零基础但是想要接触新鲜事物、想要了解编程的你 姜姜姜的个人经历，可以用“有趣”+“传奇”来形容：她曾主持过 50 多场婚礼，做过高中数学老师。在接触到 FCC 社区后，她决定从零基础开始，自学编程，从此走上了程序员的道路。 这次分享，热爱体验不同生活方式的姜姜姜将会分享她的那些奇特体验，同时，她也会介绍 FCC 的背景和历史和 FCC 成都社区的发展历程；并且和重庆热爱前端的小伙伴一起，成立 FCC 重庆社区，让对编程感兴趣的同学有机会免费自学。期待一下，接触编程以后，也许你的人生也会变得有趣得超乎你想象噢。","link":"/activity/conference/web-fe-conf-chongqing-2018/"},{"title":"fCC Coffee & Code 周末编程自习室 2025年8月3日","text":"还在一个人对着屏幕写代码吗？本周末，来和 fCC 成都社区的伙伴们一起结对编程吧！无论你是编程初学者、进阶学习者还是开发者，都能在这里找到志同道合的小伙伴。 这一次，我们希望带你体验更真实、更有温度的编程学习方式： 自由结对：随机或自选伙伴，一起挑战小任务，交流彼此的思路。 项目共创：社区开放项目现场对接，想加入团队实战的朋友千万别错过。 问题速解：不会写？卡 Bug？这里有经验丰富的社区伙伴可以帮你出招。 灵感碰撞：比起独自写代码，和人聊聊需求、架构、实现，往往更有启发！ 活动依旧 免费参加，饮品自费。无需准备复杂议题，带着问题或小目标来就好～ 📍 活动信息 时间：2025 年 8 月 3 日（周日）14:00 - 18:00 地点：漫咖啡MAAN COFFEE(红唐店) - 成都市武侯区天府大道中段中1388号红唐购物中心1层LA104 直播：https://vc.feishu.cn/j/755910722 人群：编程初学者、爱好者、从业者 文档：fCC 成都社区 Coffee &amp; Code 周末编程自习室 2025年8月3日 费用：活动免费、饮品自费 装备：自备电脑 📚 主要内容 开源市集项目进展分享 中国公益数据库 2.0 fCC 成都社区官网（2025版） 开源市集官网 开放会务系统 黑客松开放平台 HOP Coffee &amp; Code 结对编程体验 为什么要来？ 找到志同道合的学习伙伴，避免单打独斗 用结对方式更高效地完成学习或开发任务 接触社区真实项目，参与开源，提升实战经验 发现灵感、拓展人脉，轻松高效度过周末 无论你是想完成自己的学习计划，还是想在真实场景下提升技术，带上电脑，加入我们，一起分享知识、输出代码、结识朋友！","link":"/activity/salon/20250803-coffee-code/"},{"title":"Deno 入门与 Chrome 性能调试","text":"2019 年 6 月 30 日 13:30 ~ 17:30 成都市高新区天益南巷 18 号创客大使馆 JavaScript 前后端的小伙伴有没有被一天到晚填坑而累得没脾气呢？ 想不想学点高端武艺来对 bug 降维打击呢？ FCC 成都社区半月一次的小活动又来了！！！ 主题简介《Deno 初体验》 让我们来了解 Node.js 之父 Ryan Dahl 的新“造物”Deno 背后的动机，来一起学一下别人“学不动的” Deno，从背景及语法再到简单 HTTP 服务入手，畅谈 Deno 的现在和未来。 讲师简介满远荣，前重庆优启科技架构师、前重庆奇燎科技 CTO，现 ThoughtWorks 切图仔。 Deno contributor；Deno 中国发起人、Deno 中文社区站长及发起人；denolib 组织 Member；Deno 生态核心基础库作者和贡献者。 《Chrome DevTools 之 performance》 从浏览器渲染到动画性能调优，让自己写的前端代码渲染性能可控。 讲师简介Helen，爱玩的程序媛，喜欢写代码、玩游戏、架子鼓、马拉松。 她也是 FCC 成都社区核心成员、Vue Beauty 组件库活跃开发者，并在 Google Women TechMaker 2018（成都站）、第 0 届学生开源年会等会议上发表演讲。 课前准备安装 DenoLinux、Mac OS X在命令行终端执行以下命令： curl -fsSL https://deno.land/x/install/install.sh | sh Windows在 PowerShell 中执行以下命令： iwr https://deno.land/x/install/install.ps1 | iex Mac OS X在命令行终端执行以下命令： brew install deno 安装 Google Chromehttps://google.cn/chrome 参考资料 Deno 中文手册 Deno 核心指南 Deno 生态集锦 活动总结由于本次活动的出品人水歌上周经历了重感冒、在公司项目写微信小程序的双重折磨，没能尽早确定活动日期并联系场地方，导致本次场地没有可用的 HDMI 投影仪、智能电视，只能临时用 AK 同学的私人 Zoom 会议室共享讲师屏幕…… 但幸好大家一起把三张大桌子连起来，人手一台电脑地坐一起，反而拉近了人与人的距离，又找回 2016 ~ 17 年在 @Too 的【拾级咖啡】办活动时的那种感觉！ 第一个主题 Deno 乍看 PPT 很简单，但随着满远荣老师的逐步发散，让在座很多 Web 工程师发现 Deno 独特设计的奥妙 —— 小巧的单可执行文件 —— 安装、部署非常简单 开箱即用的 TypeScript 支持 —— 保持 JS 灵活的同时又强健 内置最新 Web API —— 前端同构代码更好移植 依赖包一条 URL 搞定 —— 基于 ECMAScript 模块标准 虽然现在 Deno 标准库尚不完善，但正因为基于 ES module，一个常用功能官方是否提供，甚至有没有官方软件源，都已不再重要，Deno 完全变成了分布式系统。 尽管如此，官方还是希望维护一批由核心开发者维护的高质量常用库，满老师自己开发的 SMTP 工具库就是 Deno 创始人中意的之一，我们也有幸现场跟着老师从零写一遍这个库的核心代码，通过实践来体会 SMTP 协议和 Deno 的简洁。 【注】我事后发现了一个 VSCode Deno 扩展的 bug —— https://github.com/justjavac/vscode-deno/issues/44 紧接着的第二个主题由我们 FCC 成都社区颜值担当之一的 Helen 小姐姐讲解，几张言简意赅的图文 PPT 之后，便直接开始用 demo 程序演示如何用 Chrome 调试器来分析、优化动画渲染性能。 勤于思考的小伙伴们在讲完后提出了多个值得思考的问题，Helen 在会后的活动总结中做了进一步解答。 活动结束时，小伙伴们纷纷表示收获颇丰，但希望动手实践环节能再更易上手些，并通过一些思考题来现场编码，提升动手的参与度。这些建议我们会在和满老师一起准备下期 Deno 活动时充分采纳，敬请期待！","link":"/activity/salon/deno-chrome/"},{"title":"结对编程的理念","text":"虽然深藏保利中心高层的【拾级咖啡】不太好找，但依然没消磨大成都地区 15+ 小伙伴参会的决心，成华、新津一类郊区也不是事儿~ 而且，热情的店主也是技术出身，小店安静、惬意的环境，让 Coffee &amp; Code 可谓名副其实了~ 本期的主题是【结对编程】，一种【敏捷开发】的常见模式，也是入门编程的良好方法，很适合 FCC 线下活动 —— 结对编程心得分享 结对编程的正确姿势 主讲人向大家介绍完“结对编程”的基本概念、方法后，让大家分组认领 FCC 成都社区官网的完善任务，在现场实践当天所学的同时，为社区建设添砖加瓦！ 活动过程中大家尽量“老带新”，两两积极讨论、编码，氛围不错。但不足在于活动结束时，仅一半左右的小组提交了代码，其中只有两个小组在 GitHub 上通过 Pull Request 合并回主库。究其原因，我想是 —— Web 前端新人居多、经验不足，改已有代码不知从何下手 大家 Git、GitHub 使用较少，在代码提交、合并方面 概念模糊","link":"/activity/salon/pair-programming-concept/"},{"title":"Google I/O 2019 回顾会（成都站）","text":"2019 年 Google I/O 大会已经落下帷幕，今年成都 GDG 的负责人再次奔赴 I/O 大会现场，成都 GDG 的旗帜也再一次飘扬在大洋彼岸。为了把本次 I/O 大会的新技术、新趋势带回给社区，带回给国内的开发者，成都 GDG 社区将在 5 月 25 号举行今年的 Google I/O 大会回顾。本次活动还邀请了在 Google 新加坡公司从事云解决方案以及云机器学习的大牛到场分享，诚邀大家参加！ 面向人群 对技术痴狂、热爱游戏、热衷尝新，且崇尚科技的你 对 GDG 感兴趣的你 活动议题2019 Google I/O 大会回顾嘉宾简介毕强，Web 全栈工程师、应用架构师，成都谷歌开发者社区负责人之一，连续多年奔赴 Google I/O 大会现场。 内容大纲 今年 I/O 大会新产品、新技术的见解 Google 新一代跨平台开发工具 Flutter 的介绍和应用场景解析 Google Cloud Machine Learning workshop嘉宾简介Markku is a Cloud Solutions Architect at Google. He has worked in cloud computing for the past 10 years. Before joining Google, Markku led the cloud architecture of Nokia Siemens Networks’ global business units, and covered APAC as a technology evangelist at Amazon Web Services. He works out of Singapore, and helps developers and customers across APAC and Japan understand how to best use and architect solutions for Google Cloud. Markku is the IoT solutions lead for J/APAC for Google Cloud. Web 与 Chrome 的新进展嘉宾简介水歌，Web/JavaScript 全栈工程师、开源软件作者，freeCodeCamp 成都社区第 4 任负责人、18 年老谷粉、微软 MVP，致力于 Web/JavaScript 标准应用、开源模式推广。 内容大纲 新实现的 Web API HTTP 协议演进 JavaScript 在 V8 引擎中的改进 Google 搜索支持 How to 微数据 Material Design 支持 Dark 模式。 会后资料 《Web 与 Chrome 的新进展》演示文稿 《Web 与 Chrome 的新进展》观众笔记 现场照片 联合出品主办 协办 场地赞助 媒体宣传","link":"/activity/salon/google-io-2019-extended/"},{"title":"FCC 小姐姐直播教你 Vue 3.0！","text":"【时间】2020 年 8 月 27 日（周四）19:00 ~ 20:00 自 Vue 3.0 开放了源码，开发者最关心的是框架的更新能为带来什么编码优质体验。本次分享将介绍 Vue 3.0 的新特性以及和 2.0 的区别，也会分享做组件库时踩到的坑，让大家可以避免踩雷。","link":"/activity/salon/vue-3-quick-start/"},{"title":"【开源】Vue 3 小程序引擎 & React 富文本编辑器","text":"开源项目都很高大上吗？ 不，开源作者就在你身边！ 些许的实践与反思，就能催生一个小小的开源项目~ 阳春三月，一起和去年 1024「开源市集」中的两位开源人感受春暖花开吧~ 时间：2021 年 4 月 18 日（周日）13:30 ~ 17:30地点：成都市高新区天府五街 200 号箐蓉汇 2 栋 5 楼少灏厅 Vue Mini：Vue 3 小程序引擎 简介Vue Mini 是一个基于 Vue 3 的小程序开发库，它能让你用 Composition API 写小程序。与某些小程序开发方案不同的是 Vue Mini 仅仅是一个轻量的运行时库，它既不依赖任何编译步骤，也不涉及任何 Virtual DOM。并且 Vue Mini 从一开始就被设计为能跟小程序原生语法协同工作，你甚至能在同一个页面或组件内混用原生语法与 Vue Mini，这能让你很轻松的将其整合进既有项目中。当然，你也能完全使用 Vue Mini 开发一个小程序。 Vue Mini 仅聚焦于小程序逻辑部分，也就是 JS 部分，它并不影响小程序的模版、样式及配置。 作者 杨明山 ThoughtWorks 高级 Web 工程师 React Bootstrap editor：轻量级富文本编辑器 简介React Bootstrap editor 是一个基于 TypeScript、React 和 Bootstrap 的轻量级富文本编辑器，没有繁杂的 API，只有基于抽象类的平台封装： document.execCommand() document.queryCommandState() document.queryCommandSupported() document.queryCommandEnabled() Selection API 而其自身代码不过 400 行，原型实现也只花了外包项目恼火一天后的 4 小时熬夜。 作者 水歌 idea2app 团队创始人","link":"/activity/salon/vue-3-mini-app-engine-react-rich-text-edtior/"},{"title":"Web 与 JavaScript 的新天地","text":"春风已至，百花正开，我们一起，创造 1024。2021 年的首场技术分享，我们说来就来。成都 HDZ 邀请业界大咖分享一些技术领域上的历程与成果。如何利用现有开源基础设施做一个减法，让 Web 打包器再次简单。前端语言 JS 如何在万物互联的浪潮中激流勇进，打通新的奇经八脉。HDZ 欢迎更多志同道合的朋友，携手同行一起构建开放、创新、多元化，有活力的开发者社区组织，我们欢迎您的到来。 活动简讯 活动时间：2021 年 3 月 27 日 13:30 ~ 17:00 活动地点：天府五街 200 号箐蓉汇 2 栋 5 楼少灏厅 活动内容《让 Web 打包器再次简单！》 水歌 沿着 Web 开发技术发展的历史进程，分析现有各种 Web 打包器的优缺点；再针对现状的痛点，总结出打包器的设计原则；并借用现有开源基础设施，尝试实现一个简洁的打包器。 《JS Everything 之 JS IoT》 唐云峰 JS 全栈概念主要是基于 Web 开发而言。但新的应用场景需求要求用户交互界面从电脑屏和手机屏跳出到物理世界，越来越多的应用需求需要使用到人工智能技术，甚至区块链技术也被节奏带着进入了广大应用领域。本次分享 JS 在物联网下的大放光彩。","link":"/activity/salon/web-and-javascript-new-age/"},{"title":"产品设计与计算机科学","text":"freeCodeCamp 成都社区 2019 秋季第一期沙龙 不少人一直觉得 FCC 只是个“前端社区”，其实 Quincy Larson 创社之初就没做这个限定，只不过 Web 前端对零基础的人最好上手，线上课程才以前端做入门。其实 FCC 中文化伊始，我们就有 Node.JS 后端 、 通用算法 、 计算机科学 、 程序员面试 等课程， 计算机英语教程 也在计划中。freeCodeCamp.org 志在成为计算机教育界的“维基百科”，目前国际站的 Alexa 全球网站排名已超过同类著名商业平台 Udacity.com（优达学城）。 FCC 成都社区也一直秉持“IT 从业者全职业生涯技能提升”的宗旨，让大家在家门口学习各种 IT 互联网行业的知识。本期线下沙龙，让我们一起从产品设计与计算机科学的全局高度，来重新审视日常繁杂的工作，给有志进一步提升的小伙伴一些启发与思考。 主题简介《创业中打造产品品牌和 IP 的区别、方法与效果》相信每一个程序员都有一个自己的产品梦，在工作之余孵化一个自己的项目。不管是从自身价值、工作之余的额外收入还是业余时间创业，都是不错的选择。 讲师简介 何姚含 交互设计师。爱好研究分享产品、设计、用户体验等内容。有个美工人工智能做图产品创始人，前京东高级设计师。 《计算机科学概览》快速计算机科学概览之一（从早起手工计算设备到现代计算机的历史） 讲师简介 书香墨剑（余琦） FCC 成都社区组织者，野生 JavaScript 程序员一枚，现于可好玩乐从事少儿编程平台全栈开发。","link":"/activity/salon/product-desgin-computer-science/"},{"title":"应用开发之王 —— Web 标准技术","text":"FCC 成都社区走进四川大学 网页制作 N 剑客（2000 ~ 2010） Microsoft FrontPage Adobe Photoshop Adobe Dreamweaver Adobe Flash 闪客帝国 AIR HTML 5 + CSS 3 (2014 ~ ) “给我做个 H5” “我要做个小程序” 前端三大框架 Web everything（2015 ~ ） ECMAScript 2015 + Node.js 4 JavaScript 中文兴趣组 Web Components PWA WebGL WebAssembly Web USB Web Authn Web RTC 弹幕 会议博文 标准草案 Web of Things WebXR FCC 成都社区","link":"/activity/salon/web-standard-app-development/"},{"title":"fCC 成都社区 Coffee & Code 周末编程自习室 2025年10月19日","text":"近一个多月真的是中国人的爱国教育月 —— 九三抗战胜利日、九一八国耻日、十一国庆节。吾等平民百姓虽无力左右宏大叙事，但可以从身边小事做起，用开源代码助力公益事业，为爱国尽绵薄之力！ 本期 fCC Coffee &amp; Code 将主要分享【开源市集】社区的【开源公益】计划，同时现场展示、演练如何用 AI agent 加速公益 IT 基础设施的建设。 活动信息 时间：2025-10-19 14:00~18:00 地点：漫咖啡MAAN COFFEE(红唐店)，四川省成都市武侯区天府大道中段中1388号红唐购物中心1层LA104 人群：编程初学者、开源爱好者、公益志愿者、AI 从业者 费用：参会免费、餐饮自费 文档：https://open-source-bazaar.feishu.cn/wiki/L1UqwHif2i4HBHkbZMpcrAutn6d 直播：https://vc.feishu.cn/j/757288816 群聊：https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=0dcqe9e3-5f27-4d5d-a30c-0477b64c828b 活动内容 🤖AI agent 通用代码库规格文件 @水歌 🚀开源公益计划发布 @水歌 🚧中国公益数据库 2.0 测试服导入旧版数据 @水歌 @罗基印 前端页面接入测试服 @水歌 🛠️新冠抗疫信息平台 后端基于 SQL ORM + Docker 重构 @水歌 前端基于 EChart-JSX 1.x 精简、优化 @水歌 🚧开源市集官网 老乡鸡开源菜谱知识库 @水歌 🛠️开源镜像站 Web polyfill 中国大陆备份镜像由 fCC 成都社区接管 @水歌 💻结对编程","link":"/activity/salon/fcc-chengdu-coffee-and-code-2025-10-19/"},{"title":"fCC 成都社区 Coffee & Code 周末编程自习室 2025年9月7日","text":"9 月开学季，恰逢大阅兵，fCC 成都社区邀您一同探讨 AI MCP 编程技巧、飞书建站方案。用代码致敬开源精神，让技术如阅兵般整齐有力！ 活动信息 时间：2025-09-07 14:00~18:00 地点：漫咖啡 MAAN COFFEE(红唐店)，四川省成都市武侯区天府大道中段中 1388 号红唐购物中心 1 层 LA104 人群：编程初学者、开源爱好者、AI 从业者 费用：参会免费、餐饮自费 文档：https://open-source-bazaar.feishu.cn/wiki/O7d7wTOJZiVbc6k8h0YcInu9nkg 直播：https://vc.feishu.cn/j/154339918 群聊：https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=0dcqe9e3-5f27-4d5d-a30c-0477b64c828b 活动内容 💡Python 中文社区【开源松】@TechQuery https://codekitchen.community/t/topic/1095 https://codekitchen.community/c/song/l/latest?board=default 🛠️Claude Code 在开发中的使用 @hu-qi 从早期对 Claude Code 的偏见到现在开发中离不开 Claude Code ，我究竟经历了什么？ 🚀组织智能化转型之 idea2app 飞书方案 @TechQuery 结合开源市集官网、开放会务系统、开放治理系统等的开源代码更新，讲解如何利用飞书低成本、低代码地建设公益组织、中小企业的 IT 基础设施。 💻 结对编程 https://github.com/FreeCodeCamp-Chengdu https://github.com/Open-Source-Bazaar","link":"/activity/salon/fcc-chengdu-coffee-and-code-2025-09-07/"},{"title":"Web 前端入门指导","text":"主要流程 FCC 介绍 自我介绍和分享 在 FCC 学习中，遇到困难了吗？小伙伴们帮你解决 前端导航、优质微信公众号推荐，让你对前端更入迷 九个 Console 命令推荐，让 JavaScript 调试更简单","link":"/activity/salon/start-web-front-end/"},{"title":"走近函数式编程","text":"活动简介活动主要是从书香墨剑学习函数式编程的心得体会出发，来谈谈他所理解的函数式编程，并以一个罗马数字转阿拉伯数的例子和大家一起探讨函数式编程的使用以及对我们日常编码的影响，最后大家互相分享对函数式的理解。 活动信息 时间：2019.03.30 14:00 - 17:00 地点：成都市高新区世纪城路 1029 号天华社区乡愁故事馆 活动流程 时刻 内容 14:00 Who are you? 14:10 函数式编程之我知 14:40 函数式编程之我用 16:00 你谈？我谈？共交流 我可以参与？欢迎有一定 JavaScript 基础、对函数式编程有所理解 或 有不同看法的小伙伴~ 活动总结一来到活动现场，乡愁故事馆的文艺气息似乎可以冲淡些技术宅的刻板，为沙龙参会者带来一丝别样的感受。本次沙龙的主讲书香墨剑不但网名文艺，平时也是个话剧爱好者，活动场地也是他亲自选的，果然符合本人气质。 What ?业内人士深知源自数学思想的“函数式编程”抽象晦涩，书香便以川菜经典“回锅肉”的做法来讲解 —— function 煮(肉) { return 水 + 火 + 肉; } function 炒(...食材) { return 油 + 火 + 食材 + 盐; } let 回锅肉 = 炒(炒(切(煮(肉))), 切(蒜苗), 豆豉); 数学函数 层层传递输入输出、不引用外部变量、不改变外部变量 等主要原则一目了然。 但往往概念、原则讲多了，初学者要么云里雾里、要么颠覆三观，不能对新学的思想方法正确认识、合理运用。于是书香便一针见血地来了个“敲黑板”三连 —— 函数式编程只是一个编程范式！ 区别在于对程序的抽象看法； 一段程序里可以存在多个编程范式。 那…… 书香你怎么看？一图胜千言 —— Why &amp; How ?既然函数式编程有这么多好处 —— 方便单元测试 减少外部状态干扰 通过高阶抽象方便阅读、灵活组合 那该怎么用呢？很多人连 JavaScript 数组自带的 map()、filter()、reduce() 都还用不好呢。无妨，我们动手演练一个例子 —— 罗马数字与阿拉伯数字的转换。 规则如下： // 罗马数字与阿拉伯数字的对应 const roman_arab = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; 罗马数字从大到小排列，并加起来得到最后的结果，只有下列情况除外： I 可在 V、X 前，表减 1（如 IV 表示 4） X 可在 L、C 前，表减 10 C 可在 D、M 前，表减 100 最后我们实现了罗马数字转阿拉伯数字的代码： const romanLetterToInt = letter =&gt; { const table = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; if (table[letter]) return table[letter]; throw Error(\"capacity should be positive integer\"); }; const strSplit = str =&gt; str.split(\"\").map(romanLetterToInt); const subtractItem = arr =&gt; arr.map((element, index, arr) =&gt; index &lt; arr.length - 1 &amp;&amp; element &lt; arr[index + 1] ? -element : element ); const getInt = str =&gt; subtractItem(strSplit(str)).reduce((acc, curr) =&gt; (acc += curr), 0); 以及阿拉伯数字转罗马数字的代码： const table = { 5: [\"I\", \"V\", \"X\"], 50: [\"X\", \"L\", \"C\"], 500: [\"C\", \"D\", \"M\"] }; const intToIString = number =&gt; new Array(number).fill(\"I\").join(\"\"); const mergeLetter = (str, numIndex) =&gt; { const length = str.length; const headLen = Math.floor(length / 10), tailLen = length % 10; const headerArray = new Array(headLen).fill(table[numIndex][2]); switch (tailLen) { case 9: return headerArray .concat([`${table[numIndex][0]}${table[numIndex][2]}`]) .join(\"\"); case 4: return headerArray .concat([`${table[numIndex][0]}${table[numIndex][1]}`]) .join(\"\"); default: const tailArray = new Array(Math.floor(tailLen / 5)) .fill(table[numIndex][1]) .concat(str.substring(str.length - (tailLen % 5)).split(\"\")); return headerArray.concat(tailArray).join(\"\"); } }; const splitStr = (str, numIndex) =&gt; { const index = str.split(\"\").findIndex(ele =&gt; ele !== table[numIndex][0]); return index &gt;= 0 ? [str.slice(0, index), str.slice(index)] : [str, \"\"]; }; const mergeStr = (arr, numIndex) =&gt; mergeLetter(arr[0], numIndex) + arr[1]; const getRoman = num =&gt; mergeStr( splitStr( mergeStr(splitStr(mergeStr(splitStr(intToIString(num), 5), 5), 50), 50), 500 ), 500 ); 再举个栗子本次活动主题较为抽象，主讲者虽尽力借鉴生活中的例子来讲解“函数式编程”的理念，但大家还是比较困惑；加上参会者自带电脑的又比较少，原定的现场动手实践较早结束。于是水歌便上台即兴分享了自己做过的 TDD 习题 —— 基于函数式编程的保龄球算法，让大家更清晰地认识函数式编程的应用范式。 每局比赛每人有十轮投球 每轮共有两次机会来打倒全部十个瓶子 一次打完为“全中”，本轮得分为 10 + 后两球分数 两次打完为“补中”，本轮得分为 10 + 后一球分数 第十轮全中、补中加 2、1 次击球 规则看完，想必全中、补中的事后加分最让人头疼…… 但函数式编程范式却像我们上学解数理化题时“套公式”一样，让计算程序一目了然 —— 每局分数 = 本局第一次击球分数 + 本局第二次击球分数 + 下局第一次击球分数 x 补中系数 + (下局第一次击球分数 + 下局第二次击球分数) x 全中系数 用代码描述如下： // 两数相加 function sum(first, second) { return first + second; } // 补中系数 function isSpare(first, second) { return first !== 10 &amp;&amp; first + second === 10 ? 1 : 0; } // 全中系数 function isStrike(first) { return first === 10 ? 1 : 0; } // 每轮分数 function round(this_first, this_second, next_one, next_two) { return ( this_first + this_second + isSpare(this_first, this_second) * next_one + isStrike(this_first, this_second) * (next_one + next_two) ); } 上述代码虽清晰明了，但还有个关键没有解决 —— 未来的分数怎么办？这就需要学习函数式编程的第一难关柯里化来解决： function curry(origin) { // 原函数声明了几个参数 const count = origin.length; // 包装函数 return function wrapper() { // 当前是否已有足够的参数 return count &gt; arguments.length ? // 还差几个，返回一个记住已传入参数的新函数 wrapper.bind(this, ...arguments) : // 够了，执行原函数 origin.apply(this, arguments); }; } 这样我们就可以把击球数一个个填进去，最终合计即可算出总分 —— const curry_round = curry(round), score = []; score[0] = curry_round(3)(7)(3)(4); // 13 score[1] = curry_round(3)(4)(0)(0); // 7 score[2] = curry_round(10)(0)(3)(7); // 20 // 以此类推…… 讲到这儿，台下部分同学频频点头，露出了“原来如此”的笑容~ 活动反馈以下是会后部分同学的建议 —— 编辑器居然没有设置自动保存 不写注释一时爽，一直不写一直爽 其实讲一讲 Redux，对大家理解函数式编程帮助比较大 其实讲一些实用的例子会更好，也更容易理解！ 听了对柯里化理解还不够 罗马数字转阿拉伯数字的例子不错。阿拉伯数字转罗马数字的例子可以不用讲了，比较冗余了。可以加点例子: 如果其中某个函数抛出异常了怎么处理。 参考资料 主讲 PPT 罗马、阿拉伯 数字互转 保龄球计分","link":"/activity/salon/start-functional-programming/"},{"title":"AI时代前沿的创新与实践","text":"本次AI 技术分享会汇聚多位技术专家与教育创新者，共同探索人工智能时代下的技术应用与教学变革。 📢 活动亮点 🔧 技术实践：获得可立即应用的 AI 技术实操方法。 🎓 趋势洞察：了解智能教育的最新发展趋势。 💡 思维拓展：激发跨领域创新思维与合作机会。 🔥 明星嘉宾阵容📚 AI 编程教育的探索之旅 彭雪梅 | 创业者 | 全栈工程师 | fCC 活动组织者 AI高效提取内容，助力学习复盘 自动生成教学视频，提升课堂体验 复杂知识点一键图解 🤖 DeepSeek 创新点与本地化部署 何静 | AI 技术研究者｜AFE AI 社群主理人 DeepSeek 创新点 本地部署大模型以及应用 Agent 前沿发展趋势 🗃️ 数据库技术及应用·从原理到实战 孙瑜 | 西南石油大学教授 | 华为 ICT 学院负责人 数据库基础原理精讲 openGauss数据库架构及关键技术解析 SQL语言实战演练 🎨 AI绘图魔法升级·图片也能当指令！ 王润林 | 软件工程师 | AI 技术探索者 零门槛”图生图”技巧，新手友好创作 文字提示词精髓，精准指挥AI生成 快速落地应用（如海报设计） 揭秘 GPT-4o 等模型的图像能力提升 ⏳ 活动日程 时间 环节 14:00-14:30 签到 领取福利 14:30-14:45 介绍环节 14:45-15:15 AI 编程教育的探索之旅 15:20-16:00 数据库技术及应用·从原理到实战 16:10-16:50 DeepSeek 创新点与本地化部署 17:00-18:00 AI 绘图魔法升级·图片也能当指令！ 🚀 活动信息 时间：2025 年 4 月 26 号 14:00-18:00 地点：天府五街 200 号菁蓉汇 2A 栋 5 层少颢厅 模式：线下为主，线上为辅 设备：自带电脑 费用：免费 🎁 特别惊喜 ✔ 价值 382 元洁牙卡 ✔ AI 工具资源大礼包","link":"/activity/workshop/ai-events/"},{"title":"【阿里云】Web 前端工作坊","text":"【时间】2020 年 8 月 15 日（周六）13:30 ~ 17:10【地点】成都天府五街 菁蓉国际广场 2 栋 5 楼少颢厅【设备】自带电脑！自带电脑！自带电脑！ 互动奖品 WebCell 棒球帽 WebCell 主题提问者可获赠一顶 WebCell 棒球帽~","link":"/activity/workshop/aliyun-web-front-end/"},{"title":"【fCC成都社区技术分享活动】","text":"费用：免费 设备：​自带电脑 参与方式：线下为主，线上为辅 活动日程 时间 内容 讲师 14:00-14:30 签到 14:30-14:40 自我介绍 14:40-15:30 JavaScript 栈溢出的底层原理 彭雪梅- 资深前端工程师 15:40-16:20 AI 时代开发者的突围与重构·聊聊技术、产品、商业 Ironben - 开源智能助手 5ire.app 作者、Essay.ink 文字社区主理人、饺子科技产品领航员 16:30-18:00 结对编程-现场有预设主题或自行选择编程主题 17:30-18:00 展示成果并分析心得、疑问解答","link":"/activity/workshop/ai-javascript-events/"},{"title":"双手编写未来","text":"**freeCodeCamp 成都社区** 走进 **成都七中育才学校** “编程”是什么？编写“程序” “程序”又是什么？做一件事的流程 —— 算法 流程所需材料的规格 —— 数据结构 程序是一种“说明文” 程序 = 数据结构 + 算法 为何要编程？阐述想法，做“甩手掌柜”，让机器帮我们做事 程序“代码”又是什么？代码 = 英文单词（逻辑）+ 代数符号（计算） 为何代码能处理事物？计算机代码是种形式语言、符号系统 能转化为数学计算 数学公式可以描述万事万物 艾达·拜伦 (1815 ~ 1852) 全球公认第一位程序员 计算机科学的半边天多个里程碑都由女性铸就 6 位女性共同为全球第一台公开的电子计算机编程 葛瑞斯·霍普 (1906 ~ 1992) 程序编译器之母，发现了史上第一个 Bug 玛格丽特·汉密尔顿 (1936 ~ ) 软件工程之母 海蒂·拉玛 (1914 ~ 2000) 移动数字通信之母 1980 年代开始，计算机科学领域女性锐减 性别 只影响思维视角，不影响智力 不要妄自菲薄！ 第一份代码选一门直观、通俗的编程语言入门 比如 标记型语言 HTML 再选一个开箱即用的框架和模板 Talk is cheap, show me your Code!李纳斯·托沃茨 (1969 ~ ) 一刻钟学一课全球最大的公益编程学习平台 freeCodeCamp 中文社区 成都社区 QQ 群 微信服务号","link":"/activity/salon/hands-write-future/"},{"title":"FCC 技术翻译工作坊（第一期）","text":"想在 GitHub 给国外某大型开源项目提 issue，你用心编写一段中文，机翻的英文自己读来读去都觉得不通顺，只好放弃贡献大型开源项目的机会…… 公司远程会议上国内外同事讨论得热火朝天，突然有人叫你名字 “What’s your opinion?”，你觉得尴尬指数五颗星，因为他们之前讨论的你只听懂 60%…… 第一次带女朋友出国旅行，出发前你努力练习问路、砍价的常用口语，想要塑造与当地人谈笑风生的男神形象，结果女朋友觉得还是手机里的腾讯翻译君更让她有安全感…… 不要慌，问题不大 7 月 14 日，FCC 成都社区工作坊又来啦，快来约~~ 结对翻译，成为 freeCodeCamp.org 国际社区的开源贡献者，不仅能提升你的英文水平，还能提升你的 Git 操作熟练度。 不管你是什么行业的小哥哥小姐姐，只要你对翻译感兴趣，都可以参加！ 翻译内容freeCodeCamp.org 是一个注册在美国的非营利组织，创立于 2014 年，以“帮助人们免费学习编程”为使命，创建了庞大的完全免费的学习资源。freeCodeCamp 英文社区的成员发布了大量优质文章，分享前端、后端、 Android、iOS、产品、设计、区块链、人工智能等领域的内容，以及学习编程的经历和求职经验，我们一起把这些文章翻译成中文，分享给更多读者。 我们将在 freeCodeCamp 的 GitHub 仓库协作，参与者可以戳 👆 链接提前浏览挑选你想要翻译的文章喔（文章持续增加中^_^）。 工作坊引导者Coding 引导者：水歌freeCodeCamp 成都社区第 4 任负责人、微软 2018~2020 年度 MVP（最有价值专家）、开源社官网开发组组长，主攻 Web/JavaScript 全栈开发，是多个国际开源项目的贡献者、多个原创开源软件的作者。 语言引导者：Miya曾经是 freeCodeCamp 的志愿者，因为热爱非营利组织与教育，现在全职加入了这个团队，担任 Chinese Community Ambassador，是 freeCodeCamp 在中文地区的唯一员工，与团队和贡献者们一起协作推动社区国际化。 活动流程 时段 内容 13:30 ~ 14:00 参与者陆续到场 14:00 ~ 14:20 FCC 国际社区简介，破冰 &amp; 结对 14:20 ~ 14:30 翻译规范简介 14:30 ~ 17:00 结对翻译进行时 17:00 ~ 17:30 成果分享","link":"/activity/workshop/fcc-technical-translation-0/"},{"title":"内容型网站应用一小时实战","text":"freeCodeCamp 成都社区 在线工作坊 #1 学习收获个人、公益组织、创业团队 快速搭建自己的网站，并生成智能机桌面的 App，同时掌控所有数据、轻松迁移。 教程主旨 内容型网站：新闻门户、官方网站、个人博客、维基百科、技术文档 网站应用：基于 Google 力主的 PWA 国际标准，一键生成网站的 App 零基础、零成本、免维护：开源的一键化生成工具、个人免费的自动化云服务 在线课堂2019 年 3 月 24 日（周日晚）20:00~22:00 内容大纲 基础软件安装（课前准备，下附截图） 挑选 Hexo 主题模板（课前准备） 网站项目生成 # 以 GitHub 账号 FCC 为例 npm init hexo-wiki create ~/Desktop/FCC \\ --theme NexT \\ --plugins hexo-permalink-pinyin \\ --remote https://github.com/FCC/FCC.github.io.git 自定义网站配置 配置托管服务 GitHub 账号注册 配置部署服务 写第一篇文章 配置顶级域名 挑选、注册域名 CloudFlare 账号注册 生成独立应用 参考文档 Hexo 官方文档 Git 简易指南 教练团队 主讲：水歌 助教：Akagilnc、Too、姜姜姜、书香墨剑、ing 助教招募 必要技能：熟悉 Windows、Linux 或 Mac OS X 命令行、包管理器、Git 可选技能：用过 Node.JS、Hexo（或其它静态网站生成器） 【附 0】Windows 软件安装图解0. 安装前提Windows 7 / 8 / 10（及同代 Windows Server） 1. 打开命令行 2. 安装包管理器 （复制、粘贴以下命令） Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 【注意】 已经装了同类或同样的软件可以把那个名字删掉，不用重复装 如有软件安装出现问题，可自行下载、安装，优先安装 Zoom 客户端 3. 安装必备软件（复制、粘贴以下命令） choco install -y git tortoisegit nodejs-lts vscode googlechrome zoom 【附 1】Mac OS X 软件安装图解0. 安装前提Mac OS X 10.10 及以上版本 1. 打开命令行 在 SpotLight 里输入“终端”后回车 或从 LaunchPad 里点击“终端”图标 打开的界面如下，可以在这个提示符后面输入命令执行 2. 安装包管理器在终端里粘贴如下命令后，回车执行 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 界面如下 回车执行之后显示类似如下输出（安装过程中需要回车确认执行安装，有可能还需要输入用户的电脑密码） 如没有报错，看到 Installation successful 字样即表示安装成功！ 注意：安装非常慢、超时等可能与国内网络条件有关，需要参考 macOS 安装 Homebrew 使用国内镜像源安装。（如下图的报错） 如下图的安装失败则需要参考 Mac 上安装 homebrew 的心酸历程 执行 git 的配置命令： git config --global http.postBuffer 524288000 3. 安装必备软件依次执行如下两条命令进行安装 —— brew install node cask brew cask install sourcetree visual-studio-code google-chrome zoomus 【注意】 已经装了同类或同样的软件可以把那个名字删掉，不用重复装 如有软件安装出现问题，可自行下载、安装，优先安装 Zoom 客户端 4. 参考资料 macOS 缺失的软件包的管理器 macOS 安装 Homebrew Mac 上安装 homebrew 的心酸历程 macOS 安装 homebrew 报错 LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54 【附 2】Linux 安装最新版 Node.JSFedora/CentOS、Debian/Ubuntu 等主流发行版官方软件源的 Node.JS 版本可能 &lt; 6.3.0，要先安装 NVM： curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash # 或者 wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash 再安装 Node.JS 最新 LTS 版： nvm install --lts 【附 3】科学上网工具 https://github.com/getlantern/lantern https://psiphon.ca/zh/","link":"/activity/workshop/hexo-web-app/"},{"title":"【工作坊】遗传算法一小时编程","text":"在线运行例子https://demongodyy.github.io/GA-Robi/ 代码仓库https://github.com/demongodYY/GA-Robi 偷懒的大自然你有没有想过，你为什么是你现在的样子？这个世界又是谁设计并构建出来的呢？达尔文的进化论给予我们看待这个世界的视角：物竞天择，适者生存。大自然有种神奇的力量，它只是简单地制定了生存的规则，而让万物自由地生长、进化，一代又一代地演变，就逐渐构建出了我们当今的世界。 写程序同样是一个“构建世界”的过程，通过每一行代码来描述出各种事物并在计算机的世界中运行。对于简单地问题，我们可以编写具体的指令来运行。但是，当问题超过一定复杂程度的时候，编写海量地代码指令来描述每一处细节，就显得比较困难了。比如说想要编写一个自动打扫屋子的机器人，所面临的情况就是千变万化的，如果要为每一种可能性都去编写指令，会显得非常复杂。我们能不能“偷下懒”，只写出一些很少的代码，让代码帮我们自动“生成”机器人最优的打扫规则呢？ 遗传算法借鉴达尔文的进化论和孟德尔的遗传学说，在计算机中我们也可以设计出一些算法，通过适者生存的方式，帮助我们慢慢找出规则中优秀的“基因”，通过“遗传”地方式保留下来，从而找寻到一些问题的最优解。 实际上，遗传算法已经有了很多有趣的应用，诸如寻路问题，8 数码问题，囚犯困境，动作控制，找圆心问题（在一个不规则的多边形中，寻找一个包含在该多边形内的最大圆圈的圆心），TSP 问题，生产调度问题，人工生命模拟等。 而在这次工作坊中，我们可以建立一个小小的“清扫垃圾机器人”的游戏，来看看遗传算法的究竟。 游戏规则假定有一个机器人叫做 Robi，它存在的世界是由一个 10x10 共 100 个的方格组成的围墙中。在这些方格中，会随机有 50%的几率有一个垃圾。而 Robi 的任务就是尽可能多的捡起这些垃圾。 游戏的规则如下： Robi 的动作一共有 6 种：上移、下移、左移、右移、随机移动、捡垃圾。 Robi 每一步只能执行上述动作中的一种，一共可以走 200 步。 Robi 每次得分规则如下： 如果在有垃圾的地方进行了“捡垃圾”的动作，就 +10 分，如果没在没有垃圾的地方“捡垃圾”就 -1 分。 如果移动撞墙了，就 -5 分并弹回原地。 其他情况分数不变。 可以看出，在执行 200 步的情况下，最低分是 -1000 分（一直撞墙），最高分是 500 分（所有垃圾都捡到了）。 最后， Robi 可以看见上下左右以及当前总共 5 个格子的情况。情况分 3 种：有垃圾、空格子、墙。也就是说 Robi 每行动一步时所面临的情况有 3^5 = 243 种（简单起见，包括了脚底下也踩着墙这种不可能出现的情况）。 我们所要做的就是给这 243 种情况设定规则，让 Robi 能在游戏中得到尽可能高的分数。 工作坊流程 介绍游戏基本规则，及简单运行方式，在这可能会涉及到一些浅显地“数字化”的过程理解。 尝试编写自己的规则来尽可能地优化算法，获取更高的分数 讲解遗传算法原理，对比遗传算法生成出来的规则与人为优化的规则。 或许可以开下脑洞，比如自然是不是一段算法代码而已？ 谁能参加理解遗传算法本身更是不需要任何编程知识，拥有编程技能可能更能动手试验一下，对于了解游戏规则本身更有帮助，所以： 如果你是程序员或者能看懂 js 代码，欢迎带上电脑来亲手编写代码试验一下，这样更能感受到不一样。 如果你对写程序并不熟悉，也可以来思考，这个问题并不需要太高深的写代码的技巧，更重要地是讨论和思考的过程，你可以在现场 找一名程序员与 TA 结对编程 得到什么 你将理解如何将现实游戏的规则“数字化”到代码中进行模拟。 你将理解或亲手实现一个算法，它会通过遗传迭代，自动生成出符合游戏规则的最优方案。 或许你能在这个过程中感受到人与自然的关系？","link":"/activity/workshop/genetic-algorithm-starter-workshop/"},{"title":"NodeJS 网页爬虫一小时实战","text":"freeCodeCamp 成都社区 在线工作坊 #2 2019 年 4 月 14 日（周日）晚 8 ~ 10 点 加 QQ 群 (466129470) 上课（入群注明课程名） 学习收获一小时内学会用 Node.JS 从多个网站汇总最新本地 IT 活动列表，并了解一些知识点 —— 用 Chrome 调试器分析 HTML 结构 用 Chrome 调试器分析 HTTP 接口 Puppeteer 无界面浏览器操作 JavaScript 最新标准语法 内容大纲 JavaScript 标准项目生成 静态网页抓取 动态网页抓取 数据接口分析 数据分页处理 课前准备请学员务必提前执行以下命令，安装好开发环境！（操作图解） Windowschoco install -y git tortoisegit nodejs-lts vscode googlechrome zoom Mac OS Xbrew install node cask brew cask install sourcetree visual-studio-code google-chrome zoomus 操作要点JavaScript 标准项目生成npm init es-pack ~/Desktop/web-crawler code ~/Desktop/web-crawler 为 Node.JS 定制配置npm uninstall amd-bundle npm install -D \\ @babel/cli \\ @babel/core \\ @babel/plugin-transform-runtime npm install @babel/runtime package.json { \"engines\": { \"node\": \"^6.13.0\" }, \"script\": { \"lint\": \"eslint source/ --fix\", \"pack\": \"babel source/ -d dist/ -s\" }, \"babel\": { \"presets\": [ [ \"@babel/preset-env\", { \"targets\": { \"node\": \"6.13.0\" } } ] ], \"plugins\": [\"@babel/plugin-transform-runtime\"] } } 静态网页抓取安装依赖包npm install jsdom 核心代码source/static.js #! /usr/bin/env node import \"@babel/polyfill\"; import { JSDOM } from \"jsdom\"; (async () =&gt; { const { window: { document } } = await JSDOM.fromURL(\"https://segmentfault.com/events?city=510100\"); const list = [ ...document.querySelectorAll(\".all-event-list .widget-event\") ].map(item =&gt; ({ title: item.querySelector(\".title\").textContent.trim(), date: item .querySelector(\".widget-event__meta :first-child\") .textContent.trim() .slice(3), address: item .querySelector(\".widget-event__meta :last-child\") .textContent.trim() .slice(3), banner: item.querySelector(\".widget-event__banner\").dataset.original })); console.info(list); })(); 编译并运行npm run build node dist/static 动态网页抓取安装依赖包npm install puppeteer-core @tech_query/node-toolkit npm install fs-match -D 增加项目配置package.json { \"scripts\": { \"install\": \"app-find chrome -c\" } } 首次安装需手动应用配置： npm run install 核心代码source/dynamic.js #! /usr/bin/env node import \"@babel/polyfill\"; import Puppeteer from \"puppeteer-core\"; import { getNPMConfig } from \"@tech_query/node-toolkit\"; (async () =&gt; { const browser = await Puppeteer.launch({ executablePath: getNPMConfig(\"chrome\") }); const [page] = await browser.pages(); await page.goto(\"https://juejin.im/events/chengdu\"); await page.waitFor(\".events-list .events-inner\"); const list = await page.$$eval(\".events-list .events-inner\", list =&gt; list.map(item =&gt; ({ title: item.querySelector(\".title\").textContent.trim(), date: item.querySelector(\".date\").textContent.trim(), address: item.querySelector(\".address\").textContent.trim(), banner: (item .querySelector(\".banner\") .style.backgroundImage.match(/url\\((?:'|\")?(.+)(?:'|\")?\\)/) || \"\")[1] })) ); console.info(list); process.exit(); })(); 编译并运行npm run build node dist/dynamic 数据接口分析 安装依赖包npm install node-fetch 核心代码source/data.js #! /usr/bin/env node import \"@babel/polyfill\"; import { URLSearchParams } from \"url\"; import fetch from \"node-fetch\"; (async () =&gt; { const response = await fetch( `https://event-storage-api-ms.juejin.im/v2/getEventList?${new URLSearchParams( { src: \"web\", orderType: \"startTime\", cityAlias: \"chengdu\" } )}` ); const data = await response.json(); console.info(data.d); })(); 编译并运行npm run build node dist/data 数据分页处理传统思路source/data.js import { URLSearchParams } from \"url\"; import fetch from \"node-fetch\"; export default async function (index = 1) { const URL = `https://event-storage-api-ms.juejin.im/v2/getEventList?${new URLSearchParams( { src: \"web\", orderType: \"startTime\", cityAlias: \"chengdu\", pageNum: index } )}`; console.warn(URL); return (await (await fetch(URL)).json()).d; } source/index.js #! /usr/bin/env node import \"@babel/polyfill\"; import crawler from \"./data\"; (async () =&gt; { const list = []; for (let i = 0; ; ) try { const page = await crawler(++i); if ((page || \"\")[0]) list.push(...page); else break; } catch (error) { console.warn(error); break; } console.info(JSON.stringify(list, null, 4)); })(); 通过命令输出数据到文件 —— npm run build node dist/ 1&gt; index.json 现代思路source/data.js export default async function* (start = 1) { while (true) { const URL = `https://event-storage-api-ms.juejin.im/v2/getEventList?${new URLSearchParams( { src: \"web\", orderType: \"startTime\", cityAlias: \"chengdu\", pageNum: start++ } )}`; const data = (await (await fetch(URL)).json()).d; if ((data || \"\")[0]) yield { URL, data }; else break; } } source/index.js #! /usr/bin/env node import \"@babel/polyfill\"; import crawler from \"./data\"; (async () =&gt; { const list = []; for await (let { URL, data } of crawler()) { console.warn(URL); list.push(...data); } console.info(JSON.stringify(list, null, 4)); })(); Think more… 多源数据去重 定期抓取 展示界面 本地应用打包 服务器部署 【附】样本数据 https://www.huodongxing.com/events?orderby=n&amp;tag=IT%E4%BA%92%E8%81%94%E7%BD%91&amp;city=%E6%88%90%E9%83%BD https://www.bagevent.com/eventlist.html?f=1&amp;tag=17&amp;city=%E6%88%90%E9%83%BD https://www.oschina.net/event?tab=latest&amp;city=%E6%88%90%E9%83%BD&amp;time=all https://juejin.im/events/chengdu https://segmentfault.com/events?city=510100 【附】参考文档 项目创意 DOM API 文档 Node.JS 中文文档 Puppeteer 中文文档","link":"/activity/workshop/nodejs-web-crawler/"},{"title":"AI 学院工作坊 #0","text":"AI 学院与 FCC 成都社区联合出品 一次开放的 AI 深度学习体验，一场解码 AI 更多可能性的讨论。 —— 在这里，数位来自成都的热爱 AI 科技的 Deans 期待与你相遇！ 参会须知 目标群体：软件开发者、会一点点程序设计的人、AI 从业者 免费！自带电脑！！！ 主要流程 AI 学院简介 AI 简介 Python 环境和深度学习开发依赖的安装 实现一个简单的深度神经网络 课前准备建议学员提前执行以下命令，安装好开发环境（操作图解） Windowschoco install -y git tortoisegit python vscode miniconda3 Mac OS Xbrew install python brew cask install sourcetree visual-studio-code miniconda Conda 虚拟环境 与 python 依赖包conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes conda create -n deeplearning python=3.6.5 -y conda-env list conda activate deeplearning # 中国教育网用户切换镜像 # pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple pip install matplotlib numpy pandas tensorflow==1.11.0 keras -i https://pypi.doubanio.com/simple/ 特别鸣谢 天华社区乡愁故事馆是由桂溪街道天华社区居委会主办，桂溪街道办事处支持，爱有戏社会工作服务中心运营的公益性社区营造项目。 活动回顾我们的主讲 Ethen 老师Ethen 用浅显易懂的语言和实例，像大家介绍了什么叫做 AI、机器学习、深度学习、神经网络。 比如，这是一个假设的，根据面积来预测房价的图，而这条绿线，就是最贴近各个点的一条线，那么其实就可以表现为一个神经元 那么多个因素就可以生成多个神经元，根据我们定义的逻辑就可以把它们组合起来形成多个神经元组成的网络 —— 神经网络 而机器学习的奇妙之处，在于它可以自己去寻找这一层原本需要人类去定义的关系，所以在这里，实际的神经网络变成了下图所示的结构 而机器学习会试着去找出更合理的规则，来让我们的答案更加贴近我们的目标。 最终，我们理解了这几个术语的意义与关系 真的是连完全没有经验的小白都能理解呢，给 Ethen 老师打 call！ 专心思考的参与者们全程无尿点，后续的提问环节也是有大量的小伙伴提出了很有质量的问题，看来大家是真的理解了呢。唯一的遗憾可能就是因为网络不太好没有能跟着实现一遍了吧，后续补上～ 隐藏的角落这位美女提出了相当棒的问题，作为一个不会编程的人，却从数学的角度给出了很棒的建议，建议用距离正确答案的比例差来取代绝对值差，就连 Ethan 老师也是赞不绝口呢！ 下次还要来玩哦希望这次大家玩的开心，下次还要来哦！","link":"/activity/workshop/school-of-ai-0/"},{"title":"AI 学院工作坊 #1","text":"AI 学院 与 FCC 成都社区联合出品 大家复联都看了么？每个英雄都认识的清清楚楚了吧？ 可你知道，AI 也能认识英雄么? 今天，我們要教 AI 做图像识别， 介绍我们的超级英雄给 AI 认识吧。 —— 在这里，数位来自成都的 AI 科技爱好者期待与你相遇！ 参会须知 目标群体：软件开发者、会一点点程序设计的人、AI 从业者 免费！自带电脑！！！提前做好课前准备（见下文）！！！ 主要流程 Python 环境和深度学习开发依赖的安装 图像处理相关概念介绍 图像识别的 Python 实现 实现漫威英雄识别 课前准备请提前执行以下命令，安装好开发环境（操作图解） Windowschoco install -y python miniconda3 Mac OS Xbrew install python brew cask install miniconda Conda 虚拟环境 与 Python 依赖包conda create -n deeplearning python=3.6.5 matplotlib -y conda-env list conda activate deeplearning pip install scikit-image opencv-contrib-python numpy tensorflow==1.11.0 keras \\ -i https://pypi.doubanio.com/simple/ 活动回顾Ethan 老师这次给我们带来了 图片识别 的内容 我们用到了 Google 预先训练好的 inception v3 卷积神经网络，用 2573 张图，训练了一个全连通的神经网络 了解了每张图可以用像素的特征来展示。这里我们用 1280 个参数来表示一张图。 最终在某种准确度上，实现了区分复联里的超级英雄的能力。","link":"/activity/workshop/school-of-ai-1/"},{"title":"微信机器人入门实战 Python & JavaScript","text":"2019 年 6 月 16 日 13:30 ~ 17:30 成都市高新区天益南巷 18 号创客大使馆 基本流程跟着教练一起，实现一个简单的微信机器人 自动通过好友请求 发送信息给指定好友 发送信息给特定群体 拉人进群 你的收获 收获志同道合的小伙伴，锻炼你的思维、动手能力和表达能力 学会用 Python 或 JavaScript 做自己的微信机器人 参与须知 活动免费，自带电脑和你的激情！ 对小白友好，欢迎任何对 coding 感兴趣的小伙伴参与! 课前准备建议学员提前执行以下命令，安装好开发环境（操作图解） 安装包管理器WindowsSet-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) Mac OS X/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 如果提示权限问题，请在前面加上 sudo 安装开发环境Windowschoco install -y git python nodejs vscode googlechrome pip install pipenv -i https://pypi.doubanio.com/simple/ # 或 pip3 install pipenv -i https://pypi.doubanio.com/simple/ Mac OS Xbrew install python nodejs brew cask install sourcetree visual-studio-code google-chrome pip install pipenv -i https://pypi.doubanio.com/simple/ # 或 pip3 install pipenv -i https://pypi.doubanio.com/simple/ 项目初始化Pythonmkdir ~/Desktop/WeChat-robot cd ~/Desktop/WeChat-robot pipenv install itchat -i https://pypi.doubanio.com/simple/ Node.JSmkdir ~/Desktop/WeChat-robot cd ~/Desktop/WeChat-robot npm init -y npm set puppeteer_download_host https://storage.googleapis.com.cnpmjs.org npm install wechaty wechaty-puppet-puppeteer puppeteer 参考资料 WeChaty 官方文档 WeChaty 规范示例 FCC Panky 微群管 活动回顾即将开始还没有开始呢，水歌大佬就已经迫不及待的指点迷津了 破冰时间大家各自介绍了自己，希望你们在活动中交到好朋友哦 导师风采学习真是一件开心的事情！ 活动现场我们先从登录和自动回复消息入手 然后给特定好友发消息，再给群组好友发消息 最后学会了如何自动通过好友请求，并且把这个好友拉入指定的群 完结撒花大家都动手敲了一个下午，收获满满吧？下次还要来哦！ 反馈教训事后我们做了反馈调查，小伙伴们提出了一些超棒的建议 对于pipenv和虚拟环境的认识不够，可以做一些说明 现场环境网络比较差 椅子质量有点差（摔） 活动内容本身 节奏希望再紧凑一些 除了按照导师教的做之外，能有一些小挑战，即学习、模仿、思考题的模式 现场采用结对编程的模式，让大家更有互动感，也可以规避一些环境安装的问题 活动完后可以给学员一个发表感受的机会 我们非常感谢这些很棒的建议，并且会应用到下一次工作坊，敬请期待～","link":"/activity/workshop/wechat-robot/"},{"title":"【工作坊】Web 标准组件开发","text":"正在筹划本期工作坊时，就看到 FCC 成都社区的微信群里有小伙伴在苦恼前端技能提升的问题，也有小伙伴想一起开发一个组件库，那你们这次可来对了~ 本期工作坊是水歌在 2019 年 Google DevFest 成都站《Web 组件标准实践》演讲后的首次配套工作坊，可以错过上次，但一定不要错过这次！ 【时间】2019 年 12 月 21 日（周六）13:30 ~ 17:30 【地点】成都市高新区天益南巷 18 号创客大使馆 实践收获 学习 Web Components 标准原生 API 的基本用法 了解 WebCell 如何基于 TypeScript、JSX、Parcel 简化 Web 组件开发 亲手封装一个基于 BootStrap 的通用 Web 组件，现场为开源项目做贡献 实践路线图Step 0 | Web Components 标准简介 Web Components 是一套浏览器提供的新标准 API，用于实现框架无关的 Web 组件。其官方 polyfill 补丁支持 IE 11+，Polymer、Angular、Ionic Stencil 等国际 Web 前端框架已全面应用。 Step 1 | 手写一个 Web 组件只用 Web Components API 来实现一个简单的组件。 Step 2 | 用 WebCell 简化组件 WebCell 是一个基于 Web Components API 的轻量级组件引擎，在保留 Web Components 核心写法的同时，基于 TypeScript、JSX、Parcel 等成熟技术，进一步简化 Web 组件的开发。 Step 3 | 封装一个 BootStrap 组件 BootStrap BootStrap 可谓 CSS 框架时代的开创者，一直被模仿、从未被超越。在同时代的大量同类框架中，现在基本只有它还在持续演进。 在当今基于 Angular、React、Vue 等的 JS 组件库大行其道之时，BootStrap 为何仍有很大的优势？来基于它亲自封装一个通用 Web 组件、开发一个 Web 应用，你就能体会到其设计的独到之处~","link":"/activity/workshop/web-components-development/"},{"title":"【工作坊】文化成都，文言编程","text":"说到中文编程，上了年纪的程序员想必知道易语言、中蟒、周蟒、孔 Caml 等语言，所有支持 Unicode 的现代编程语言也都支持用汉字等非英文字符做标识符（比如水歌参与翻译的 CodeceptJS API）。但在华人 IT 界，中文编程一直争议极大、毁誉参半。不过，两岸四地的华人程序员们，多年来却从未放弃对母语编程的不懈探索。 最近一位在美国卡耐基梅陇大学读书的华人大四学生又新创了一门中文编程语言 —— WenYan（文言），一个月左右的时间便在 GitHub 斩获近一万四千 star！ WenYan 编程语言 但它与上述前辈迥然不同，不再是简单地替换英文标识符、关键字，徒生违和感，而是完全以古汉语的语法行文，再编译为 JavaScript、Python 等主流语言去运行，可谓是真正的用中文去编程！ 不仅如此，作者从一开始便运用开源社区运营手法 —— 英文说明文档、语法规范文档、在线开发环境、本地编辑器插件等一应俱全，甚至还结合《九章算术》等古代数学著作的风格做了代码古籍图片生成器！实乃后生可畏，我大中华复兴有望矣！ 于是乎，生长于中国历史文化名城的 FCC 成都社区也想为中文编程做一点微小的贡献，便有了本期工作坊（这恐怕是全球第一次文言编程线下活动）~ 【时间】2020 年 1 月 12 日 13:30 ~ 17:30 【地点】成都市高新区天府五街 200 号 菁蓉国际广场 2A 栋 9 楼 紫荆谷众创空间 序言夫混沌初开，阴阳分晓。盖两仪化四象，四象生八卦，八卦生无穷，此天地万物之生也。至冯祖降世，悟有无之道，尽天机之正，锻金为骨，化爻为髓，作精妙之仪，御之以电，上可演九章算术，下可推少广方田， 乃开后世之先河。 然则阴阳之道，众人难之，皆欲代之以文，谓之语言。不意甲子之期未至，百家争鸣已然，程式语言之多，繁若《天官》之星宿，奇胜《山经》之走兽。然以文言编程者，似所未有。有奇人 LingDong，宿好文章，且通程式，乃做斯言，行文言编程之事。且承开源之大义，此当吾辈之所以勉励也。 吾辈小子数人，尝创可思摩斯之奥义。结其于文言程式之中，乃凭文法之妙，于方寸之间，创宇宙之万物。行此聚会，以文、程二物会友。固为一乐，并望君能于乐中有所获矣。 内容 简单介绍文言编程的转译源代码，以及与 co3mos 项目的融合 了解文言编程的关键字，熟悉文言编程的语法，写出一个“问天地之好在” (Hello, World!) 在 co3mos 平台上用文言文动手实践一个算法/几何绘画题目 在 co3mos 平台上用文言文做出一个游戏 生成作品文言代码书 示例代码 讲师 余琦 FCC 成都社区 - 核心成员 可好玩乐 - Web 开发工程师 协办 紫荆谷众创空间 紫荆谷众创空间（上海）于 2017 年 12 月 29 日在上海宝山区纬地路正式开园落地，该众创空间总面积达 3500 平方米，共有 2 层，集国际联合办公、孵化空间、创业服务、创业投资、创业导师培训工作室，打造创业环境一流、创业氛围和谐的新一代国际孵化器和加速器。不仅如此，紫荆谷众创空间细节之处还体现了国际化的要素，概念设计单位 Lifestyle Creating 是拥有国际视野的顶尖设计公司，成功开发并打造了新天地及诸多新概念商业地产项目。同时紫荆谷众创空间运营团队也都拥有丰富的国际化运作模式的专业背景。未来运营团队将结合技术资源、专业导师指导、全球市场接入、产业化落地、投融资服务等领域，为全世界的创业项目提供专项的垂直加速运作，帮助创业者突破发展瓶颈，将“紫荆谷”打造成为国家科技创新的“东方硅谷”，将“紫荆谷+”打造成为传统产业创新的高端平台。 参考 https://www.raychase.net/758","link":"/activity/workshop/wenyan-programming/"},{"title":"【工作坊】Web 自动化测试","text":"2022 新年钟声的敲响有没有让开发小哥哥、测试小姐姐们心头一紧？马上过年了，2021 年的项目还一堆功能和 bug 没搞完，真令人头秃…… 小编干了小十年开发，每到项目交付前，再美的测试小姐姐我每天也不想见到她。因为大多数团队每次为了赶进度，在一期工程基本一屁股技术债 —— 单元测试是不可能写的，这辈子都不会写单元测试；集成测试更不要想，只能靠测试小姐姐点点点这样维持一点质量…… 而且俗话说得好： 码农三大懒 —— 变量命名、注释/文档、测试代码 辣这年前上线啷个弄嘛？ …… 也不是不可以抢救一下~ 知识精讲WebDOM 模拟库 JSDOM：稳健老前辈 HappyDOM：轻快新后生 浏览器操作库 Selenium 开天辟地：ThoughtWorks Puppeteer 改天换地：Google Playwright 另起炉灶：Microsoft 录制器（偷懒神器）测试小姐姐一边点点点，测试代码自动录制出来，*代码小白的黑盒测试专员立马转职会玩代码的白盒测试工程师*，过年回家又可以吊打亲戚家孩子了~😜 运行器/套件 Jest：使用广泛 Codecept：封装全面（偷懒神器） 中国技术宅小时候不少都玩过易语言中文编程，那用各国语言写测试代码你玩过吗？这又是一个测试小姐姐不可错过的升职加薪、吊打凤凰男/普信男的绝佳机会~ Feature(\"CodeceptJS 演示\"); Scenario(\"成功提交表单\", ({ 我 }) =&gt; { 我.在页面(\"/documentation\"); 我.填写字段(\"电邮\", \"hello@world.com\"); 我.填写字段(\"密码\", \"123456\"); 我.勾选选项(\"激活\"); 我.勾选选项(\"男\"); 我.单击(\"创建用户\"); 我.看到(\"用户名可用\"); 我.在当前网址中看不到(\"/documentation\"); }); 小程序微信开发者工具内置操作脚本录制器，也开发了类似浏览器操作库的 API，结合 Web 前端已有的测试框架，小程序这么中国特色的玩意儿也能做自动化测试啦~ 后端 APIJSON：智能测试框架 腾讯工程师基于机器学习开发的自动化 API、UI 测试框架 开源中国 GVP 获奖项目 Apifox = Postman + Swagger + Mock + JMeter 国内 API as a Service 创业厂商 两种自动化测试模型测试金字塔测试冠军杯动手实践课前预习，课上带电脑！ 实操案例：Next.js + Jest —— 来自脚手架 @idea2app/Next-Bootstrap-ts 安装npm i -D jest playwright jest-playwright-preset \\ @jest/types ts-node @types/jest ts-jest npx playwright install tsconfig.json{ \"compilerOptions\": { \"types\": [\"@types/jest\", \"jest-playwright-preset\"] } } jest.config.tsimport type { value Config } from \"@jest/types\"; const config: Config.InitialOptions = { preset: \"jest-playwright-preset\", transform: { \"^.+\\\\.ts$\": \"ts-jest\" }, testTimeout: 60000 // 根据后端网速调节 }; export default config; jest-playwright.config.jsmodule.exports = { browsers: [\"chromium\", \"firefox\", \"webkit\"], launchOptions: { headless: false // 仅本机测试 }, serverOptions: { command: \"npm run dev\", port: 3000, debug: true // 仅本机测试 } }; .vscode/launch.json{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Debug Jest\", \"type\": \"node\", \"request\": \"launch\", \"port\": 9229, \"runtimeArgs\": [ \"--inspect-brk\", \"${workspaceRoot}/node_modules/jest/bin/jest.js\", \"--runInBand\" ] } ] } test/home.spec.tsdescribe(\"Home page\", () =&gt; { beforeAll(() =&gt; page.goto(\"http://localhost:3000\", { timeout: 60000 // 根据后端网速调节 }) ); it(\"should load Main framework\", async () =&gt; { expect(await page.title()).toBe(\"Home page\"); }); }); export {}; 活动概况 受众： Web 前后端工程师 测试专员、工程师 项目经理 费用：￥ 0.00","link":"/activity/workshop/web-testing-automation/"},{"title":"fCC开源技术分享活动·AI主题分享·脚手架现场实操","text":"我们不给活动设定预期，比如规模要多大或者邀请多少人加入，我们希望通过真诚且有温度的表达，为自己、也为更多人营造一个轻松愉快的编程氛围，通过实战演练提升各自的编程技能、结对编程提升团队协作能力，让我们共同进步，抵达各自的彼岸。","link":"/activity/workshop/ai-deno-scaffold/"},{"title":"CodingDojo 编程道场 #1","text":"本期编程道场，FCC 成都联合 Le Wagon 一起在 wework 为大家呈现。提供良好的环境和有趣的知识，最关键是，有最棒的小伙伴们，还在等什么，快来加入我们。 2019/1/20 13:30 ~ 17:30 WeWork：199 东大街，睿东中心 B 座 40F 基本流程针对预先准备的趣味问题，分组探讨解决方案，动手检验，上台展示小组结果。 你的收获 收获志同道合的小伙伴，锻炼你的思维、动手能力和表达能力。 了解并使用 TDD、结对编程的敏捷实践来实现方案。 什么人可以参与编程道场？ 对 TDD，结对编程等敏捷方式有兴趣的小伙伴； 愿意尝试，希望和人交流获取更多灵感的有想法的小伙伴； 想要不断学习提升的小伙伴； 参与编程道场需要什么？活动免费，自带电脑，和你的激情！ 参与编程道场需要有编程基础么？本期编程道场对小白友好，欢迎任何对 coding 感兴趣的小白们参与。 活动流程 时刻 内容 13:35 自我介绍 13:45 主持人介绍编程道场 14:00 编程道场实践与分享环节 17:30 自由交流、反馈、合影","link":"/activity/workshop/coding-dojo-1/"},{"title":"fCC 成都社区 Coffee & Code 周末编程自习室 2025年11月16日","text":"周末不想卷，但手又痒？来【开源市集】周末编程自习室写点真代码。11月16日 14:00 漫咖啡·红唐店，面向 Web 前端、全栈、AI 开发者：React 19 升级坑点复盘、GitHub Actions 多分支部署流水线、社区官网性能优化、理财 PWA 现写现跑。带上电脑与在研 repo，结对调试、代码评审、现场提 PR；遇到卡点有导师当面支援，线上也可远程加入。不讲空话不放 PPT，只有 commit、issue 和结果。不限语言与工具，欢迎新人与老手同桌切磋。少点焦虑，多点提交；咖啡在线，Bug 离线。免费参与，名额有限，先到先写。 活动信息 时间：2025-11-16 14:00~18:00 地点：漫咖啡MAAN COFFEE(红唐店)，四川省成都市武侯区天府大道中段中1388号红唐购物中心1层LA104 人群：编程初学者、开源爱好者、公益志愿者、AI 从业者 费用：参会免费、餐饮自费 文档：https://open-source-bazaar.feishu.cn/wiki/Mi5pwfoE6ijJEokVRLkccOvJnRc 直播：https://vc.feishu.cn/j/288361973 群聊：https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=0dcqe9e3-5f27-4d5d-a30c-0477b64c828b 开源分享 💡灵感代码 —— 阿富汗首个女子编程学校 @水歌 🤝开源市集·编程自习室 x 疯狂星期四（成都站）@水歌 @彭雪梅 框架研讨：智能纪要：编程学习及开源社区建设研讨 2025年11月6日 活动立牌制作 @yiwei @廖彬彬 🛠️JavaScript 中文兴趣组官网 ✅合并前端部署的多分支 GitHub actions，并升级上游库，更新公共 CDN @水歌 🛠️fCC 成都社区官网（试验版） ✅升级至 React 19、React Chrono 3、PNPM 10、LESS 4 等上游库 @水歌 🚧fCC 中文社区官网 ✅新增课程列表页 @水歌 @🤖copilot ✅新增用户详情页 @水歌 @🤖copilot 动手训练 周末编程自习室 Workshop 是一个开放式学习空间，适合想提升编程技能的同学自由学习与交流。我们将提供学习指导与项目实践分享，帮助大家巩固知识、解决疑难。 请自备笔记本电脑，并确保网络连接畅通。 🚧理财入门 PWA @水歌 @dethan3 现场一起用 AI 开发一个单页理财应用","link":"/activity/workshop/fcc-chengdu-coffee-and-code-2025-11-16/"},{"title":"fCC Coffee & Code 周末编程自习室 2025-07-13","text":"fCC 成都社区上次以 Coffee &amp; Code 命名的活动还是 2019 年 3 月 30 日的《走进函数式编程》活动，近 6 年半后，我水歌这个 6 年半三度接任 fCC 成都社区主理人的开源老将，在大家对“轻松的日常小活动”的期待中，重启这个 freeCodeCamp.org 最早、最经典的活动品牌。 同时，我将组织者闯闯提出的【周末编程自习室】作为它的中文名，再通过飞书视频会议的方式兼容线上线下的参与者，让所有学习编程、从事编程的人都能感受到编程的快乐！ 📍 参会信息 时间：2025年7月13日（周日）14:00 - 18:00 地点：成都市高新区天府五街红唐商城一层星巴克咖啡 直播：https://vc.feishu.cn/j/704264950 人群：编程初学者、爱好者、从业者 文档：https://open-source-bazaar.feishu.cn/wiki/TTPvwJhpni1OGqknc7CcxWvTnCd 费用：活动免费、饮品自费 装备：自备笔记本/平板电脑 📚 主要内容 fCC 成都社区【黑客松开放平台 2.0】重启官宣 【开源市集】行动落地进展分享 社区自有项目阶段路演 黑客松开放平台 HOP 开源市集官网 fCC 成都社区官网（2025 版） fCC 成都社区图书馆 - Open Library 自由结对编程 📋 协作文档","link":"/activity/workshop/fcc-coffee-and-code-2025-07-13/"},{"title":"Git 入门及 GitHub Pages 个人主页开发","text":"主要流程 Git 及其常见在线平台介绍、常用功能入门 个人主页开发（非预编译型，托管于 GitHub Pages） FCC 题目答疑、自由交流 重庆前端大会入场券团购动员","link":"/activity/workshop/my-github-pages/"},{"title":"编程道场之结对活动","text":"什么是 Coding Dojo？Coding Dojo 是一个集体学习活动。一些程序员（通常是 15-20 人）在一起编程解决一个程序问题。一边编程，一边互相学习。每个人可以从 Coding Dojo 中学到：解决问题的思路、编程技巧、面向对象设计、演进式设计、结对编程、测试驱动开发、持续集成等等。 流水帐开场由于是到新场地第一次搞活动，负责组织的小伙伴们都提前到了做准备。参加活动的小伙伴们大部分准时到场了，稍微比计划时间晚一点之后，2 点左右主持人 Too 宣布了活动的开始。 先是惯例由 FCC 成都总舵主姜姜姜同学简单介绍社区的情况，然后是每个人的自我介绍，大家建立第一印象。 结对编程活动介绍Too 用了半个小时左右对本次活动内容和安排进行说明，由于考虑到这次到场的小伙伴对敏捷开发和结对编程都比较陌生，所以尝试说得比较详细，对相关术语也尽量解释清楚。为了方便大家建立更直观的印象，Too 和书香一起现场用 cyber-dojo.org 网站进行了演示，使用了比较简单易懂的 Word Wrap 题目。在疑似结对争吵中，两个人演示了结对编程基本的样子；如何做最简单的测试驱动开发；互相交换角色等。这部分时间没控制好超出了计划。 第一个结对环节，采用题目 FizzBuzz随机两两组合结对之后，大家就热火朝天的开始了结对尝试。Too 在现场对各组的观察和询问了解中发现了一些情况： 在介绍演示过程中，忽略了对“红-绿-重构”这一基本动作的强调，部分小伙伴没有完全按照这个来进行练习 对 TDD（测试驱动开发）这种模式的陌生，导致部分小伙伴对第一个测试测什么产生困惑，而有的小伙伴测试和实现代码一起写完才运行测试，这些都影响了对 TDD 好处的感受。 cyber-dojo 的结对编程环境在使用 JS 的严格语法检测下，会有不少报警，不少小伙伴都不太习惯。由于前两个问题都是直接对活动的目的有较大影响，因为主持人不得不多次打断正在互相讨论或编码的大家，进行提醒。 4 点左右，看着大家还是做得不亦乐乎，有点不忍打住。但是本次结对活动的目的是让大家感受和实践结对的技巧，避免在题目上耗费太多时间，所以还是强制大家停下来休息 5 分钟，然后回来一起看看进行的情况。在回顾的过程中，主持人随机挑选了几组结对的小伙伴的代码，按本次结对编程活动的目的进行了说明和评论，指出哪些地方是符合了设想的要求的，哪些是有所欠缺。（所有人一起查看，尽量保持了评论的代码是匿名性） 第二个结对环节，采用题目 Anagrams应该说 FizzBuzz 题目还是比较简单的，重新组对之后，建议了大家尝试更难一点的题目，但是介绍环节和第一个环节的时间已经超出计划比较多了，留给这个环节的时间较少，所以整体来说，这个环节进行的不太顺利，简单抽取了几对小伙伴的代码进行一起回顾之后，就有点匆忙的结束了。 主要的一个问题是，随着题目难度的增加，应该测试什么，和如何拆分任务来达到小步迈进上，普遍缺乏 TDD 经验的小伙伴们大部分被卡住了。 结束还是惯例，收集大家的反馈，然后一起合照之后，大概 6 点左右，结束了今天的活动。看到现场还有结对的小伙伴留下来继续讨论，感觉能激起他们的兴趣，心里挺高兴的。活动后得到的初步反馈是破冰环节不足，导致大家进入状态慢；时间控制没做好，超出计划太多；活动前期说明和准备不足，影响大家在现场的了解和实践。都是对我们活动改进的宝贵意见，其他还有的话还请大家及时反馈，对我们很重要。 参考资料和扩展链接 使用 Python 从头到尾的以 TDD 方式开发一个项目可以阅读Python Web 开发：测试驱动方法 (豆瓣) / Praise for Test-Driven Development with Python 要学习 SOLID 设计原则, 可以阅读”Agile Software Development, Principles, Patterns, and Practices”, 或 “Agile Principles, Patterns, and Practices in C#”. 要学习如何能为其他程序员提供编写整洁代码的反馈，可以阅读 Robert C. Martin 所著 “Clean Code” 要学习如果能够识别代码腐臭来做重构，可以阅读 Martin Fowler 所著 “Refactoring” 要学习如何将难以测试的遗留代码改造为便于测试的情形来编写测试，可以阅读 Michael Feathers 所著 “Working Effectively with Legacy Code” 结对编程的正确姿势，你会了吗？ – ThoughtWorks 洞见 重新思考 Code Retreat - Seaborn Lee - ThoughtWorks 咨询师 如何爱上结对编程 » Topics » 中国软件匠艺小组 告诉你什么叫结对编程！ Atlassian 愚人节视频—在线播放—优酷网，视频高清在线观看","link":"/activity/workshop/pair-programming-demo/"},{"title":"【青铜三人行】外篇之循环与递归","text":"不知不觉青铜三人行已经做了两个月的题了，这次轻松点，看看不一样的吧。 机器擅长的事 —— 重复作为专业的程序猿，经常被行业外的朋友问到，为什么要学习编程？其实，除了掌握技能提高工作效率、甚至成为职业以外。学习编程更重要的是：思维训练。 其实，计算机从一开始就是为了帮助人们解决复杂问题而设计出来的。而在这个过程中，计算机程序的「思考」模型是一个叫“图灵机”的计算模型，图灵机是图灵 (Alan Mathison Turing) 祖师爷模拟人思考而发明出来的。为什么图灵祖师爷要发明图灵机呢？是因为他想要试图以自己和自己周围的天才科学家的思维方式作为人类的具体实例，来抽象总结出一套解决问题的办法。所以说，计算机程序的运作方式其实是一种人类尝试用简单的方式逐步去解决复杂问题的天才的思考方式。 在如今的时代，计算机早已经充斥在我们生活的方方面面，想要更好地进行人机交互，或多或少地我们都需要一些「像机器一样」的思考方式。即使是作为专业程序员，不断培养自己像机器一样思考的思维模式也是必不可少的。 既然要像机器一样去思考，那么不妨从计算机最擅长的事情 —— 重复，开始说起吧。下面是来自 TED-Ed 中「Think like coder」系列课程的第一节，讲的就是计算机的重复 —— 循环。 各种编程语言的循环来看看在实际编程中，不同编程语言的循环写法有什么不同吧！ for 循环Cint jj; for (jj = 0; jj &lt; 10; jj++) printf(\"%d, \", jj); // =&gt; prints \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \" printf(\"\\n\"); Java// for loop structure =&gt; for(&lt;start_statement&gt;; &lt;conditional&gt;; &lt;step&gt;) for (int fooFor = 0; fooFor &lt; 10; fooFor++) System.out.println(fooFor); // Iterated 10 times, fooFor 0-&gt;9 System.out.println(\"fooFor Value: \" + fooFor); JavaScriptfor (var i = 0; i &lt; 5; i++) { // will run 5 times } Pythonfor i in range(4): print(i) animals = [\"dog\", \"cat\", \"mouse\"] for i, value in enumerate(animals): print(i, value) Rust // Ranges for i in 0u32..10 { print!(\"{} \", i); } println!(\"\"); // prints `0 1 2 3 4 5 6 7 8 9 ` Gofor x := 0; x &lt; 3; x++ { // ++ is a statement. fmt.Println(\"iteration\", x) } for key, value := range map[string]int{\"one\": 1, \"two\": 2, \"three\": 3} { // for each pair in the map, print key and value fmt.Printf(\"key=%s, value=%d\\n\", key, value) } while 循环Cint ii = 0; while (ii &lt; 10) //ANY value less than ten is true. printf(\"%d, \", ii++); // ii++ increments ii AFTER using its current value. // =&gt; prints \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \" printf(\"\\n\"); Javaint fooWhile = 0; while(fooWhile &lt; 100) { System.out.println(fooWhile); // Increment the counter // Iterated 100 times, fooWhile 0,1,2...99 fooWhile++; } System.out.println(\"fooWhile Value: \" + fooWhile); JavaScript// As does `while`. while (true) { // An infinite loop! } Pythonx = 0 while x &lt; 4: print(x) x += 1 # Shorthand for x = x + 1 Rust while 1 == 1 { println!(\"The universe is operating normally.\"); // break statement gets out of the while loop. // It avoids useless iterations. break } Go// Go 语言里面只有 for 循环，但是 for 循环可以不加范围 for { // Infinite loop. break // Just kidding. continue // Unreached. } 循环的本质事实上，不管循环本身的写法和描述有什么改变，它的本质都是一种逻辑判断。也就是说，它们从根本上都是 until 循环的类型： 当某条件满足的时候跳转到循环结束的地方，不然就跳转回循环开始的地方 而基本所有的循环最后大概都会被编译成以下的样子，这叫做汇编语言，它是最接近计算机的思考方式的编程语言了。 mov eax, val1 ; 把变量 val1 放到 EAX 里面 beginwhile: cmp eax, val2 ; 比较 val1 和 val2 jnl endwhile ; 如果 val1 不小于 val2，就跳到 endwhile 的地方 inc eax ; val1++; dec val2 ; val2--; jmp beginwhile ; 跳回到 beginwhile 的地方 endwhile: mov val1, eax ;保存 val1 的新值 递归循环有一对「孪生兄弟」叫做递归。它们的作用都在于解决「重复」的事情。所不同的在于它们对于「重复」的部分的抽象描述不同 如果把要重复执行的指令放在一个「块」里面，称为循环体，并通过外部变量来调整每次循环执行的数据，就叫做循环。 如果把要重复执行的指令抽象成「函数」，并通过传参数的形式来调整每次执行的数据，就称作递归啦！ 关于递归的详情可以看看来自 Helen 的视频讲解： 后面好啦，这次并没有做题，要讲的内容就这么多啦。有时候换换心情和视野也是很重要的，希望这次的内容可以当做故事看看，了解一些更多的事情。下次见啦！","link":"/article/algorithm/loop-and-recursion/"},{"title":"【青铜三人行】二叉树中的最大路径和","text":"每周一题，代码无敌~ 这一次，青铜三人行决定在五一假期期间挑战一道难度为「困难」的题目： 二叉树中的最大路径和力扣 ​leetcode-cn.com 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1输入：[1, 2, 3] 1 / \\ 2 3 输出：6 示例 2输入：[-10, 9, 20, null, null, 15, 7] -10 / \\ 9 20 / \\ 15 7 输出: 42 解题思路因为这次题目相对来说比较困难，因此就以一种思路来说明。 这道题的难点在于，题目中要求取的“任意节点出发”的路径，且不一定经过根节点。导致在如何迭代求取上，陷入了一个比较复杂的境地。 为了求解这个问题，我们需要将题目先简化一下，分步骤完成： 求取某一节点为起始的最大路径和function maxChildrenPathValue(node) { if (node == null) return 0; const leftPathVal = maxChildrenPathValue(node.left), rightPathVal = maxChildrenPathValue(node.right); const maxPathValue = Math.max(leftPathVal, rightPathVal) + node.val; return Math.max(maxPathValue, 0); } 在这一步中，我们递归求取了某一个节点为开始的单边最大路径和，值得注意的是，如果取出来的值是负值，则设为 0，意为「舍弃」掉这条路径。 求取经过某一根节点的最大路径和完成了上一步，我们就可以求取经过某一特定根节点的最大路径和了，即把「某个节点的值」与「左边最大路径和」和「右边最大路径和」相加： function getRootMaxPathVal(root) { const leftMaxPathVal = maxChildrenPathValue(root.left), rightMaxPathVal = maxChildrenPathValue(root.right); return leftMaxPathVal + rightMaxPathVal + root.val; } 遍历求取整颗二叉树的最大路径值有了上面的基础，我们就可以遍历整个二叉树，来求取所有节点的最大路径和，并取出其中的最大值来作为整颗二叉树的最大路径和了，在这里我们用了二叉树前序遍历，并使用了一个全局变量 result 来记录最大值： function preorderTraversal(root) { if (!root) return; const value = getRootMaxPathVal(root); if (value &gt; result) result = value; preorderTraversal(root.left), preorderTraversal(root.right); } 到此我们就可以解出这道题目了，完整代码如下： /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number} */ function maxPathSum(root) { let result = -Infinity; function maxChildrenPathValue(node) { if (node == null) return 0; const leftPathVal = maxChildrenPathValue(node.left), rightPathVal = maxChildrenPathValue(node.right); const maxPathValue = Math.max(leftPathVal, rightPathVal) + node.val; return Math.max(maxPathValue, 0); } function getRootMaxPathVal(root) { const leftMaxPathVal = maxChildrenPathValue(root.left), rightMaxPathVal = maxChildrenPathValue(root.right); return leftMaxPathVal + rightMaxPathVal + root.val; } function preorderTraversal(root) { if (!root) return; const value = getRootMaxPathVal(root); if (value &gt; result) result = value; preorderTraversal(root.left), preorderTraversal(root.right); } preorderTraversal(root); return result; } 优化同样的解题思路下，Helen 发现到在求取某一节点为起始的最大路径和这一步的时候，已经在对二叉树进行遍历了，那能不能直接在一次递归遍历中解出题目呢？Helen 对代码进行了优化： function maxPathSum(root) { let max_sum = -Infinity; function max_gain(root) { if (root === null) return 0; const left_gain = Math.max(max_gain(root.left), 0), right_gain = Math.max(max_gain(root.right), 0); const newPath = root.val + left_gain + right_gain; max_sum = Math.max(newPath, max_sum); return root.val + Math.max(left_gain, right_gain); } max_gain(root); return max_sum; } 代码简洁多了，运行也更快了！你有没有发现两个解法的共同之处和不同之处呢？ Extra最后依然是曾大师的 Go 语言 show time~ func maxPathSum(root *TreeNode) int { var val = INT_MIN(); subMaxPathSum(root, &amp;val); return val; } func subMaxPathSum(root *TreeNode,val *int) int{ if (root == nil) return 0; left := subMaxPathSum(root.Left, val); right := subMaxPathSum(root.Right, val); threeSub := root.Val + max(0, left) + max(0, right); twoSub := root.Val + max(0, max(left, right)); *val = max(*val, max(threeSub, twoSub)); return twoSub; } func INT_MIN() int{ const intMax = int(^uint(0) &gt;&gt; 1); return ^intMax } func max(x, y int) int { if x &lt; y return y return x } 结果依然很惊人啊…… 嗯…… 最后这次的题目有些复杂，但通过简化题目、拆解步骤，也可以让困难的题目得到解决。而日常编程的过程中，也是在将复杂问题简单化、步骤化的一个过程。最后留个小问题，之前提到过，所有的递归都可以用循环来解决，那么在第一步的递归中，如果用循环解决该怎么做呢？下周见~","link":"/article/algorithm/max-path-sum-of-binary-tree/"},{"title":"【青铜三人行】每周一题@两数之和","text":"哈喽，大家好，欢迎来到青铜三人行的每周一题现场。在接下来的时间里，我们三人（Helen、书香、曾大师）会在每周选择一道编程算法题来完成，和大家一起探讨一下解题的思路。所谓每周一题，代码无敌，欢迎各位小伙伴们一起进入我们的刷题之旅~ 因为个人水平有限，我们的解法不一定是最优的，只是希望抛转引用，分享自己的思路，带动和大家一起练习编程技能。大家有任何建议，也可以通过 bronze_3@163.com 邮箱联系我们~ 话不多说，就进入我们这周的题目吧，它出自 LeetCode 的第一题： 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解法一拿到题目，Helen 心想，这次题目难度不大。略一思忖，要在数组中找到满足某个条件的两个数，一个双重循环搞定即可： function twoSum(num, target) { for (const index in num) { for (const _index in num) { if (index !== _index &amp;&amp; num[index] + num[_index] === target) { return [index, _index]; } } } } ​ //作者：Helen //链接：https://leetcode-cn.com/circle/discuss/5cC2dU/view/p3MA3g/ //来源：力扣（LeetCode） //著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 顺利通过题目！但是效率似乎并不理想…… 解法二接下来就要优化算法，Helen 审视代码，发觉影响效率的主要原因恐怕是在于双重循环所造成的 O(n²) 复杂度。要想提高效率，恐怕就要在一重循环里搞定题目。但如何在一次迭代中找到两个数的关系呢？确实颇费考虑…… 算法领域中，空间与时间通常如同鱼和熊掌一般不可兼得。空间换时间…… Helen 灵光一现，对了，一次迭代中表现两个数的关系，可以在 map 结构中用查找 key 的方式呀。考虑至此，信手写出了第二版代码： function twoSum(nums, target) { const numsMap = {}; for (const index in nums) { numsMap[nums[index]] = index; } for (const index in nums) { const complement = target - nums[index]; if (numsMap[complement] &amp;&amp; numsMap[complement] !== index) { return [index, numsMap[complement]]; } } } ​ //作者：Helen //链接：https://leetcode-cn.com/circle/discuss/5cC2dU/view/p3MA3g/ //来源：力扣（LeetCode） //著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 如此一来，时间复杂度减为 O(n)， 速度果然大大提高： 书香作为一个函数式编程的拥护者，平日里对 map、 filter、 reduce 等方法都记在心里。看到这个代码，心想恐怕在循环中对数组的频繁引用是一个可以优化的点，于是利用 JavaScript 中内置的 reduce 方法稍作修改： const twoSum = function(nums, target) { const objNums = nums.reduce((acc, num,index) =&gt; { acc[num]=index; return acc},{}); ​ for (let i=0; i&lt;nums.length;i++) { const num = nums[i]; const other = objNums[target-num]; if(other!==undefined &amp;&amp; other!==i){ return [i,other] } } return; }; ​ //作者：demongodYY //链接：https://leetcode-cn.com/circle/discuss/5cC2dU/view/8eOrHo/ //来源：力扣（LeetCode） //著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 时间和空间上居然都有所提高，看来 JavaScript 对内置方法的优化果然到位： 解法三于此同时，Helen 则进一步对代码进行了优化。题目要求只需要找到满足条件的两个数，那么有可能在没有遍历完的时候就能找到呀。如此一来，就不必提前将整个数组转换成 map 结构，而是边转换边查找，在找到满足条件的时候即可返回： function twoSum(nums, target) { const numsMap = {}; for (const index in nums) { const complement = target - nums[index]; if (numsMap[complement]) { return [ index, numsMap[complement]]; } numsMap[nums[index]] = index; } } ​ //作者：Helen //链接：https://leetcode-cn.com/circle/discuss/5cC2dU/view/p3MA3g/ //来源：力扣（LeetCode） //著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 如此一来，代码性能大大地得到了优化： extra最后，由曾大师为我们在 Go 语言中展现了一把对内存的极致管理，也体现了对于不同编程语言特性的优化差别： func twoSum(nums []int, target int) []int { for i := 0; i &lt; len(nums); i++ { for j := i+1; j &lt; len(nums); j++ { if nums[i]+nums[j] == target { return []int{i,j} } } } return []int{} } ​ //作者：glowd //链接：https://leetcode-cn.com/circle/discuss/5cC2dU/view/omqRef/ //来源：力扣（LeetCode） //著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 天啊，内存消耗仅为 2.9MB，在所有 Go 提交中击败了 100% 的用户！😲😲😲 结尾OK，这就是咱们青铜三人行的第一次分享的全部内容啦，虽然很多地方还不完善，但也希望凭借一点微薄的力量，提起大家对编程算法题的兴趣。 如果看到了这次分享，你有一些灵感的话，请立即拿起手中的键盘，打开 LeetCode 的网站找到题目先刷一遍，并与我们或者身边的小伙伴们分享你的思路~ 如果有任何的建议和意见的话，也欢迎大家随时联系我们，我们的联系邮箱是 bronze_3@163.com。 下周见！","link":"/article/algorithm/two-number-sum-algorithm/"},{"title":"【青铜三人行】每周一题@组合总和","text":"每周一题，代码无敌~ 这次让我们回到算法本身，来探讨一下回溯算法： 组合总和力扣 ​leetcode-cn.com 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ] 示例 2输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ] 思路对于这道题来说，最困难的点就在于「candidates 中的数字可以无限制重复被选取」, 这个条件导致了最后结果的集合里面可以选的元素的数量不一定，直接导致了满足条件的可能性组合的数量暴增，给程序的复杂性带来了一定的挑战。 面对这种情况，我们就不得不尝试组合出各种能容纳最多元素的组合。在学习算法的过程中，可以理解到，类似面临这种 「查找最远路径」的问题，最适合的算法场景就是 「深度优先」搜索算法。 回到这个题目当中，我们想要找出所有满足条件的组合，就是要 「从长到短」、「从小到大」尝试所有相加不超过 target 的组合。而在如果遇到组合超过 target 的情况，则回到更 「短」一点的组合尝试其他可能性： 以这道题目的 示例 2 为例： 如图所示，我们从左往右，每次尝试去取到最多元素的可能性，当组合的和大于或等于 target 的时候（等于的时候要记录结果），就返回上一层，尝试新的组合（新的组合的数要比之前的大）。相当于在这里 「剪掉」了后面的可能性，并 「返回」了上一层去尝试。因此这种算法也被称为了 「回溯剪枝算法」。提一下，「回溯剪枝算法」其实就是一种 「深度优先查找」(DFS) 算法。 注意：对于这个题来说，这个算法必须在有序数组中才可以才行，因为数值越大，深度就越有限。 解法了解了思路，我们先来看看 Helen 的解法 /** * @param {number[]} candidates * @param {number} target * @return {number[][]} */ function combinationSum(candidates, target) { const result = []; let tmpPath = [], start = 0; candidates = candidates.sort((a, b) =&gt; a - b); function backtrack(tmpPath, target, start) { if (target === 0) { result.push(tmpPath); return; } for (let index = start; index &lt; candidates.length; index++) { if (target &lt; 0) break; tmpPath.push(candidates[index]); backtrack(tmpPath.slice(), target - candidates[index], index); tmpPath.pop(); //回溯 } } backtrack(tmpPath, target, start); return result; } 在这里，Helen 定义了一个 backtrack 的回溯函数，在其中遍历了 candidates 数组，并在其中递归地又去回溯，从而找出所有的可能性。 注意其中 target &lt; 0 这个条件，其实就是一个“剪枝”，把超出的可能性剪掉。只不过用了减法的形式，有点反直觉，可以多琢磨下。 而书香稍微改了下结构，把代码缩短了点： function combinationSum(candidates, target) { const sliceArr = candidates .filter(item =&gt; item &lt;= target) .sort((a, b) =&gt; a - b), finalArr = []; function findCompose(target, offset, last) { for (let i = offset; i &lt; sliceArr.length; i++) { const subTarget = target - sliceArr[i]; if (subTarget == 0) finalArr.push([...last, sliceArr[i]]); if (subTarget &gt; 0) findCompose(subTarget, i, [...last, sliceArr[i]]); } } findCompose(target, 0, []); return finalArr; } 其实差不太多，不过是因为用了 ES 6 数组的解构赋值方法，没有把每个分支都 push 进去，所以回溯的时候就可以少写一个 pop 啦~ 曾大师 Go 语言时间他在注释里顺便给我们解释了 「示例 1」，并且直接将函数命名成了 DFS（深度优先搜索）。果然很有算法大师的风范呀！ // 深度搜索加减枝,具体过程如下 // 2 -&gt; 22 -&gt; 222 -&gt; 2222 -&gt; 223(合适) -&gt; 23 -&gt; 233 -&gt; 26 -&gt; 3 -&gt; 33 -&gt; 333 -&gt; 36 -&gt; 6 -&gt; 66 -&gt;7(合适) var result [][]int var currCandidate []int func combinationSum(candidates []int, target int) [][]int { sort.Ints(candidates) result=make([][]int,0) currCandidate=make([]int,0) DFS(target,candidates) return result } func DFS(target int,candidates []int) int { if getSum(currCandidate) == target { temCandidate := make([]int, len(currCandidate)) copy(temCandidate, currCandidate) result = append(result, temCandidate) return 0 } else if getSum(currCandidate) &gt; target { return -1 } else { //主要看这里用0代表相同，-1代表已经超过了当前target，1则表示还能继续加 for i := 0; i &lt; len(candidates); i++ { currCandidate = append(currCandidate, candidates[i]) temp := DFS(target, candidates[i:]) currCandidate = currCandidate[:len(currCandidate) - 1] if temp &lt;= 0 { break } } } return 1 } func getSum(nums []int) int { sum := 0 for i := 0; i &lt; len(nums); i++ { sum += nums[i] } return sum } 结语OK，这样看下来，其实算法离我们也没有那么远。事实上如此，算法本身也是为了解决具体的问题而诞生的。而我们在练习的过程中，要理解到算法具体解决了什么问题，就可以在遇到类似的问题的时候迎刃而解啦~ 下周见~","link":"/article/algorithm/combined-sum/"},{"title":"【青铜三人行】每周一题@三数之和","text":"哈喽~ 每周一题，代码无敌。欢迎各位继续观看「青铜三人行」的刷题现场。 话不多说，我们进入这周的题目吧： 三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a、b、c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如 // 给定数组 const nums = [-1, 0, 1, 2, -1, -4]; 最初的解法Helen 拿到题目，心想这道题岂不是如同上周的“两数之和”一般？无非就是多加了一个数而已。按照思路，首先暴力举出所有满足条件的三个数，再去重即可，写出了如下代码： function threeSum(nums) { const results = []; for (i = 0; i &lt; nums.length; i++) for (j = i + 1; j &lt; nums.length; j++) for (k = j + 1; k &lt; nums.length; k++) if (nums[i] + nums[j] + nums[k] === 0) { // 转换成字符串方便去重 const strResult = [nums[i], nums[j], nums[k]] .sort((a, b) =&gt; a - b) .join(\",\"); results.push(strResult); } return Array.from(new Set(results)).map(str =&gt; str.split(\",\")); } 拿入测试用例执行，结果正确 😎： 于是提交，结果被现实狠狠打脸……😱： 排序解法纳尼？这道题居然有时间限制…… 太阴险了吧……😵 看样子传统的暴力破解法，在三重循环之下，时间复杂度到达了 O(n³)，时间消耗应该是远远超过了题设。 看样子想解出这道题，至少要“消灭”掉其中的一重循环。Helen 找来书香一起讨论，两人细细品味题目，发现题目要求：a + b + c == 0 ，那说明这三个在数组中的数，除开三个数都为 0 的情况，必然有正有负，有大有小。 换言之，如果给定一个“最小”的数，我们只需要在比这个数“大”的剩余数组里找出”其他”两个数，看看它们加起来的结果。如果等于 0，则加入结果，如果大于 0，则设法调整“其他两数”，使其和变小。若小于 0，则设法使“其他两数”之和变大。 而在有序数组中，调整两数相加之和的大小是只需要一次循环就可以做到的，如此一来，我们似乎就可以在 O(n²) 的时间复杂度中就可以完成题设了： function threeSum(nums) { const funcSeq = (a, b) =&gt; a - b; const sortedNums = nums.sort(funcSeq); const length = sortedNums.length; const result = []; for (let i = 0; i &lt; length; i++) { let num = sortedNums[i]; let lIndex = i + 1; let rIndex = length - 1; while (lIndex &lt; rIndex) { let lNum = sortedNums[lIndex]; let rNum = sortedNums[rIndex]; if (lNum + num + rNum === 0) { result.push([lNum, num, rNum].sort(funcSeq).join(\",\")); rIndex -= 1; lIndex += 1; } else if (lNum + num + rNum &lt; 0) lIndex += 1; else if (lNum + num + rNum &gt; 0) rIndex -= 1; } } return Array.from(new Set(result)).map(str =&gt; str.split(\",\")); } 然而在提交时，遇到了一个诡异的测试用例，导致还是超时了 😰： 居然还有这么奇葩的测试用例！大量的 0 构成的数组。还好这并没有难倒 Helen, 既然题设里要求没有重复的三元组，那么加上了一个跳过重复元素的条件就好了： function threeSum(nums) { const funcSeq = (a, b) =&gt; a - b; const sortedNums = nums.sort(funcSeq); const length = sortedNums.length; const result = []; for (let i = 0; i &lt; length; i++) { let num = sortedNums[i]; if (num === sortedNums[i - 1]) continue; let lIndex = i + 1; let rIndex = length - 1; while (lIndex &lt; rIndex) { let lNum = sortedNums[lIndex]; let rNum = sortedNums[rIndex]; if (lNum + num + rNum === 0) { result.push([lNum, num, rNum].sort(funcSeq).join(\",\")); rIndex -= 1; lIndex += 1; } else if (lNum + num + rNum &lt; 0) lIndex += 1; else if (lNum + num + rNum &gt; 0) rIndex -= 1; } } return Array.from(new Set(result)).map(str =&gt; str.split(\",\")); } 提交，代码终于顺利通过啦 😆： 优化看到解题终于通过，大家欢欣鼓舞，也打开了更多的思路。书香发现，既然要相加等于 0，那么除开全为 0的情况，必然结果里有正有负。换言之，第一层循环选取的数字，只需要遍历“非正数”的部分就好，于是加了个条件尝试了一番： function threeSum(nums) { const funcSeq = (a, b) =&gt; a - b; const sortedNums = nums.sort(funcSeq); const length = sortedNums.length; const result = []; for (let i = 0; i &lt; length; i++) { let num = sortedNums[i]; if (num &gt; 0) break; if (num === sortedNums[i - 1]) continue; let lIndex = i + 1; let rIndex = length - 1; while (lIndex &lt; rIndex) { let lNum = sortedNums[lIndex]; let rNum = sortedNums[rIndex]; if (lNum + num + rNum === 0) { result.push([lNum, num, rNum].sort(funcSeq).join(\",\")); rIndex -= 1; lIndex += 1; } else if (lNum + num + rNum &lt; 0) lIndex += 1; else if (lNum + num + rNum &gt; 0) rIndex -= 1; } } return Array.from(new Set(result)).map(str =&gt; str.split(\",\")); } 而 Helen 则从“去重”这一部分上进行了优化，节省了转化成字符串，再用 Set 等数据结构去重带来的额外开销： function threeSum(nums) { const funcSeq = (a, b) =&gt; a - b; const sortedNums = nums.sort(funcSeq); const length = sortedNums.length; const result = []; for (let i = 0; i &lt; length; i++) { let num = sortedNums[i]; if (num &gt; 0) break; if (num === sortedNums[i - 1]) continue; let lIndex = i + 1, rIndex = length - 1; while (lIndex &lt; rIndex) { let lNum = sortedNums[lIndex], rNum = sortedNums[rIndex]; if (lNum + num + rNum === 0) { result.push([lNum, num, rNum]); while (lIndex &lt; rIndex &amp;&amp; sortedNums[lIndex] === sortedNums[lIndex + 1]) lIndex++; while (rIndex &gt; lIndex &amp;&amp; sortedNums[rIndex] === sortedNums[rIndex - 1]) rIndex--; (rIndex -= 1), (lIndex += 1); } else if (lNum + num + rNum &lt; 0) lIndex += 1; else if (lNum + num + rNum &gt; 0) rIndex -= 1; } } return result; } 而优化之后的结果也是相当理想： Extra最后，我们照例贴上曾大师的 Go 语言代码： func threeSum(nums []int) [][]int { result := [][]int{} var keyCountMap map[int]int /*创建集合 */ keyCountMap = make(map[int]int, len(nums)) for i := 0; i &lt; len(nums); i++ { count, ok := keyCountMap [nums[i]] if ok { keyCountMap[nums[i]]=count+1; } else { keyCountMap[nums[i]]=1; } } newNums := make([]int, 0, len(keyCountMap)) for keyi := range keyCountMap { newNums = append(newNums, keyi) if keyCountMap[keyi] &gt; 1 { if keyi == 0 { if (keyCountMap[keyi] &gt; 2) { result = append(result, append([]int{}, 0, 0, 0)) } continue } var remain = 0 - keyi * 2 _, ok := keyCountMap [remain] if ok { result = append(result, append([]int{}, keyi, keyi, remain)) } } } for i := 0; i &lt; len(newNums); i++ { for j := i + 1; j &lt; len(newNums); j++ { var remain = 0 - (newNums[i] + newNums[j]) if remain == newNums[i] || remain == newNums[j] { continue } _, ok := keyCountMap [remain] if ok { var b1 bool = true for k := 0; k &lt; len(result); k++ { if (newNums[i] == result[k][0]) { if (newNums[j] == result[k][1] || remain == result[k][1]) { b1 = false break } } else if newNums[j] == result[k][0] { if(newNums[i] == result[k][1] || remain == result[k][1]){ b1 = false break } } else if remain == result[k][0] { if(newNums[i] == result[k][1] || newNums[j] == result[k][1]){ b1 = false break } } } if b1 { result = append(result, append([]int{}, newNums[i], newNums[j], remain)) } } } } return result; } 在这里，他另辟蹊径，采用了类似上周“两数之和”的题目解法，利用空间换时间，将数组转成 map 形式进行查找。同样通过了题目： 在这里，提个小问题：既然在“三数之和”可以参考“两数之和”的转换成 map 解题的方法，那在“两数之和”中，能不能参考上述“先排序，比较大小查找”的方法呢？ 结尾这周的题目难度上升为了“中等”，随着难度的上升，在解题上也无法完全做到完美。如果你有更好的思路，欢迎通过 bronze_3@163.com 邮箱联系我们~ 下周见！","link":"/article/algorithm/three-number-sum-algorithm/"},{"title":"【青铜三人行】删除链表的倒数第 N 个节点","text":"每周一题，代码无敌。这周，「青铜三人行」为你带来了一道关于“链表的题目”。 删除链表的倒数第 N 个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例 给定一个链表: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, 和 n = 2；当删除了倒数第二个节点后，链表变为 1 -&gt; 2 -&gt; 3 -&gt; 5。 说明给定的 n 保证是有效的。 进阶你能尝试使用一趟扫描实现吗？ 力扣 ​ leetcode-cn.com 啥是链表要完成这道题，首先就得了解一下啥是链表？简单来说，链表是一种数据结构，它由一系列离散的节点组成。其特点是，每个节点上除了自己的数据以外，还会有一个或两个指针指向下一个或者上一个节点，使得这些节点可以链起来。 其中，只有指向下一个节点的链表称为单向链表，它只能从前一个节点到下一个节点一个方向来查找其中的节点数据： 而双向链表则拥有两个指针，分别指向之前和之后的节点： 而在 JS 中，这道题目里给我们设定了链表的结构，很明显，是一个单向列表： function ListNode(val) { this.val = val; this.next = null; } 解法一：两次遍历找到对应的节点了解了链表的数据结构以后，这道题就不难解决了。不过题目里有个小小的花招，即要求寻找「倒数第 n 个节点」。因为是单向链表，我们没法倒着寻找节点，因此我们很容易想到先找到整个链表的长度，计算出要找的元素的正向位置，然后再从头遍历，进行删除： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ function removeNthFromEnd(head, n) { let node = head, length = 0; while (true) { if (node === null) break; node = node.next; length++; } node = head; if (n === length) return head.next; for (let i = 0; i &lt; length - n - 1; i++) node = node.next; node.next = node.next.next; return head; } 解法二：转离散节点为连续节点这道题数据量较小，因此运行的速度都比较快。于是向着题目中「只扫描一次」这个进阶目标前进。书香提出了一种方法，既然题目的难点在于链表不容易反向查找，那么把它映射成一个连续的数据结构不就可以解决了吗？于是很自然想到了应用数组完成了题目： /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} head * @param {number} n * @return {ListNode} */ function removeNthFromEnd(head, n) { let node = head; const arrNodes = []; while (true) { if (node === null) { const length = arrNodes.length; if (length === n) head = head.next; else arrNodes[length - n - 1].next = arrNodes[length - n + 1]; break; } arrNodes.push(node); node = node.next; } return head; } 值得注意的是，当需要删除的元素是第一个元素的时候，容易造成数组的越界，需要特殊处理： if (length === n) head = head.next; 解法三：双指针法上面书香的解法虽然在一次扫描中完成了任务，却额外引入了一个数组的外部结构。有没有更好的办法呢？Helen 和 曾大师对于这个问题，采用了新的办法：题目要求删除倒数第 n 个节点，那么我只需要在我当前扫描到的节点指针之后相隔 n 的节点再设置一个指针，到后一个指针越界的时候，当前节点就是需要删除的节点了： 代码如下： function removeNthFromEnd(head, n) { const dummy = new ListNode(0); dummy.next = head; let l = dummy, r = dummy, offset = n; while (offset--) r = r.next; while (r.next) (l = l.next), (r = r.next); l.next = l.next.next; return dummy.next; } Ertra最后，曾大师 go 语言的福利时间又到啦，同样是双指针，你能看出有什么不同吗？ func removeNthFromEnd(head *ListNode, n int) *ListNode { store := head i := 0 p := head for p != nil { if (i &gt; n) { store = store.Next } p = p.Next i++ } // 删除头节点 if (i == n) { return store.Next } store.Next = store.Next.Next return head } 而在时间和空间上，相当惊人，嗯嗯…… 结尾这周的题目相对来说比较简单，主要是说明了链表的数据结构。链表相对于数组来说，更容易插入、删除其中的节点，而数组比起来则更容易查找到某个节点（想想为什么？）。两个数据结构相辅相成，在不同的应用场景选择合适的数据结构，可以让你的程序运行起来事半功倍哦！ 这次的题目就这样了，欢迎通过 bronze_3@163.com 邮箱联系我们，下周见！","link":"/article/algorithm/remove-nodes-of-linked-lists/"},{"title":"【青铜三人行】每周一题之验证栈序列","text":"先说一个消息，为了方便互相交流学习，青铜三人行建了个微信群，感兴趣的伙伴可以扫码加下面的小助手抱你入群哦！ 青铜三人行小助手（其实是 Helen） 每周一题，代码无敌~ 这次的主题是 「贪心算法」： 验证栈序列给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false。 示例 1输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -&gt; 4, push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 示例 2输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 提示 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed 是 popped 的排列 栈结构要做这道题，首先得了解一下什么是 「栈」。为此书香搬来了维基百科上的解释： 堆栈（英语：stack）又称为栈或堆叠，是计算机科学中的一种抽象数据类型，只允许在有序的线性数据集合的一端（称为堆栈顶端，英语：top）进行加入数据（英语：push）和移除数据（英语：pop）的运算。因而按照后进先出（LIFO, Last In First Out）的原理运作。 栈常与另一种有序的线性数据集合队列相提并论。 栈常用一维数组或链表来实现。 这个定义看起来多，其实也没什么大不了的。栈本身就是一个数组或者链表，只是人为定义它获取数据的方式只能从栈的顶端获取，因此遵循先进后出、后进先出的规则罢了。 想象栈就是一摞盘子，你只能在最上面放盘子或者拿走盘子。对应起来，栈的操作就有两个： push 操作，往栈顶放入一个数据。 pop 操作，从栈顶取走一个数据。 解题思路回到这道题目，一开始看起来题目有点绕，让人不知道要做什么。后来 Helen 提议，既然题目要求是考虑在最初空栈上进行的推入 push 和弹出 pop 操作，那么我们不妨就建立一个空栈尝试用程序的方式来模拟一遍操作的流程，看看会不会明朗点： function validateStackSequences(pushed, popped) { const stack = []; pushed.forEach(ele =&gt; { stack.push(ele); stack.pop(); }); return !stack.length; } 这样我们就建立了一个栈，并且在按题目中 pushed 数组的顺序将元素 push 进栈， 然后再按照同样的顺序 pop 出去。 不过这样子就跟数学题里面一边放水，一边加水的疯狂管理员一般，返回的结果肯定为 true。 回头再看看题目，发现其实就是在这个一边增加一边移出的过程上，添加了一个条件：只能按照 poped 的顺序来 pop 数据，看看能不能将 stack 清空 。 再拆解一下目标，就更明确了： 按照 pushed 的顺序将元素 push 入栈。 在 push 的过程中尝试 pop 元素。 pop 元素的顺序要和 poped 的顺序一样。 要满足这三个条件，一个方法就是，尝试在 push 的每一步时，尽可能按照指定顺序 pop 出所有的元素。根据这个思路，Helen 给出了题解： function validateStackSequences(pushed, popped) { const stack = []; let popIndex = 0; for (const val of pushed) { stack.push(val); while (stack.length !== 0 &amp;&amp; stack[stack.length - 1] === popped[popIndex]) { stack.pop(); popIndex++; } } return stack.length === 0; } 书香的思路一模一样，只是把代码写的更短了点 ： function validateStackSequences(pushed, popped) { const stack = []; pushed.forEach(ele =&gt; { stack.push(ele); while (stack.length &amp;&amp; stack[stack.length - 1] === popped[0]) { stack.pop(); popped.shift(); } }); return !stack.length; } Extra Go对于书香和 Helen 这样的初级选手，通过实现一个栈结构来模拟题目中要求的操作，解出题目，就已经开心地到一边去玩耍了 ~ 但对于追求完美的曾大师来说，push 和 pop 这两个操作，都非常消耗计算资源。而这种把数据一边 push 一边 pop 的疯狂操作显然是不能容忍的。 为此，他写出了 2 米长的 Go 语言代码： func validateStackSequences(pushed []int, popped []int) bool { if len(popped) == 0 { return true } pushedValues := make(map[int]int) //存储所有的已经入栈的值和数组索引 left := 0 right := 0 for i := 0; i &lt; len(pushed); i++ { if pushed[i] == popped[0] { pushed[i] = -1 // 出栈 left = i-1 right = i+1 break } else { pushedValues[pushed[i]] = i } } for j := 1; j &lt; len(popped); j++ { if _, ok := pushedValues[popped[j]]; ok { // 值已经加入stack了 for left &gt;= 0 { if pushed[left] == -1 { left-- } else { break } } if left &lt; 0 { left = 0 } if popped[j] != pushed[left] { return false } else { // 值相等，出栈 pushed[left] = -1 left-- } } else { // 值没有加入stack，继续往前找 for right &lt; len(popped) { if popped[j] == pushed[right] { // 找到了 pushed[right] = -1 //出栈 left = right - 1 // 重新赋值left right ++ // 重新赋值right break } else { // 没有找到，继续往前 pushedValues[pushed[right]] = right right++ } } } } return true } 嗯…… 8 ms 的运行时间…… 贪心算法不知道你有没有发现，这道题目，在开始的时候看起来比较绕，但是真正实现起来并没有那么困难？ 其实关键点在于 「分而治之」，将任务中的每一步拆分开来，并且在每一步时，都尽可能去寻找最优解，再将每一步的最优解达到合起来，看是否能达成目标。 这种思路的算法就称为 「贪心算法」，它在遇到寻找最优解问题的情况下，能够提供很大的帮助。 下次见~","link":"/article/algorithm/verify-stack-sequence/"},{"title":"【青铜三人行】匹配子序列的单词数","text":"每周一题，代码无敌~ 这次让我们换换口味，讨论一个稍微偏实际一点的问题： 匹配子序列的单词数力扣 ​leetcode-cn.com 给定字符串 S 和单词字典 words, 求 words[i] 中是 S 的子序列的单词个数。 示例输入: S = \"abcde\" words = [\"a\", \"bb\", \"acd\", \"ace\"] 输出: 3 解释: 有三个是 S 的子序列的单词: \"a\", \"acd\", \"ace\"。 注意所有在 words 和 S 里的单词都只由小写字母组成。 S 的长度在 [1, 50000]。 words 的长度在 [1, 5000]。 words[i] 的长度在 [1, 50]。 暴力破解法这周的题目相对简单。从题意上来理解，无非就是 words 数组中每一个单词拿到 S 字符串中去尝试匹配就好。稍微值得注意的是，因为匹配的规则在于不一定是连续子字符串匹配，因此需要考虑每个字母在其中是否全部都存在，Helen 给出了暴力解法： function numMatchingSubseq(S, words) { let count = 0; for (const word of words) { let index = -1, _count = 0; for (const str of word) { _count++; const _index = S.indexOf(str, index + 1); if (_index === -1) break; else index = _index; if (_count === word.length) count++; } } return count; } 书香在同样的思路上，利用 JS 的自带 API ，稍微做了一些写法上的优化，让程序看起来更简短了一些： function numMatchingSubseq(S, words) { const isSubWord = function (s, word) { let pos = -1; for (let i = 0; i &lt; word.length; i++) { pos = s.indexOf(word[i], pos + 1); if (pos == -1) return 0; } return 1; }; return words.reduce((count, word) =&gt; count + isSubWord(S, word), 0); } 你看出了其中的相同之处了吗？ 正则表达式匹配既然是字串匹配，自然可以通过正则表达式来完成匹配。书香尝试了这一解法： function numMatchingSubseq(S, words) { return words.reduce((count, word) =&gt; { const testReg = new RegExp(word.split(\"\").join(\"w*\")); if (testReg.test(S)) count++; return count; }, 0); } 但是，正则匹配花费的计算资源会更高一些，因此这个解法在题目中的超长字串测试用例中，因为超出时间限制而失败了…… 在这里贴出这段代码，仅作为一种思路的参考。 可不可以不那么暴力？Helen 作为三人行里唯一的女生，自然忍不了动不动就 「暴力破解」的做法 ‍♀️。因此她换了一个不那么暴力的思路，通过将 words 中的单词按照首字母先排序到一个 「桶」中，将数据进行了预处理，然后在字符串匹配其中字符的的时候，就可以从对应的地方匹配了： function numMatchingSubseq(S, words) { const bucket = Array.from({ length: 26 }, () =&gt; []); let count = 0; for (const word of words) bucket[word.charCodeAt(0) - 97].push(word); // a 的 Unicode 是 97 for (const str of S) { const list = bucket[str.charCodeAt(0) - 97]; bucket[str.charCodeAt(0) - 97] = []; for (let word of list) if (word.length &gt; 1) { word = word.slice(1); if (word) bucket[word.charCodeAt(0) - 97].push(word); } else count++; } return count; } Extra曾大师的 Go 语言时光，他似乎也很暴力…… func numMatchingSubseq(S string, words []string) int { count := 0 for i := 0; i &lt; len(words); i++ { stat := 0 word := words[i] if len(word) &gt; len(S) { continue } else { for i := 0; i &lt; len(S); i++ { if word[stat] == S[i] { stat++ if stat == len(word) { count++ break } } } } } return count } 这一次他的时间消耗就没有那么好了，你能看出相比其前面 JS 的两个暴力解法，这次他为什么「失手」了吗？ 更多在这次题目中，三人行不约而同采用了「暴力解法」，并且在一定程度的简单优化上，时间和空间的利用成绩都还不错。事实在，在写代码的过程中，往往也是一个迭代的过程，前期过度地优化有时候反而不如先利用最直观的方式把程序先跑起来，再根据需求和场景条件来进行对应的优化更好。 下周见啦~","link":"/article/algorithm/number-of-words-matching-subsequence/"},{"title":"使用 Certbot 在内网签发 wildcards（通配符证书）","text":"前置条件 Certbot 和 certbot-dns-cloudflare 插件 域名的 NS 服务器设置为 CloudFlare， 配置好，大概一天后生效（保守估计） 内网 DNS 服务器， 如果路由器支持定义局域网域名，可以不安装，我用的是 adguard 内网 Ubuntu 服务器 Ubuntu 安装 Nginx 安装 Certbotsudo apt install -y certbot 因为域名的 NS 服务器在 CloudFlare， 需要使用 certbot-dns-cloudflare 插件 sudo apt-get install python3-certbot-dns-cloudflare 获取用户 API 令牌 登录到 CloudFlare Dashboard。 前往 “My Profile” &gt; “API Tokens”。 确认你的 API 令牌具有所需的权限（Zone.Zone:Read 和 Zone.DNS:Edit），并且选择要使用的域名。 在服务器上创建文件 vim ~/.cloudflare.ini,写入如下内容 dns_cloudflare_api_token = xxx # 对应域名的 API token 然后修改文件权限，只可以本用户可读写 chmod 600 ~/.cloudflare.ini。 签发证书sudo certbot certonly \\ --dns-cloudflare \\ --dns-cloudflare-credentials ~/.cloudflare.ini -d \\ 'yourdomain.com, *.yourdomain.com' 就可以看到如下 Saving debug log to /var/log/letsencrypt/letsencrypt.log Requesting a certificate for yourdomain.com and *.yourdomain.com Waiting 10 seconds for DNS changes to propagate Successfully received certificate. Certificate is saved at: /etc/letsencrypt/live/yourdomain.com/fullchain.pem Key is saved at: /etc/letsencrypt/live/yourdomain.com/privkey.pem This certificate expires on 2024-08-10. These files will be updated when the certificate renews. Certbot has set up a scheduled task to automatically renew this certificate in the background. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - If you like Certbot, please consider supporting our work by: * Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate * Donating to EFF: https://eff.org/donate-le - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 几分钟后应该收到 CloudFlare 和 Certbot 的邮件 因为这个证书是有 90 天的有效期， 需要把 cerbot 加入定时任务。先验证 Cerbot 续签是否可以成功。 certbot renew --dry-run Ubuntu 和 Debian 使用了 systemd ， 在安装 Certbot 过程中已经设置好了，不需要在自己手动加入 Crontab ， 验证状态。 systemctl status certbot.timer ● certbot.timer - Run certbot twice daily Loaded: loaded (/lib/systemd/system/certbot.timer; enabled; preset: enabled) Active: active (waiting) since Sun 2024-05-12 22:49:11 CST; 53min ago Trigger: Mon 2024-05-13 01:49:57 CST; 2h 7min left Triggers: ● certbot.service May 12 22:49:11 traefik systemd[1]: Started certbot.timer - Run certbot twice daily. 如果发行版没有使用 systemd ， 运行命令， 编辑定时任务。 crontab -e 加入如下内容 0 0,12 * * * sudo certbot renew --quiet 每天 0 点， 12 点运行一次， --quiet 参数确保只有在发生错误时才会有输出。 更详细的日志可以通过下面的命令查看 less /var/log/letsencrypt/letsencrypt.log 请注意，Certbot 通常会在证书到期前 30 天尝试续签，所以即使你设置了每天检查，实际的续签操作并不会每天发生。 配置 Nginx 读取证书server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name yourdomain.com www.yourdomain.com; ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384'; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; } 请将 yourdomain.com 替换为你的实际域名。 sudo nginx -t 验证 Nginx 配置 sudo systemctl reload nginx 使用新配置。 配置 内网 DNS 服务器需要在路由器指定 内网 DNS 服务器，我用的是小米路由器 192.168.2.166 我的 DNS 服务器的内网 IP。 配置内网 DNS 服务器， 我用的是 Adguard 验证 DNS 解析 dig gpt.luojiyin.top &lt;&lt;&gt;&gt; DiG 9.18.18-0ubuntu2.1-Ubuntu &lt;&lt;&gt;&gt; gpt.luojiyin.top ;; global options: +cmd ;; Got answer: ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 50327 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 65494 ;; QUESTION SECTION: ;gpt.luojiyin.top. IN A ;; ANSWER SECTION: gpt.luojiyin.top. 10 IN A 192.168.2.166 ;; Query time: 4 msec ;; SERVER: 127.0.0.53#53(127.0.0.53) (UDP) ;; WHEN: Mon May 13 00:13:12 CST 2024 然后指定 公网 DNS 服务器 119.29.29.29 dig gpt.luojiyin.top @119.29.29.29 ; &lt;&lt;&gt;&gt; DiG 9.18.18-0ubuntu2.1-Ubuntu &lt;&lt;&gt;&gt; gpt.luojiyin.top @119.29.29.29 ;; global options: +cmd ;; Got answer: ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 48075 ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0 ;; QUESTION SECTION: ;gpt.luojiyin.top. IN A ;; AUTHORITY SECTION: luojiyin.top. 360 IN SOA jocelyn.ns.cloudflare.com. dns.cloudflare.com. 2341014133 10000 2400 604800 1800 ;; Query time: 272 msec ;; SERVER: 8.8.8.8#53(8.8.8.8) (UDP) ;; WHEN: Mon May 13 00:13:32 CST 2024 ;; MSG SIZE rcvd: 99 就可以发现 DNS 解析只在内网生效。 然后用浏览器打开你自己的网址，可以看到。 就可以在内网使用 https，可以使用很多高级 web 特性了。 总结考虑大部分人接触过 Nginx，以 Nginx 作为示范。 可以根据自己的情况换成阿里云或者腾讯云，需要设置域名的 NS 服务器设置为对应的云。由于是 wildcard（通配符域名），只需签发一次， yourdomain.com *.yourdomain.com 等域名可以用。 思路是通过 DNS 验证，Certbot 通过 token 给 CF 的 DNS 服务器添加一个 TXT 记录， 然后 Cerbot 读取这个 TXT 记录，是否一致，验证你对域名的控制权并签发证书。也是国内很多云服务商为什么让你加一个 TXT 记录，才签发一个单个域名证书 (Single-domain SSL certificate) ，不舍得给你一个 通配符证书 (Wildcard SSL certificate) ，让你反复操作。 一图胜千言 Certbot 就是图中的 Caddy 如果不使用 Nginx， 而使用云原生的网关软件，会变得更自动化，更简单。","link":"/article/engineering/certbot-issues-wildcards-private-network/"},{"title":"ECMAScript + DOM 骚操作","text":"前一阵有篇传播较广的 Web 技术博文，我看后觉得，作者题为“ES 6”，但有些示例代码却不够 ES 6，且看我一一优化~ 对标文章 中文译文：《记好这 24 个 ES6 方法，用来解决实际开发的 JS 问题》 英文原文：“24 modern ES6 code snippets to solve practical JS problems” 我来优化1. 如何隐藏所有指定的元素？for (const element of document.querySelectorAll(\".your-selector\")) element.hidden = true; 【知识点】 for ... of HTMLElement.prototype.hidden 4. 如何获取当前页面的滚动位置？const getScrollPosition = ({ pageXOffset, pageYOffset, scrollLeft, scrollTop } = window) =&gt; ({ x: pageXOffset ?? scrollLeft, y: pageYOffset ?? scrollTop }); getScrollPosition(); // {x: 0, y: 200} 【知识点】（ES 11/2020 特性，略微超纲） ?? 空值合并运算符 5. 如何平滑滚动到页面顶部？window.scrollTo({ top: 0, behavior: \"smooth\" }); 【知识点】 window.scrollTo() 8. 如何获取元素中的所有图像？const getImages = (element = document) =&gt; [ ...new Set( Array.from( element.querySelectorAll('img, input[type=\"image\"]'), ({ src }) =&gt; src ) ) ]; getImages(); // ['http://fcc-cd.dev/xxx.jpg', 'http://fcc-cd.dev/yyy.png'] 【知识点】 Array.from() input[type=\"image\"] 9. 如何确定设备是移动设备还是台式机、笔记本电脑？const isMobile = \"ontouchend\" in document; console.log(isMobile); 【知识点】 touchend 事件 11. 如何创建一个包含当前 URL 参数的对象？const parseURLData = (raw = location.search) =&gt; Object.fromEntries([...new URLSearchParams(raw)]); parseURLData(\"http://url.com/page?n=Adam&amp;s=Smith\"); // {n: 'Adam', s: 'Smith'} 【知识点】（ES 10/2019 特性，略微超纲） Object.fromEntries() URLSearchParams() 若想支持重名参数、参数值转基本类型，请参考 Web Utility 的实现。 12. 如何将一组表单元素转化为对象？const formToJSON = form =&gt; Object.fromEntries([...new FormData(form)]); formToJSON(document.forms[0]); // {email: 'test@email.com', name: 'Test Name'} 【知识点】 FormData() 若想支持同名多值、 fieldset 转嵌套对象、参数值转基本类型，请参考 Web Utility 的实现。 14. 如何在等待指定时间后调用提供的函数？const delay = seconds =&gt; new Promise(resolve =&gt; setTimeout(resolve, seconds * 1000)); await delay(1); console.log(\"1 second later\"); 【知识点】 Promise() 顶层 await 提案 17. 如何获得给定毫秒数的可读格式？const unitISO = [\"Y\", \"M\", \"D\", \"H\", \"m\", \"s\", \"ms\"], patternISO = /[YMDHms]+/g; function formatDate(time = new Date(), template = \"YYYY-MM-DD HH:mm:ss\") { time = time instanceof Date ? time : new Date(time); const temp = new Date(+time - time.getTimezoneOffset() * 60 * 1000) .toJSON() .split(/\\D/) .reduce((temp, section, index) =&gt; { temp[unitISO[index]] = section; return temp; }, {}); return template.replace(patternISO, section =&gt; temp[section[0]].padStart(section.length, \"0\") ); } formatDate(new Date(1989, 05, 04), \"YYYY年MM月DD日\"); // '1989年06月04日' 【知识点】 Date.prototype.toJSON() Array.prototype.reduce() String.prototype.padStart() 上述函数的核心是 ISO 时间格式，它也是 Date 对象序列化到 JSON 中的标准格式。又因为 ISO 时间总是 0 时区的，所以要事先做好时区偏移，使转出的时间正确。将 ISO 时间字符串中的数值与时间单位占位符一一对应后，就可用正则表达式把时间数据替换进模板里了~ 20. 如何对传递的 URL 发出 POST 请求？const request = ( path, method = \"GET\", body = null, header = { \"Content-Type\": \"application/json\" }, option = { responseType: \"json\" } ) =&gt; new Promise((resolve, reject) =&gt; { const client = new XMLHttpRequest(); (client.onload = () =&gt; resolve(client.response)), (client.onerror = reject); client.open(method, path); for (const name in header) client.setRequestHeader(name, header[name]); Object.assign(client, option); client.send(body &amp;&amp; typeof body === \"object\" ? JSON.stringify(body) : body); }); console.log( await request(\"https://jsonplaceholder.typicode.com/posts\", \"POST\", { userId: 1, id: 1337, title: \"Foo\", body: \"bar bar bar\" }) ); 【知识点】 XMLHttpRequest() Object.assign() 有些小伙伴看了上面的代码可能要说： 要用基于 Promise 的 AJAX，干嘛不用 fetch()？XHR 还要自己封装…… 其实标准化后的 XHR 功能很强大，比 fetch() 还灵活，水歌开发的网络库 KoAJAX 就基于它实现~ 总结自 HTML 5、DOM 4、ECMAScript 6 以来，各种新 API、语法糖层出不穷，再加上 API polyfill 补丁、Babel 语法转译器，Web 前端工程师早已不需担心浏览器兼容性，大胆使用原生 API、语法写出简洁的代码，专注于业务和上层架构。 以上经验来自水歌开源的 WebCell 组件引擎升级最新 API 和语法之路的一些心得。同时，WebCell 也全面拥抱了 TypeScript，并已形成官方生态库矩阵，支撑了多个生产项目，欢迎大家一起研讨、开发！ 相关推荐《如何用开源软件办一场技术大会？》","link":"/article/engineering/ecmascript-dom-skills/"},{"title":"GitHub 在线 IDE 初体验","text":"之前就有听说 GitHub 将推出在线 IDE，一搜索发现很多结果。 现在 GitHub 的在线 IDE 发布一段时间了，官方命名为：GitHub Codespaces（点击可以申请），今天我们就来体验一下。 基础体验在这里，我就拿本人博客的仓库来简单跑一下 GitHub Codespaces。 创建 IDE在 Clone 的按钮选择“Open With Codespaces” 创建流程 进入之后会列出已有的 IDE 列表，没有的话点击下面的新建就是了。 创建流程 进入 IDE开始进入是在初始化，然后就是同步一些配置。 我们会发现在 VS Code 的配置和插件扩展都会被同步过来（当然，前提是你本地的 VSC 和自己的 GitHub 绑定起来，并且同步配置）。 同时，IDE 可以自动识别 package.json 安装依赖，进来就自动安装好了。 点击查看日志还可以查看初始化的日志。 基本使用预装基础环境简单的几行代码，我们可以发现 IDE 已经预装了 node、docker、npm、git、python 等等基础开发环境。 预安装基础环境 启动项目首先全局安装 Hexo，再启动项目 yarn d。 yarn add global hexo 因为 GitHub 的环境在外面，因此安装速度还是很快的，纵享丝滑。 外部端口的打开如果我们的页面需要启动本地端口，IDE 也会提示出来有外部端口。 端口打开 我们也可以在“Remote Explorer”看到全部的端口映射情况 Remote Explorer 我们点击在浏览器打开，然后就可以看到页面了。 当我们修改之后，在侧边栏直接提交就是了，简单快捷。也不用任何的设置。 进阶玩法我们的项目不仅仅是前端项目，也有可能是后端 Server，这里我就用一个后端 Server 来简单演示一下。 安装依赖跑起来 全局安装 nodemon 进入 server 目录安装依赖 很明显这里报错了，原因是我们的 Server 需要连接 PostgreSQL，而我们没有安装。 不恰当的安装方法找到一篇教程，照着代码跑起来。 sudo apt-get update sudo apt-get install postgresql postgresql-client # 创建一个数据库超级用户 postgres sudo -i -u postgres 最后，我们会卡在这里，因为我们不知道 Codespace 的密码，因此安装失败。 Docker 出马我们可以观察到 Codespace 已经为我们安装了 Docker，而且在现在相当流行容器化部署，上面的那种安装方式也不够优雅。 因此运行命令，安装 PostgreSQL docker run -p 5432:5432 -v /home/docker/postgresql/data:/var/lib/postgresql/data -e POSTGRES_PASSWORD=123456 -e TZ=PRC -d --name=some-postgres postgres // -p 端口映射 // -v 将数据存到宿主服务器 // -e POSTGRES_PASSWORD 密码（默认用户名 postgres） // -e TZ=PRC 时区：中国 // -d 后台运行 // --name 容器名称 运行之后，找不到镜像会自动去拉取镜像 查看下状态 现在重启 server，发现已经可以连接上了。 端口我们可以在“Forwarded Ports”增加端口转发 简单演示一下 Get 请求，并且是即时的，修改之后可以通过域名来访问。 顺便说一句，如果我们在代码中写好 URL 地址，就可以直接用鼠标在命令行打开对应端口，网址也会被进行替换。 注意但是也需要注意，如果我们用 Postman 去请求就无法正常请求结果。 如果我们访问 /graphql，请求就会提示“Server cannot be reached”和一些跨域错误。 总结优点俗话说，工欲善其事必先利其器。 编程更重要的是一种思想，而编码更重要的是去表达思想。 如果我们将配置环境，机器选择的的步骤省下来，让自己更加专注于思想表达，专注于编码的话，这样会让我们事半功倍。而现在 GitHub IDE 就可以看成 VSC 的网页版。如果你将 VSC 的配置同步到 GitHub 账户的话，你打开在线 IDE 的时候就会直接同步配置，你会很快上手。 除此之外，GitHub 的里面预装各种环境，让你不再苦恼于环境安装，而且所处的网络环境也很棒，各种库、配置下载起来也是很快，我想这对我们的帮助也是很大的。比如再也不用纠结 node-sass 下载不下等尴尬场景。 遇到紧急的事情，一个浏览器就可以让你专注开发，这难道不香吗？ 不足虽然 GitHub 在线 IDE 有很多优点，但是还是有一些不足，肯定不能和 VSC 真机比拟。比如一些接口 /graphql，就没有本地真机开发的那么爽。除此之外，真机的 VSC 就有很多辅助扩展。比如 PicGo 来实现图片上传到 GitHub 做图床，在浏览器 IDE 里面经过测试是跑不通的。 我测试的时候限制了同时启用两个 IDE，不然会提示你让你处理。 因为每个人所处的网络环境不同，不用高级姿势访问有可能会出现链接断开的情况，这倒是有点硬伤。🤣 结语之前听过“阿里 云电脑”，加上现在 5G 的逐渐普及，说不定未来大家需要的只是一个显示器，可以完成学习、工作和娱乐，配置全部都在远端。听起来天方夜谭，说不定在未来就会实现。 一个新兴事物的出来，肯定引起人们的好奇和质疑。仔细想想 GitHub 被微软收购之后，先后推出了个人无限私有仓库，免费使用 GitHub Actions，再有 GitHub Codespaces。而微软也先后推出 TS、VSC 等市场举足轻重的开源项目。我所看到是开源界的发展和繁荣，也希望未来越来越好。 撒花！","link":"/article/engineering/github-ide-first-time/"},{"title":"GraphQL + Koa + React 项目实践","text":"项目背景源于 2019 年 11 月 16 日 FCC 成都社区主办的 Web 全栈大会上尹吉峰老师的 GraphQL 的分享，让我产生了浓厚的兴趣。GraphQL 是一个用于 API 的查询语言，是使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。一个 GraphQL 服务是通过定义类型和类型上的字段来创建的，然后给每个类型上的每个字段提供解析函数。 参考学习资料： https://graphql.cn/learn/ https://typescript.bootcss.com/basic-types.html https://www.apollographql.com/docs/react/ 基于以上的一番学习，做了个实践的小项目，就代码做以下分析。 （附上项目地址：react-graphql-project） 项目目录项目分为前端和后端两部分（目录 client 和 server），如图所示： 使用技术栈： client：React hooks + TypeScript + Apollo + GraphQL + Ant Design server: Koa 2 + GraphQL + koa-graphql + Mongoose 项目搭建及源码实现数据库部分使用的 MongoDB 数据库，这里对于该数据库的安装等不做赘述。 默认已经具备 MongoDB 的环境。接下来，启动数据库。 到 MongoDB 安装路径下，如 C:\\Program Files\\MongoDB\\Server\\4.2\\bin 打开终端，执行命令： mongod --dbpath=./data 创建项目总目录：react-graphql-project，并进入目录。 后端部分创建项目，并初始化mkdir server &amp;&amp; cd server npm init -y 安装项目依赖yarn add koa koa-grphql koa2-cors koa-mount koa-logger graphql 配置启动命令package.json { \"scripts\": { \"start\": \"nodemon index.js\" } } 业务开发入口文件index.js 这里我们启动一个 Koa 服务，进行日志监听，支持跨域操作，并将 GraphQL 服务挂到 Koa 服务上。通过 koa-graphql 提供 HTTP 服务，传入 schema，并启动 graphiql。graphiql 在测试和开发过程中都非常有用，但生产环境下应禁用它。 const Koa = require(\"koa\"); const mount = require(\"koa-mount\"); const graphqlHTTP = require(\"koa-graphql\"); const cors = require(\"koa2-cors\"); const logger = require(\"koa-logger\"); const myGraphQLSchema = require(\"./schema\"); const app = new Koa(); // 日志 app.use(logger()); // 跨域支持 app.use( cors({ origin: \"*\", allowMethods: [\"GET\", \"POST\", \"DELETE\", \"PUT\", \"OPTIONS\"] }) ); app.use( mount( \"/graphql\", graphqlHTTP({ schema: myGraphQLSchema, graphiql: true // 开启graphiql可视化操作playground }) ) ); app.listen(4000, () =&gt; { console.log(\"server started on 4000\"); }); 数据库连接创建 model 文件 model.js 这里我们建立数据链接，定义 schema，并生成对应的 model 导出。schema 是 mongoose 里会用到的一种数据模式，可以理解为表结构的定义。每个 schema 会映射到 MongoDB 中的一个 collection，它并不具备操作数据库的能力。model 是由 schema 生成的模型，可以对数据库进行操作。 const mongoose = require(\"mongoose\"); const Schema = mongoose.Schema; // 创建数据库连接 const conn = mongoose.createConnection(\"mongodb://localhost/graphql\", { useNewUrlParser: true, useUnifiedTopology: true }); conn.on(\"open\", () =&gt; console.log(\"数据库连接成功！\")); conn.on(\"error\", error =&gt; console.log(error)); // 用于定义表结构 const CategorySchema = new Schema({ name: String }); // 增删改查 const CategoryModel = conn.model(\"Category\", CategorySchema); const ProductSchema = new Schema({ name: String, category: { type: Schema.Types.ObjectId, // 外键 ref: \"Category\" } }); const ProductModel = conn.model(\"Product\", ProductSchema); module.exports = { CategoryModel, ProductModel }; schema.js 定义查询的 schema 对象。在 GraphGL 中有许多内置的 Schema Types 可供我们用来定义字段名类型。这里我们通过定义查询对象类型，通过 model 就可以对数据库进行增、删、改、查等相应操作了。 const graphql = require('graphql'); const { CategoryModel, ProductModel } = require('./model'); const { GraphQLObjectType, GraphQLString, GraphQLSchema, GraphQLList, GraphQLNonNull } = graphql // 分类类型定义 const Category = new GraphQLObjectType({ name: 'Category', fields: () =&gt; ( { id: { type: GraphQLString }, name: { type: GraphQLString }, products: { type: new GraphQLList(Product), async resolve(parent){ let result = await ProductModel.find({ category: parent.id }) return result } } } ) }) // 商品类型定义 const Product = new GraphQLObjectType({ name: 'Product', fields: () =&gt; ( // ... ) }) // 根查询对象 const RootQuery = new GraphQLObjectType({ name: 'RootQuery', fields: { getCategory: { // 通过id获取分类 type: Category, args: { id: { type: new GraphQLNonNull(GraphQLString) } }, async resolve(parent, args){ let result = await CategoryModel.findById(args.id) return result } }, // ... 其他查询定义 } }) // 根变更对象 const RootMutation = new GraphQLObjectType({ name: 'RootMutation', fields: { addCategory: { //根据name添加分类 type: Category, args: { name: { type: new GraphQLNonNull(GraphQLString) } }, async resolve(parent, args){ let result = await CategoryModel.create(args) return result } }, // ... 其他变更定义 } }) module.exports = new GraphQLSchema({ query: RootQuery, mutation: RootMutation }) 启动项目yarn start 访问 http://localhost:4000/graphql 看到数据库操作 playground 界面。可进行一系列数据库 CRUD 操作。 前端部分创建项目npx create-react-app client --template typescript 配置 webpackyarn add react-app-rewired customize-cra 更改 package.json 文件的 scripts 启动命令 { \"scripts\": { \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\" } } 然后在根目录下新建 config-overrides.js 文件，以添加 webpack 的相关配置。 安装前端 UI 组件库 antd，并配置按需加载、路径别名支持等。 yarn add antd babel-plugin-import config-overrides.js const { override, fixBabelImports, addWebpackAlias } = require(\"customize-cra\"); const path = require(\"path\"); module.exports = override( fixBabelImports(\"import\", { libraryName: \"antd\", libraryDirectory: \"es\", style: \"css\" }), addWebpackAlias({ \"@\": path.resolve(__dirname, \"src/\") }) ); 因为 TS 无法识别，还需配置 tconfig.json 文件。 新建 paths.json 文件 { \"compilerOptions\": { \"baseUrl\": \".\", \"paths\": { \"@/*\": [\"src/*\"] } } } 更改 tconfig.json { \"compilerOptions\": { \"target\": \"ES5\", \"lib\": [\"DOM\", \"DOM.Iterable\", \"ESNext\"], \"allowJs\": true, \"jsx\": \"react\" }, \"include\": [\"./src/**/*\"], \"extends\": \"./paths.json\" } 重启项目后生效。 业务开发入口文件index.tsx 首先我们需要创建 Apollo 客户端，传入启动的后端地址作为 uri 的值，将生成的客户端实例通过 context 注入到整个单页应用中。 // ... import ApolloClient from \"apollo-boost\"; import { ApolloProvider } from \"@apollo/react-hooks\"; import App from \"./router\"; // 创建apollo客户端 const client = new ApolloClient({ uri: \"http://localhost:4000/graphql\" }); ReactDOM.render( &lt;ApolloProvider client={client}&gt; &lt;App /&gt; &lt;/ApolloProvider&gt;, document.getElementById(\"root\") ); 路由文件router.js 主要包括商品列表页、商品详情等路由的配置。 import React, { Suspense, lazy, memo } from \"react\"; import { BrowserRouter as Router, Route, Switch } from \"react-router-dom\"; import { Spin } from \"antd\"; const Layouts = lazy(() =&gt; import(\"@/components/layouts\")); const ProductList = lazy(() =&gt; import(\"@/pages/productlist\")); const ProductDetail = lazy(() =&gt; import(\"@/pages/productdetail\")); const RouterComponent = () =&gt; { return ( &lt;Router&gt; &lt;Suspense fallback={&lt;Spin size=\"large\" /&gt;}&gt; &lt;Layouts&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact={true} component={ProductList} /&gt; &lt;Route path=\"/detail/:id\" component={ProductDetail} /&gt; &lt;Route render={() =&gt; &lt;h1&gt;404 Not Found&lt;/h1&gt;} /&gt; &lt;/Switch&gt; &lt;/Layouts&gt; &lt;/Suspense&gt; &lt;/Router&gt; ); }; 定义类型文件types.ts export interface Category { id?: string; name?: string; products: Array&lt;Product&gt;; } export interface Product { id?: string; name?: string; category?: Category; categoryId?: string | []; } 布局组件src/components/layouts import React from \"react\"; import { Layout, Menu } from \"antd\"; import { Link } from \"react-router-dom\"; const { Header, Content, Footer } = Layout; const Layouts = props =&gt; ( &lt;Layout className=\"layout\"&gt; &lt;Header&gt; &lt;div className=\"logo\" /&gt; &lt;Menu theme=\"dark\" mode=\"horizontal\" defaultSelectedKeys={[\"1\"]} style={{ lineHeight: \"64px\" }} &gt; &lt;Menu.Item key=\"1\"&gt; &lt;Link to=\"/\"&gt;商品管理&lt;/Link&gt; &lt;/Menu.Item&gt; &lt;/Menu&gt; &lt;/Header&gt; &lt;Content style={{ padding: \"50px 50px 0 50px\" }}&gt; &lt;div style={{ background: \"#fff\", padding: 24, minHeight: 280 }}&gt; {props.children} &lt;/div&gt; &lt;/Content&gt; &lt;Footer style={{ textAlign: \"center\" }}&gt; ©2019 - {new Date().getFullYear()} Created by zhangyanling77.{\" \"} &lt;/Footer&gt; &lt;/Layout&gt; ); export default Layouts; GraphQL 查询语句文件api.ts import { gql } from \"apollo-boost\"; // 获取所有的商品 export const GET_PRODUCTS = gql` query { getProducts { id name category { id name products { id name } } } } `; // ... 其他查询语句定义 商品列表组件 ProductList 实现商品列表展示、删除商品、新增商品等功能。 // ... 其他依赖引入 import { useQuery, useMutation } from \"@apollo/react-hooks\"; import { CATEGORIES_PRODUCTS, GET_PRODUCTS, ADD_PRODUCT, DELETE_PRODUCT } from \"@/api\"; // ... const ProductList = () =&gt; { // ... 其他状态定义 const { loading, error, data } = useQuery(CATEGORIES_PRODUCTS); const [deleteProduct] = useMutation(DELETE_PRODUCT); // ... 错误处理，加载中处理 const { getCategories, getProducts } = data; const confirm = async (event, record) =&gt; { // 删除商品 await deleteProduct({ variables: { id: record?.id }, refetchQueries: [ { query: GET_PRODUCTS } ] }); setCurrent(1); }; const columns = [ // ... ]; // ... return ( &lt;div&gt; &lt;Row style={{ padding: \"0 0 20px 0\" }}&gt; &lt;Col span={24}&gt; &lt;Button type=\"primary\" onClick={() =&gt; setVisible(true)}&gt; 新增 &lt;/Button&gt; &lt;/Col&gt; &lt;/Row&gt; {/* ... */} {visible &amp;&amp; ( &lt;AddForm handleOk={handleOk} handleCancel={handleCancel} categories={getCategories} /&gt; )} &lt;/div&gt; ); }; const AddForm = ({ handleOk, handleCancel, categories }) =&gt; { // ... 其他状态定义 let [addProduct] = useMutation(ADD_PRODUCT); const handleSubmit = async () =&gt; { await addProduct({ variables: product, refetchQueries: [ { // 添加成功后执行查询全部商品的操作，是个回调 query: GET_PRODUCTS } ] }); setProduct({ name: \"\", categoryId: [] }); // 清空表单 handleOk(); }; return ( &lt;Modal title=\"新增产品\" // ... &gt; &lt;Form&gt;{/* ... */}&lt;/Form&gt; &lt;/Modal&gt; ); }; export default ProductList; 商品详情组件 ProductDetail 根据 ID 查询商品详情及其所属商品分类下的所有商品。 // ... import { useQuery } from \"@apollo/react-hooks\"; import { GET_PRODUCT } from \"@/api\"; import { Product } from \"@/types\"; const ProductDetail = props =&gt; { let _id = props.match.params.id; let { loading, error, data } = useQuery(GET_PRODUCT, { variables: { id: _id } }); // ... 错误处理 const { getProduct } = data; const { id, name, category: { id: categoryId, name: categoryName, products } } = getProduct; return ( &lt;div&gt; &lt;Card title=\"商品详情\" bordered={false} style={{ width: \"100%\" }}&gt; &lt;div&gt; &lt;p&gt; &lt;b&gt;商品ID：&lt;/b&gt; {id} &lt;/p&gt; &lt;p&gt; &lt;b&gt;商品名称：&lt;/b&gt; {name} &lt;/p&gt; &lt;/div&gt; // ... 商品列表展示 &lt;/Card&gt; &lt;/div&gt; ); }; export default ProductDetail; 结语通过这个项目实践，基本掌握了 GraphQL 的使用。虽然这个项目只包含了简单的 CRUD 功能，但是对后端、数据库、前端都涉及到了，因此对于学习拓展来说也是不错的。后续也继续实现了登录验证、个人中心等功能，这里不做详细介绍，可自行查看项目代码了解。","link":"/article/engineering/graphql-koa-react-project-practice/"},{"title":"使用 Caddy 和 CloudFlare 在内网自动签发 https 证书","text":"前置条件 Caddy 和 dns-cloudflare 插件，需要构建自己的 Docker 镜像 域名的 NS 服务器设置为 CloudFlare， 配置好，大概一天后生效（保守估计） 内网 DNS 服务器， 如果路由器支持定义局域网域名，可以不安装，我用的是 adguard 内网 Ubuntu 服务器 Ubuntu 安装 Docker 构建 Docker 镜像在 Docker compose 同一层文件夹里，创建一个 Dockerfile。 FROM caddy:builder AS builder RUN caddy-builder github.com/caddy-dns/cloudflare FROM caddy:latest COPY --from=builder /usr/bin/caddy /usr/bin/caddy 在 Docker compose 使用 Dockerfile version: \"3.7\" services: caddy: container_name: caddy build: context: . dockerfile: Dockerfile 获取用户 API 令牌 登录到 CloudFlare Dashboard。 前往 “My Profile” &gt; “API Tokens”。 确认你的 API 令牌具有所需的权限（Zone.Zone:Read 和 Zone.DNS:Edit），并且选择要使用的域名。在 docker-compose.yml 同一层文件夹里创建一个 .env 文件 CLOUDFLARE_API_TOKEN = your token 然后修改文件权限，只允许本用户读写。 chmod 600 .env 编写 Caddyfile 文件在 docker-compose.yml 同一层文件夹里，创建一个 Caddyfile 文件 caddy.luojiyin.top { tls { dns cloudflare {env.CLOUDFLARE_API_TOKEN} } respond / \"Hello, world! This is a static response from Caddy.\" 200 } Caddy 直接输出一个静态页面，验证签发是否成功。 完整的 Docker compose 文件version: \"3.7\" networks: caddy: name: caddy services: caddy: container_name: caddy build: context: . dockerfile: Dockerfile ports: - \"80:80\" # Remember that Caddy does HTTP to HTTPS redirections automatically. - \"443:443\" environment: - CADDY_INGRESS_NETWORK=caddy # If you don't want to write your token here, remember that Docker Compose picks up # variables from an .env file if present in the same directory as the compose file. - CLOUDFLARE_API_TOKEN=${CLOUDFLARE_API_TOKEN} networks: - caddy volumes: - \"/var/run/docker.sock:/var/run/docker.sock\" # It is important to have these to conserve data after the container restarts - \"./data:/data\" # Unless we want to SSH to our server every time it restarts. - \"./config:/config\" - \"./Caddyfile:/etc/caddy/Caddyfile\" restart: unless-stopped 完整的文件夹目录 ├── Caddyfile ├── config │ └── caddy [error opening dir] ├── data │ └── caddy [error opening dir] ├── docker-compose.yml └── Dockerfile 启动服务 docker compose up 没加 -d , 第一次启动查看日志， 会读取 Dockerfile 文件构建镜像，加入 CloudFlare 插件， 从 .env 文件 获取 CLOUDFLARE_API_TOKEN 。 caddy | {\"level\":\"info\",\"ts\":1715595177.3236513,\"logger\":\"tls.obtain\",\"msg\":\"obtaining certificate\",\"identifier\":\"caddy.luojiyin.top\"} caddy | {\"level\":\"info\",\"ts\":1715595177.32397,\"logger\":\"tls\",\"msg\":\"finished cleaning storage units\"} caddy | {\"level\":\"info\",\"ts\":1715595179.2300568,\"logger\":\"tls.issuance.acme\",\"msg\":\"waiting on internal rate limiter\",\"identifiers\":[\"caddy.luojiyin.top\"],\"ca\":\"https://acme-v02.api.letsencrypt.org/directory\",\"account\":\"\"} caddy | {\"level\":\"info\",\"ts\":1715595179.2301404,\"logger\":\"tls.issuance.acme\",\"msg\":\"done waiting on internal rate limiter\",\"identifiers\":[\"caddy.luojiyin.top\"],\"ca\":\"https://acme-v02.api.letsencrypt.org/directory\",\"account\":\"\"} caddy | {\"level\":\"info\",\"ts\":1715595180.2085311,\"logger\":\"tls.issuance.acme.acme_client\",\"msg\":\"trying to solve challenge\",\"identifier\":\"caddy.luojiyin.top\",\"challenge_type\":\"dns-01\",\"ca\":\"https://acme-v02.api.letsencrypt.org/directory\"} caddy | {\"level\":\"info\",\"ts\":1715595197.6058002,\"logger\":\"tls.issuance.acme.acme_client\",\"msg\":\"authorization finalized\",\"identifier\":\"caddy.luojiyin.top\",\"authz_status\":\"valid\"} caddy | {\"level\":\"info\",\"ts\":1715595197.605848,\"logger\":\"tls.issuance.acme.acme_client\",\"msg\":\"validations succeeded; finalizing order\",\"order\":\"https://acme-v02.api.letsencrypt.org/acme/order/1723709497/269014373307\"} caddy | {\"level\":\"info\",\"ts\":1715595199.1746569,\"logger\":\"tls.issuance.acme.acme_client\",\"msg\":\"successfully downloaded available certificate chains\",\"count\":2,\"first_url\":\"https://acme-v02.api.letsencrypt.org/acme/cert/049f29c5f90a9c14bd9acdb84ff4ab90af77\"} caddy | {\"level\":\"info\",\"ts\":1715595199.176429,\"logger\":\"tls.obtain\",\"msg\":\"certificate obtained successfully\",\"identifier\":\"caddy.luojiyin.top\"} caddy | {\"level\":\"info\",\"ts\":1715595199.1766984,\"logger\":\"tls.obtain\",\"msg\":\"releasing lock\",\"identifier\":\"caddy.luojiyin.top\"} 没有报错信息， 基本成功了。 配置内网 DNS 配置内网域名解析 打开浏览器验证 总结一图胜千言 是不是比用 Nginx 简单多了。","link":"/article/engineering/using-caddy-and-cloudflare-to-issue-wildcards-on-private-networks/"},{"title":"JavaScript 效率工具","text":"每当看到发在 FCC 成都社区群里的技术文章，水歌都忍不住去指出它的不足。 今天评注的文章题为《一批提升你工作效率的 JS 工具方法》，文中的 60 个方法与上次评注的“24 个 ES 方法”类似，不够简洁、优雅，与最新 ECMAScript、DOM 标准有些差距，有些“复制粘贴老文章片段”的感觉。 接下来，我就按功能类别来对一些有必要优化的工具方法一一重构。 数据校验完全基于正则表达式的检验规则其实可以不用封装成函数，全放在独立的模块中，导入后直接 /regexp/.test(data) 即可。 电邮地址export const Email = /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/; // 原文：/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/ 「注解」 \\w 即为 [a-zA-Z0-9_] [] 表示一个字符范围，就是一个整体，无需 () 包围 Gmail 等服务商还支持形如 name.filter@gmail.com 这样的用户别名邮箱 (.[a-zA-Z0-9_-]{2,3}){1,2} 只适用于前些年常见的 .cn、.com.cn 一类根域名，近几年新增的 .name、.info、.club、.camp 等域名就失效了，形如 vip.xxmail.com 的多级域名也不适用 手机号码其实以下只适用于中国大陆手机号，其它国家手机号似乎与固定电话号之间没有明显的区分。 export const Mobile = /^1[3-9]\\d{9}$/; // 原文：/^1[0-9]{10}$/ 「注解」 \\d 即为 [0-9] 中国大陆手机号第二位目前没有 1、2 固话号码中国大陆固定电话号码“区号 + 机号”始终为 11 位。 export const Phone = /^((0\\d{2}-)?\\d{8}|(0\\d{3}-)?\\d{7})$/; // 原文：/^([0-9]{3,4}-)?[0-9]{7,8}$/ 网址export const URL = /^\\w+:\\/\\/\\S+$/; // 原文：/^http[s]?:\\/\\/.*/ 「注解」 URL 协议不仅包括 http、https，还有 ftp（文件传输）、file（本机文件系统）、ed2k（电驴 2000）等各种各样的网络协议 URL 主机名、路径可以是 Unicode 中各种可见字符，但遇到空白符就结束 日期格式判断是否为合法的日期格式除了用正则之外，还可利用 Date 构造函数内部的算法： export const isDate = raw =&gt; !isNaN(+new Date(raw)); 对于无法解析为日期的数据，date.toString() 会返回“Invalid Date”，date.getTime() 对应的返回值则是 NaN。而算数运算符会调用对象的 valueOf() 方法，date.valueOf() 的返回值又与 date.getTime() 相同。 汉字“汉字”在计算机领域的学名叫中日韩统一表意文字（俗称 CJK），在 2017 年 6 月发布的 Unicode 10 标准中，它有了代码级明确的指代： export const HanZi = /\\p{Unified_Ideograph}/u; 【详情参考】 最佳实践 学习：正则分析器 RegExr、Regex101 前端：HTML 5 表单校验 API 后端：基于装饰器的数据校验 数据转换阿拉伯数字转中文ECMA-402 标准（ECMAScript 国际化 API）把各语言之间的数据格式转换算法都封装好了，我们引入 polyfill 就可以直接用： export const toChineseNumber = raw =&gt; new Intl.NumberFormat(\"zh-Hans-u-nu-hanidec\").format(raw); 数据类型判断一个值的类型，用比较构造函数名或类名的方式兼容性比较差，因为线上环境通常是压缩后的代码，自定义的函数名、类名不再是原名，应用开发者一般也不会实现 Symbol.toStringTag getter 类成员，导致 Object.prototype.toString.call() 只会返回默认值 [object Object]。 JavaScript综上，我们应该利用 JavaScript 原型继承，来统一判断“值的类型归属”： export const isType = (value, constructor) =&gt; Object(value) instanceof constructor; 「注解」 Object 构造函数会返回所有基本值的包装对象 TypeScript下面，我再给出一个 TypeScript 的实现，让类型推断更加准确： export function isType&lt;T&gt;( value: T, constructor: { new (...data: any[]): T } ): value is T { return Object(value) instanceof constructor; } import { isType } from \"./utility\"; let test; if (isType(test, Number)) console.log(test!.toFixed(2)); 【在编辑器中体验 TS 类型提示】 浏览器检测以下使用 globalThis 是为了兼容浏览器主线程、Web Worker、Node.js、Deno 等不同 JavaScript 运行时环境。 品牌export const isBrowserVendor = ( name, UA = globalThis.navigator?.userAgent || \"\" ) =&gt; UA.toLowerCase().includes(name); 爬虫export const isRobot = (UA = globalThis.navigator?.userAgent || \"\") =&gt; /bot|spider|crawler/i.test(UA); 去除 HTML 标签正则表达式以下使用了 non-greedy（非贪婪模式）来提升性能，并规避正文中可能出现的示例代码没完全转译尖括号，导致删除错误。 export const removeHtmlTag = raw =&gt; raw.replace(/&lt;[\\s\\S]+?&gt;/g, \"\"); DOM API下面再提供一种借助 DOM 引擎的实现： const box = document.createElement(\"template\"); export function removeHtmlTag(raw) { box.innerHTML = raw; return box.content.textContent; } URL 参数追加URL()、URLSearchParams() 在浏览器主线程、Web Worker、Node.js 10+、Deno 均全局可用。 export function appendQuery(path, data, base = globalThis.location.href) { const URI = new URL(path, base); const { searchParams } = URI; for (const key in data) searchParams.append(key, data[key]); return URI + \"\"; } W3C、ECMA 标准还有一些可以用新标准（部分为提案）直接实现的特性，集中罗列如下： .trim()、.trimStart()、.trimEnd()（原文第 53 条） .includes()（原文第 42 条） Array.from()（原文第 48 条） 数组去重（原文第 44 条） 动态 import（原文第 27 条） element.classList（原文第 29 ~ 31 条） saveAs()（原文第 28 条） text-transform（原文第 54 条） 开源库 水歌把日常开发中积累的各种工具方法，用 TypeScript 写成一个 Web 开源工具库 —— https://web-cell.dev/web-utility/ ，欢迎大家使用、改进！~","link":"/article/engineering/javascript-efficiency-utility/"},{"title":"【2019 成都 Web 全栈大会】参会指南","text":"本届大会秉持程序员自主办会的宗旨，努力从各方面用编程解决问题。 FCC 成都社区坚信 —— 主办方自身紧跟技术潮流，才能让参会者为之信服！ 【时间】2019 年 11 月 16 ~ 17 日 09:00 ~ 18:00 【地点】成都市高新区天府五街 菁蓉国际广场 7 号楼主会场 【议程】https://web-conf.dev/#2019/ 【报名】http://fcc-chengdu.mikecrm.com/7pG2aOh 大会 App本届大会筹办期间，水歌把整个大会官网用自研的 WebCell v2 重写之外，还把它升级为一个 PWA（渐进式 Web 应用），可直接安装在 Android、Windows、iOS 的桌面上，并支持离线缓存，随时随地查看大会议程！ 下面以 Google Chrome 举个栗子，Firefox、Edge、UC 浏览器、小米手机浏览器、Safari 等均有不同形式、程度的支持： 访问大会官网，自动提示安装 点击提示后，确认安装 稍后即可在桌面看到图标 （Chrome 在国产 Android 上有时较慢，请耐心等待，或刷新重试） App 启动界面 邀请函 从本届大会主页导航栏进入邀请函页面 用买票人手机号登录 （刚买票的数据更新有延迟，请稍候再试） 登录成功自动显示邀请函 长按保存、分享图片 会场导航 大会 App 内嵌高德导航","link":"/article/propaganda/web-conf-2019-guide/"},{"title":"webpack 打包文件分析（上）","text":"前言webpack 是一个用于静态资源打包的工具。它分析你的项目结构，会递归的构建依赖关系，找到其中脚本、图片、样式等将其转换和打包输出为浏览器能识别的资源。 本篇文章仅对 webpack 打包输出的文件进行简要的分析。 项目准备项目地址 看一下几个关键文件： 依赖文件 src/foo.js module.exports = \"foo\"; 入口文件 src/index.js const foo = require(\"./foo.js\"); console.log(foo); webpack 配置文件 webpack.config.js const path = require(\"path\"); module.exports = { mode: \"development\", // 标识不同的环境，development 开发 | production 生产 devtool: \"none\", // 不生成 source map 文件 entry: \"./src/index.js\", // 文件入口 output: { path: path.resolve(__dirname, \"dist\"), // 输出目录 filename: \"bundle.js\" // 输出文件名称 } }; bundle 分析首先放上打包输出文件 dist/bundle.js (function (modules) { // 模块缓存对象 var installedModules = {}; function __webpack_require__(moduleId) { if (installedModules[moduleId]) { return installedModules[moduleId].exports; } // 创建一个新的模块对象 var module = (installedModules[moduleId] = { i: moduleId, // 模块id，即模块所在的路径 l: false, // 该模块是否已经加载过了 exports: {} // 导出对象 }); modules[moduleId].call( module.exports, module, module.exports, __webpack_require__ ); // 标识模块已经加载过了 module.l = true; return module.exports; } // 该属性用于公开modules对象 (__webpack_modules__) __webpack_require__.m = modules; // 该属性用于公开模块缓存对象 __webpack_require__.c = installedModules; // 该属性用于定义兼容各种模块规范输出的getter函数，d即Object.defineProperty __webpack_require__.d = function (exports, name, getter) { if (!__webpack_require__.o(exports, name)) { Object.defineProperty(exports, name, { enumerable: true, get: getter }); } }; // 该属性用于在导出对象exports上定义 __esModule = true，表示该模块是一个 ES 6 模块 __webpack_require__.r = function (exports) { // 定义这种模块的Symbol.toStringTag为 [object Module] if (typeof Symbol !== \"undefined\" &amp;&amp; Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" }); } Object.defineProperty(exports, \"__esModule\", { value: true }); }; // 创建一个命名空间对象 // mode &amp; 1: 传入的value为模块id，使用__webpack_require__加载该模块 // mode &amp; 2: 将传入的value的所有的属性都合并到ns对象上 // mode &amp; 4: 当ns对象已经存在时，直接返回value。表示该模块已经被包装过了 // mode &amp; 8|1: 行为类似于require __webpack_require__.t = function (value, mode) { if (mode &amp; 1) value = __webpack_require__(value); if (mode &amp; 8) return value; if (mode &amp; 4 &amp;&amp; typeof value === \"object\" &amp;&amp; value &amp;&amp; value.__esModule) return value; // 创建一个命名空间对象 var ns = Object.create(null); // 将ns对象标识为es模块 __webpack_require__.r(ns); // 给ns对象定义default属性，值为传入的value Object.defineProperty(ns, \"default\", { enumerable: true, value: value }); if (mode &amp; 2 &amp;&amp; typeof value != \"string\") for (var key in value) __webpack_require__.d( ns, key, function (key) { return value[key]; }.bind(null, key) ); return ns; }; // 获取模块的默认导出对象，这里区分 CommonJS 和 ES module 两种方式 __webpack_require__.n = function (module) { var getter = module &amp;&amp; module.__esModule ? function getDefault() { return module[\"default\"]; } : function getModuleExports() { return module; }; __webpack_require__.d(getter, \"a\", getter); return getter; }; // 该属性用于判断对象自身属性中是否具有指定的属性，o即Object.prototype.hasOwnProperty __webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; // 该属性用于存放公共访问路径，默认为'' (__webpack_public_path__) __webpack_require__.p = \"\"; // 加载入口模块并返回模块的导出对象 return __webpack_require__((__webpack_require__.s = \"./src/index.js\")); })({ \"./src/foo.js\": function (module, exports) { module.exports = \"foo\"; }, \"./src/index.js\": function (module, exports, __webpack_require__) { const foo = __webpack_require__(\"./src/foo.js\"); console.log(foo); } }); 根据上面的源码可以看出，最终打包出的是一个自执行函数。 首先，这个自执行函数它接收一个参数 modules，modules为一个对象，其中 key 为打包的模块文件的路径，对应的 value 为一个函数，其内部为模块文件定义的内容。 然后，我们再来看一看自执行函数的函数体部分。函数体返回 __webpack_require__(__webpack_require__.s = \"./src/index.js\") 这段代码，此处为加载入口模块并返回模块的导出对象。 可以发现，webpack 自己实现了一套加载机制，即 __webpack_require__，可以在浏览器中使用。该方法接收一个 moduleId，返回当前模块的导出对象。 webpack 文件加载 (__webpack_require__)var installedModules = {}; function __webpack_require__(moduleId) { if (installedModules[moduleId]) { return installedModules[moduleId].exports; } var module = (installedModules[moduleId] = { i: moduleId, l: false, exports: {} }); modules[moduleId].call( module.exports, module, module.exports, __webpack_require__ ); module.l = true; return module.exports; } // ... 首先，当前作用域顶端声明了 installedModules 这个对象，它用于缓存加载过的模块。在 __webpack_require__ 方法内部，会对于传入的 moduleId 在缓存对象中查找对应的模块是否存在，如果已经存在，返回该模块对象的导出对象；否则，创建一个新的模块对象，记录当前模块 id、标识模块是否加载过、以及定义导出对象，同时将它放到缓存对象中。 接下来就是重要的一步，执行模块的函数内容，传入 module、module.exports 及 __webpack_require__ 作为参数。 modules[moduleId].call( module.exports, module, module.exports, __webpack_require__ ); 也就是去执行自执行函数传入的 modules 对象中当前 moduleId 对应的函数。接着将该模块标识为已经加载的状态，最后返回当前模块的导出对象。此时便完成了模块的加载任务。 接着，再来看看传入的 modules 对象部分。 ({ \"./src/foo.js\": function (module, exports) { module.exports = \"foo\"; }, \"./src/index.js\": function (module, exports, __webpack_require__) { const foo = __webpack_require__(\"./src/foo.js\"); console.log(foo); } }); 观察函数体内容，可以看到对于依赖模块 foo.js 而言，函数体内即为 foo.js 文件中的定义内容。而对于入口模块 index.js，则需要执行 __webpack_require__ 方法将依赖的文件加载进来使用。 那么，到此为止，我们已经明白了 webpack 加载模块的基本原理。但细心的你一定发现了，我们的文件导入导出遵循的是 CommonJS 规范，而 webpack 是基于 Node.js 实现的，所以在文件加载部分并没有特别的处理。因此，这里我们来看看不同模块规范相互加载时，webpack 是如何处理的。 harmony（和谐，即对于不同模块规范加载的一个兼容处理） CommonJS 加载 CommonJS 这种方式即我们上面示例的加载方式，就不做赘述了。 CommonJS 加载 ES modulesrc/foo.js export default \"foo\"; src/index.js const foo = require(\"./foo.js\"); console.log(foo); dist/bundle.js ({ \"./src/foo.js\": function (module, __webpack_exports__, __webpack_require__) { __webpack_require__.r(__webpack_exports__); __webpack_exports__[\"default\"] = \"foo\"; }, \"./src/index.js\": function (module, exports, __webpack_require__) { const foo = __webpack_require__(\"./src/foo.js\"); console.log(foo); } }); 由打包后的源码可以发现，当 foo.js 使用 ES module 方式导出，与之前的相比，多了 __webpack_require__.r(__webpack_exports__)这段代码，__webpack_exports__ 很好理解，即模块的导出对象。那么，__webpack_require__.r 方法是干嘛的呢？ // ... __webpack_require__.r = function (exports) { if (typeof Symbol !== \"undefined\" &amp;&amp; Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" }); } Object.defineProperty(exports, \"__esModule\", { value: true }); }; // ... 根据其实现可知，该方法将传入的对象标识上 __esModule=true，即表明该模块为 ES 6 模块。同时定义该对象的 Symbol.toStringTag 为 Module，即当使用 Object.prototype.toString.call 时将返回 [object Module]。 最后，将模块的内容挂在 __webpack_exports__ 的 default 属性上。 ES module 加载 ES modulesrc/foo.js export default \"foo\"; src/index.js import foo from \"./foo.js\"; console.log(foo); dist/bundle.js ({ \"./src/foo.js\": function (module, __webpack_exports__, __webpack_require__) { __webpack_require__.r(__webpack_exports__); __webpack_exports__[\"default\"] = \"foo\"; }, \"./src/index.js\": function ( module, __webpack_exports__, __webpack_require__ ) { __webpack_require__.r(__webpack_exports__); var _foo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( \"./src/foo.js\" ); console.log(_foo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]); } }); 当入口文件 index.js 和依赖文件 foo.js 都遵循 ES module 的方式时，可以发现在 index.js 中，对于获取导出对象的方式也有所不同。_foo_js__WEBPACK_IMPORTED_MODULE_0__ 用来接收导入的文件，并通过 default 属性获取到文件的默认导出内容。 那么，是如何实现这种方式的呢？ // ... __webpack_require__.d = function (exports, name, getter) { if (!__webpack_require__.o(exports, name)) { Object.defineProperty(exports, name, { enumerable: true, get: getter }); } }; // ... __webpack_require__.n = function (module) { var getter = module &amp;&amp; module.__esModule ? function getDefault() { return module[\"default\"]; } : function getModuleExports() { return module; }; __webpack_require__.d(getter, \"a\", getter); return getter; }; __webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; // ... 分析这几个方法可以发现，__webpack_require__.o 其实就是 Object.prototype.hasOwnProperty 的一个重写，用于判断对象自身属性中是否具有指定的属性。而 __webpack_require__.d 即 Object.defineProperty，这里用于定义兼容各种模块规范输出的 getter 函数。__webpack_require__.n 则是用于获取模块的默认导出对象，兼容 CommonJS 和 ES module 两种方式。 ES module 加载 CommonJSsrc/foo.js module.exports = \"foo\"; src/index.js import foo from \"./foo.js\"; console.log(foo); dist/bundle.js ({ \"./src/foo.js\": function (module, exports) { module.exports = \"foo\"; }, \"./src/index.js\": function ( module, __webpack_exports__, __webpack_require__ ) { __webpack_require__.r(__webpack_exports__); var _foo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( \"./src/foo.js\" ); var _foo_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n( _foo_js__WEBPACK_IMPORTED_MODULE_0__ ); console.log(_foo_js__WEBPACK_IMPORTED_MODULE_0___default.a); } }); 当入口文件 index.js 以 ES module 的方式加载遵循 CommonJS 规范的 foo.js 时，通过 __webpack_require__ 加载传入的模块，将得到的模块 _foo_js__WEBPACK_IMPORTED_MODULE_0__ 再传入 __webpack_require__.n 方法获取到该模块的默认导出对象。因为 foo.js 中的内容是通过 export 导出，而非 export default 导出。因此 foo 被挂在了 default 的一个 a 属性上。 结语webpack 对于不同模块规范的相互加载的处理，我们已经有了基本的了解。但此时我们的文件加载都是同步的，那么文件的异步加载又是怎么样的呢？ 请听下回分解。","link":"/article/engineering/webpack-bundle-analyse-0/"},{"title":"fCC 成都社区 Coffee & Code 周末编程自习室 2025年8月24日","text":"七夕节又要到了，fCC 成都社区的小伙伴将分享自己”用 AI 耗电“的 AI 开源应用开发经验，用实战让大家体会 —— AI 让人回归”做爱做的事“本身~ 活动信息 时间：2025-08-24 14:00~18:00 地点：漫咖啡 MAAN COFFEE(红唐店)，四川省成都市武侯区天府大道中段中 1388 号红唐购物中心 1 层 LA104 人群：编程初学者、开源爱好者、AI 从业者 费用：参会免费、餐饮自费 文档： https://open-source-bazaar.feishu.cn/wiki/DwnvwaAyWidJDakTUiecH8mDnEh 直播: https://vc.feishu.cn/j/482033714 群聊: https://applink.feishu.cn/client/chat/chatter/add_by_link?link_token=0dcqe9e3-5f27-4d5d-a30c-0477b64c828b 活动内容 🦉 新项目发布：Tickeye - 轻量股指监测工具 🚨 每天在股市下跌的警报中起床 @dethan3 https://github.com/dethan3/tickeyeTickeye 是一款轻量的全球市场指数监控工具，灵感来自 fCC 成都社区深夜自习室。有了想法之后，说干就干，用最传统的 AI 编辑器一个晚上就有了原型，之后又断断续续优化了两周，才成了现在的模样。过程中几乎处处有 AI 的影子，连飞书开放平台也有 AI 助手给方案，算是一次挺有趣的探索，也是我的第一款 Vibe Coding 产品。技术栈：Python + AKShare API 从部署 Tickeye 窥见 Vibe Coding @hu-qi 以 Github Action 定时执行会延迟的“痛点”作为切入点，从 Python 部署遇到依赖包困境，到探索 Docker 容器化部署的 Serverless 技术实践过程，梳理 Vibe Coding 在实际开发中的应用价值。 🚀开放会务系统（全栈开源版）开发重启 @TechQuery @TechQuery 基于 GitHub copilot agent 用 6 天写完了开源社 6 年写不完的前端代码。 💻 结对编程 https://github.com/FreeCodeCamp-Chengdu https://github.com/Open-Source-Bazaar","link":"/activity/salon/fcc-chengdu-coffee-and-code-2025-08-24/"},{"title":"webpack 打包文件分析（下）","text":"回顾上一篇webpack 打包文件分析（上）我们讲到 webpack 打包源码中文件加载的部分，通过分析了解了在 webpack 中不同模块规范相互加载的处理。而至此，只包括了文件的同步加载分析，对于文件的异步加载又是如何处理的呢？ 我们使用 webpack 将项目打包为一个 bundle.js 文件，通过 script 标签插入到页面中引用。但如果这个 bundle.js 体积特别大，就会导致我们加载时间过长，阻塞页面的渲染。 其次，这个打包出来的 bundle.js 中其实部分的代码资源是当前加载页面用不到的，这样也导致了浪费。于是，资源加载的优化就成了必须要考虑的问题，而异步加载（或者说动态加载）就是解决这个问题的方案之一。 异步加载在 webpack 中提供了符合 ECMAScript 的 import() 语法，允许我们动态的加载模块。（在 webpack 版本较低时，我们使用的代码动态加载方案是 require.ensure 方法，后面已经被 import() 取代）。 那么接下来，就继续探究一下异步加载的实现。 关键文件 src/foo.js export default \"foo\"; src/index.js // /* webpackChunkName: \"foo\"*/: 魔法字符串，设置打包后的chunk名 import(/* webpackChunkName: \"foo\" */ \"./foo\").then(foo =&gt; { console.log(foo); }); webpack.config.js // ... output: { path: path.resolve(__dirname, 'dist'), // 输出目录 filename: '[name].bundle.js', // 输出文件名称 }, // ... bundle 分析打包后输出两个文件： foo.bundle.js 因为是异步加载的方式，单独打包为一个文件。由于打包后的源码内容过长，这里省略部分已经分析过的代码块。 index.bundle.js (function (modules) { function webpackJsonpCallback(data) { // ... } /** * 该对象用于存储已经加载和正在加载中的chunks * undefined：表示chunk未加载 * null：表示chunk预加载 / 预获取 * Promise：表示chunk正在加载中 * 0: 表示chunk已经加载了 */ var installedChunks = { index: 0 // 默认入口模块已经加载完毕 }; function __webpack_require__(moduleId) { // ... } // 设置加载chunk的脚本路径 此处的 __webpack_require__.p 为 publicPath，默认为\"\" function jsonpScriptSrc(chunkId) { return ( __webpack_require__.p + \"\" + ({ foo: \"foo\" }[chunkId] || chunkId) + \".bundle.js\" ); } // ... // 作用：懒加载代码块，原理使用 JSONP __webpack_require__.e = function requireEnsure(chunkId) { var promises = []; // ... return Promise.all(promises); }; // ... // 异步加载时触发的错误函数 __webpack_require__.oe = function (err) { console.error(err); throw err; }; // 存储的是传入的chunk var jsonpArray = (window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []); // 存储旧的 jsonpArray.push 方法 var oldJsonpFunction = jsonpArray.push.bind(jsonpArray); // 用 webpackJsonpCallback 覆盖 jsonpArray.push 方法 jsonpArray.push = webpackJsonpCallback; jsonpArray = jsonpArray.slice(); for (var i = 0; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]); var parentJsonpFunction = oldJsonpFunction; // __webpack_require__.s 用于缓存入口模块id return __webpack_require__((__webpack_require__.s = \"./src/index.js\")); })({ \"./src/index.js\": function (module, exports, __webpack_require__) { // 异步加载 foo __webpack_require__ .e(\"foo\") .then(__webpack_require__.bind(null, \"./src/foo.js\")) .then(foo =&gt; { console.log(foo); }); } }); foo.bundle.js // [[这里存chunk的名称], {这个对象是存放chunk路径及chunk内容定义的键值对}] (window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([ [\"foo\"], { \"./src/foo.js\": function ( module, __webpack_exports__, __webpack_require__ ) { \"use strict\"; // 将模块标识为 ES Module __webpack_require__.r(__webpack_exports__); // 将函数内容定义挂在 default 上 __webpack_exports__[\"default\"] = \"foo\"; } } ]); 可以看出，对于同步加载的部分（index.js），依然是使用 __webpack_require__ 来进行加载的，这里不做赘述。 观察 index.js 中对于 foo.js 的加载可以发现，使用到了 __webpack_require__.e 方法，该方法接收 chunkName，返回一个 promise，再传入 chunk 的路径，通过 __webpack_require__ 加载 chunk 的内容，最后输出。 那么关键点就是 __webpack_require__.e 这个方法了。 __webpack_require__.e = function requireEnsure(chunkId) { var promises = []; // 获取加载的chunk内容 var installedChunkData = installedChunks[chunkId]; if (installedChunkData !== 0) { // 0 表示已经加载过了 // Promise 意味着 chunk 正在加载 if (installedChunkData) { promises.push(installedChunkData[2]); } else { // 在chunk缓存中设置 Promise var promise = new Promise(function (resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; }); // 此时 installedChunkData = [resolve, reject, promise] promises.push((installedChunkData[2] = promise)); // 开始加载chunk，jsonp方式 var script = document.createElement(\"script\"); var onScriptComplete; script.charset = \"utf-8\"; // 设置字符集 script.timeout = 120; // 和CSP相关 if (__webpack_require__.nc) { script.setAttribute(\"nonce\", __webpack_require__.nc); } // 设置脚本的加载路径 script.src = jsonpScriptSrc(chunkId); // 脚本加载完成、超时、出错的事件处理函数 var error = new Error(); onScriptComplete = function (event) { // 避免IE内存泄漏 script.onerror = script.onload = null; clearTimeout(timeout); var chunk = installedChunks[chunkId]; if (chunk !== 0) { if (chunk) { var errorType = event &amp;&amp; (event.type === \"load\" ? \"missing\" : event.type); var realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src; error.message = \"Loading chunk \" + chunkId + \" failed.\\n(\" + errorType + \": \" + realSrc + \")\"; error.name = \"ChunkLoadError\"; error.type = errorType; error.request = realSrc; chunk[1](error); } installedChunks[chunkId] = undefined; } }; var timeout = setTimeout(function () { onScriptComplete({ type: \"timeout\", target: script }); }, 120000); script.onerror = script.onload = onScriptComplete; document.head.appendChild(script); } } return Promise.all(promises); }; 分析这个方法，它的核心作用就是异步加载的实现。 获取传入的 chunkName 在 installedChunks 对象中对应的加载状态，如果状态为非加载完成，则构造一个 promise，将它的 resolve、reject 作为该 chunk 的正在加载状态，并存入到 promises 中。 创建 script 标签，将 chunk 的路径作为脚本的加载路径，然后插入到页面的 &lt;head&gt; 中，让浏览器去下载这个 chunk。 最后返回 promises 的执行结果，让所有的 promise 都变为完成态，即完成所有 chunk 的加载。 接着再来看 foo.bundle.js，整个代码体的目的是在向 window.webpackJsonp 中 push 一个数组，这个数组的结构为 [[\"chunk的名字\"], { \"chunk的路径\": function(){ chunk的内容定义 }}] 。 回到 index.bundle.js 中我们可以找到关于 window.webpackJsonp 的相关定义及使用。 var jsonpArray = (window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []); // 存储旧的 jsonpArray.push 方法 var oldJsonpFunction = jsonpArray.push.bind(jsonpArray); // 用 webpackJsonpCallback 覆盖 jsonpArray.push 方法 jsonpArray.push = webpackJsonpCallback; jsonpArray = jsonpArray.slice(); // 依次调用 webpackJsonpCallback for (var i = 0; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]); // 缓存上一次的jsonpArray.push方法，形成链条，将模块共享挂载，起到缓存的作用。 var parentJsonpFunction = oldJsonpFunction; 这里用 webpackJsonpCallback 覆盖了 window.webpackJson 的 push 方法，也就是说，在 foo.bundle.js 中其实是调用了 webpackJsonpCallback 方法。 那么，这个 webpackJsonpCallback 方法究竟又做了什么呢？ function webpackJsonpCallback(data) { var chunkIds = data[0]; // 对应加载的chunk的名称的数组 var moreModules = data[1]; // 对应加载的chunk的路径和chunk定义组成的对象 var moduleId, chunkId, i = 0, resolves = []; for (; i &lt; chunkIds.length; i++) { chunkId = chunkIds[i]; if ( Object.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp; installedChunks[chunkId] ) { resolves.push(installedChunks[chunkId][0]); // 收集所有的resolve } installedChunks[chunkId] = 0; // 标识chunk加载完毕 } // 让modules中包含同步和异步加载的所有模块 for (moduleId in moreModules) { if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) { modules[moduleId] = moreModules[moduleId]; // 将异步加载的chunk添加到 modules 对象中 } } if (parentJsonpFunction) parentJsonpFunction(data); while (resolves.length) { resolves.shift()(); // 依次执行resolve，将所有的promise变为完成态 } } 根据代码内容分析，该方法 首先，判断异步加载的 chunk 是否已经完成加载，如果还在加载中就收集所有 promise 的 resolve方法，接着在 installedChunks 对象中标记 chunk 为加载完成状态 然后，再把这些 chunk 都添加到 modules 对象中，这样就可通过 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__) 来同步加载 chunk，也就是 foo.bundle.js 中第一个 then 执行的内容，传入模块的路径，使用 __webpack_require__ 进行同步加载。 最后，依次执行收集的 promise 的 resolve 回调，将所有的 promise 变为完成态。 到此，异步加载原理我们就有了一个基本的了解了。 补充源码中还有部分的方法因为没有用到，所以没有做具体的分析。其中 __webpack_require__.t 这个方法很有必要提一下。 这个方法会在异步加载中用到，比如，foo.js 是 CommonJS 规范的内容。 module.exports = \"foo\"; 这个时候打包出来的入口文件中就可以看到 __webpack_require__.t 的身影。 ({ \"./src/index.js\": function (module, exports, __webpack_require__) { __webpack_require__ .e(\"foo\") .then(__webpack_require__.t.bind(null, \"./src/foo.js\", 7)) .then(foo =&gt; { console.log(foo); }); } }); 该方法传入模块的路径，以及一个数字 7，作用当然也是为了加载模块内容。但它和 __webpack_require__ 相比究竟有什么区别呢？ __webpack_require__.t = function (value, mode) { if (mode &amp; 1) value = __webpack_require__(value); if (mode &amp; 8) return value; if (mode &amp; 4 &amp;&amp; typeof value === \"object\" &amp;&amp; value &amp;&amp; value.__esModule) return value; // 创建一个命名空间对象 var ns = Object.create(null); // 将ns对象标识为 ES 模块 __webpack_require__.r(ns); // 给ns对象定义default属性，值为传入的value Object.defineProperty(ns, \"default\", { enumerable: true, value: value }); if (mode &amp; 2 &amp;&amp; typeof value != \"string\") for (var key in value) __webpack_require__.d( ns, key, function (key) { return value[key]; }.bind(null, key) ); return ns; }; 分析源码可以发现，该方法最终返回一个命名空间对象，接收的第二个参数是个数字，它接下来与 1，2，4，8 进行了按位与操作。想必你已经很快联想到了二进制吧，没错，这几个数字正是对应 0b0001、0b0010、0b0100、0b1000 这几个二进制数。为什么要用数字呢？当然是为了提高运算比较的效率。 回到正题，该方法通过传入的第二个参数进行了以下处理。 当 mode &amp; 1 为true，表示传入的value是一个模块 id，需要使用 __webpack_require__来加载模块内容 当 mode &amp; 2 为true，首先构造了一个 ns 的命名空间对象，将该对象传入 __webpack_require__.r 方法中，被标识为一个 ES Module （即拥有__esModule属性）。接着定义 ns 对象的 default 属性，并将传入的 value 挂上去作为该对象的值。然后遍历传入的 value，将它的属性和值都拷贝定义到 ns 上 当 mode &amp; 4 为true，并且传入的 value 是个对象且拥有__esModule属性（表示已经是或者已经被包装为 ES Module 了），则直接返回这个 value 对象 当 mode &amp; 8 为true，其行为等同于 require，直接返回 value 即可 结语简单总结一下，为了减少打包的体积，去掉非必要资源加载的浪费，我们需要异步加载方案来优化资源的加载。简单说，就是在需要用到某个文件的时候，通过 import() 引入这个文件，在返回的 promise 的 then 中去获取文件内容，以达到动态加载的目的。当然，这并不是唯一的方法，webpack 还提供了代码分割方案，也可以达到加载优化的效果。","link":"/article/engineering/webpack-bundle-analyse-1/"},{"title":"【直播】志愿者贡献平台 PWA 开发实战","text":"【时间】2020 年 9 月 27 日（周日）19:00 ~ 21:00 本次沙龙将为大家直播基于 Headless CMS、Web 标准组件、PWA 和 TypeScript 开发志愿者贡献平台。 入门概念 Headless CMS Web Components 生成项目 Strapiyarn create strapi-app my-project --quickstart WebCell 开发项目 数据结构 任务 Task 贡献 Contribution 评价 Evaluation 后端难点 OAuth 登录 OSS 文件上传 富文本编辑器 API 文档生成","link":"/activity/salon/webcell-strapi-quick-start/"},{"title":"【2019 成都 Web 全栈大会】大咖特辑","text":"今年成都 Web 全栈大会前两波宣传发出去后，有小姐姐私聊我说：XX 讲师小哥哥好帅，好想…… 当面深入交流…… 编程技术！ 那今天我就先带大家预习一下部分讲师的小档案，方便粉丝们现场勾搭有备无患，哈哈~ 对了，记得先买票再上车哦~ 【时间】2019 年 11 月 16 ~ 17 日 09:00 ~ 18:00 【地点】成都市高新区天府五街 菁蓉国际广场 7 号楼主会场 【议程】https://web-conf.dev/#2019/ 【报名】http://fcc-chengdu.mikecrm.com/7pG2aOh 贺师俊 —— 写了 20 年前端的男人一听贺老要来，FCC 成都社区的一位小姐姐激动不已，自告奋勇要当贺老的书童，即兴赋诗一首 —— 今有大佬来蓉分享，穿过大山越过小巷。前排买票一睹风采，堂前一席胜读十书。 贺老从 1998 年 IE 4 时代开始写网页代码，至今身为 TC39、W3C 两个标准委员会的委员，可谓中国 Web 前端界少有的“两院院士”。 自 2008 年 Chrome 发布、2009 年 Node.js 问世，再到 2015 年 ECMAScript 6 出炉，Web 前端标准、生态的发展驶入了高速路，技术标准制定的过程中也有了贺老这样中国程序员的身影。若你浏览一下各项标准提案的 GitHub issue，可以看到很多贺老针砭时弊的话语，可谓一言不合就给你扔一个 SyntaxError！ 语法错误 陈成 —— 阿里 P8，超级奶爸 陈成，网名 sorrycc，花名云谦，阿里巴巴 P8 高级技术专家，毕业于浙江大学，已是两个男孩的爸爸。 2008 年 sorrycc 每个月拿着 4000 块钱在一家小公司打杂，希望老板加薪 500 元，老板都不肯，一气之下加入了阿里，一待就待到现在。前 5 年在淘宝 UED 工作，负责淘宝首页、宝贝详情、购物车和下单等很多重要的前端业务开发，后转岗到支付宝，目前在玉伯带领的蚂蚁金服体验技术部，为现代前端开发输出了源源不断的设计和技术。 截止目前已开源了众多颠覆性的项目，包括不限于： Dva —— 基于 Redux 和 Redux Saga 的数据流解决方案（14K） Umi —— 可插拔的企业级 React 应用框架（6.2K） RoadHog —— 开箱即用的 React 应用开发工具（2.5K） Ant Design —— 中小企业搭建后台管理系统的 React 组件库（53K） 本次有幸请到 sorrycc 大佬来成都参加由 FCC 和 阿里云联合举办的 2019 成都 Web 全栈大会，他将带来 《蚂蚁前端研发最佳实践》主题演讲，主要给大家分享一下蚂蚁前端在语言、CSS、目录结构、路由、数据流、Mock、构建工具、组件开发、测试、性能优化微前端等方面选择的最佳实践，以及最佳实践的迭代、遇到的问题、挑战和他的思考。 慕阳 —— 平凡的铲屎官 慕阳老师，六年开发经验，曾任职美团、人人网，现任华为云高级前端。听到这样的大佬名号，萌新的我真是瑟瑟发抖。直到我看到他发给我的这样一张图片： 没错就是这只自带“眼罩”大懒猫，我才真实的感觉到他也是一个热爱生活的人。他并不是大家想象中的两耳不闻窗外事，一心钻研搞技术的宅男；他也是爱刷抖音、爱跑步，没事撸撸猫、看看电影，外加陪陪女朋友的人。 可能有的同学了解过 Web Components，但实际使用比较多的都是类似于 Vue 或 React 形式的组件。所以大家非常好奇老师将会在这次大会中给我们带来哪些关于 Web Components 的黑科技。 我们已经了解到，老师将以华为云内部复杂的前端业务为背景，结合在实际项目中使用 Web Components 的一些经验，为我们带来一期干货满满的 Web Components 实践分享。希望同学们带好小本本，好好写笔记，一定会有很多收获哦！ 谢扬 —— 互联网之子 谢扬，本届年纪最小的讲师，96 年小鲜肉。他在大二时开发了 Gospel，提供了软件开发的全新解决方案。曾任好东西传送门的 CTO，目前在中国推广万维网之父的 SoLiD 项目，并基于此进行商业化试水。 他活跃于 GitHub，目前自己的创业项目 Authing 已经慢慢浮出水面，受到大家认可。年纪虽小，但是在初中的时候就开始编程，具有很强的编程能力和项目推动能力，十足的领导范儿。 于航 —— 女装真大佬，编码无 bug 本次大会的讲师于航（Jason Yu），除了在多个技术大会上布道之外，平时生活中也是一个极富情调的人，我们都亲切地称呼他为“航妹”。为什么呢？因为他不仅是个极客，还是传说中的“女装大佬”。访问航妹的 Github 个人主页，你就能看到他（她）的女装头像。更有甚者，航妹曾在参与某个开源项目时，被国外开发者误认为是个厉害的妹子。 航妹兴趣广泛。你时常能看到他发一些弹奏钢琴的短视频；也曾在公司组织团队成员练习街舞，参与演出；他甚至还是两只猫主子的铲屎官，一橘一花（其实主要是白色）。 橘猫叫皮卡丘，性子活泼，常常会在航妹准备 coding 之时或趴或蹲在电脑前，一副求关爱的样子。 花猫叫淘淘，性子文静，你如果看不到淘淘，那么不妨去看看航妹的床底。 看到这里，是不是觉得航妹妥妥的小说主角模板啊，有技术，有猫，还多才多艺。 航妹在今年早些时候出版了国内第一本系统介绍 WebAssembly 技术的书《深入浅出 WebAssembly》。WebAssembly 是近年诞生的一门新技术，目前在国内还很少看到相关的应用和实践，这次他来分享 WebAssembly 相关的内容，想了解同学不容错过。 如果你想了解更多关于航妹的事情，可以看看我们之前对他做的一次访谈，FCC DevTalk 002 丨于航：happy coding, happy life，也欢迎大家支持航妹的书《深入浅出 WebAssembly》。","link":"/article/propaganda/web-conf-2019-mentors/"},{"title":"【2019 成都 Web 全栈大会】工作坊特辑","text":"【时间】2019 年 11 月 16 ~ 17 日 09:00 ~ 18:00 【地点】成都市高新区天府五街 菁蓉国际广场 7 号楼主会场 【议程】https://web-conf.dev/#2019/ 【报名】http://fcc-chengdu.mikecrm.com/7pG2aOh 《AALab 算法艺术实验室》 领域 难度 时间 Unity3D 进阶 2019 年 11 月 16 日 14:00 ~ 17:00 即影即有 —— 异形投影与着色器语言。使用 Unity3D 的着色器可视化编程对于造型进行光影重塑，精准投影附着于实体之上。 叶师父 AALab 算法艺术实验室 - 算法工程师 《AWS 工作坊》 领域 难度 时间 DevOps 入门 2019 年 11 月 17 日 10:20 ~ 11:20 通过 Serverless 工作坊，我们将为您介绍如何使用 AWS Lambda、Amazon API Gateway、Amazon DynamoDB、Amazon S3 等服务来构建 Serverless 应用。您将动手开发并部署一个 Serverless 的 Web 应用，并尝试监控、版本管理和灰度发布等内容。 孙华 亚马逊 AWS - 高级解决方案架构师 《极限编程 —— 测试驱动开发（TDD）工作坊》 领域 难度 时间 敏捷开发 入门 2019 年 11 月 17 日 14:00 ~ 17:00 在各种敏捷方法中，极限编程最为重视软件开发技术工程实践。极限编程是唯一将开发技术实践提到核心地位、并围绕开发技术实践构建起完整软件交付流程的敏捷方法论。 缺少可重构性的软件，不可能快速响应变化。 没有高覆盖率、快速运行的单元测试，重构就不可能落地。 测试驱动开发是获得高质量单元测试集的唯一有效方法。 建立在充分覆盖且运行快速的自动化测试基础上的持续集成是迭代式开发的必要条件。 通过工作坊你将获得： 掌握测试驱动开发的基本节奏 任务分解，用测试用例描述沟通需求 编写失败的测试，驱动产品代码 精准框定需求范围，持续实践重构 受用终身的测试驱动开发方法论 打好程序员基本功、改善工作方式，提高十倍工作效率。 吕靖 中国极限编程社群 - Web 前端工程师","link":"/article/propaganda/web-conf-2019-workshop/"},{"title":"2019 成都 Web 全栈大会","text":"2019 成都 Web 全栈大会 2017-11-19 —— 成都首届 Web 前端大会 2018-01-21 —— Code for City 黑客马拉松 2018-03-31 —— 成都首届 React 技术大会 2018-11-10 —— 成都第二届 Web 前端大会 2019-11-16 —— 成都首届 Web 全栈大会 成都技术氛围不如北上深杭 技术大会都在沿海城市 FCC 成都社区 https://fcc-cd.dev 成都缺乏技术氛围， 我们就自己来营造氛围！ 技术分享会 结对编程/翻译工作坊 黑客马拉松 代码直播 半月度小型技术活动 不定期中型技术活动 年度大型技术会议 家（坝）门（子）口（上）的技术社区 FCC 中文社区https://chinese.freecodecamp.org/ freeCodeCamp 最早的非英语版本 由近百位志愿者在 GitHub 协作翻译 自 2016 年成立， 已在中国各大一二线城市、部分三四线城市落地 中文社区创始人 Miya， 也于 2019 年加入全球全职团队 freeCodeCamp https://freecodecamp.org 从 零基础 到 合格软件工程师 注册用户：全球 300+ 万 全球网站 Alexa 排名：超越同类商业平台 Udacity GitHub 源代码：全球星标第一 Medium 专栏：全球最大 YouTube 频道：编程类最火 线下开发者社区：遍布 160 多个国家、2000 多个城市 全球 7 个全职员工靠着社群捐款， 与千千万万业余贡献者一起， 完成了这个壮举！ 成为计算机教育领域的维基百科 参会者 QQ 群","link":"/article/propaganda/web-conf-2019-prologue/"},{"title":"【公益】高考志愿填报助手","text":"2020 年高考是一场非常不容易的高考，毕业生和社会各界都历经艰辛，希望我们的拼搏都能有更加美好的明天。 说起填志愿，回想起我高考时正值汶川大地震。那时我们获取可靠、有效、全面的志愿参考信息，基本只能通过学校发的一本大部头参考书，里面汇集了全国招生的院校、专业和往年录取数据。但这样一本像过去每个城市的电话黄页一样的书，反复查阅它的“低效”痛苦就不用多说了。 进入大学 IT 技术社团之后，就一直想用自己学到的编程技术，来为学弟学妹解决我当年那般的痛苦。但彼时，我国政府部门信息公开政策的保守和技术的落后，让我们很难获得好用的数据，商业平台又有巨大的封闭壁垒，遂作罢…… 直到前一阵子，FCC 一位城市社区组织者在群里分享了黄希彤老师的填教授公益项目，看到他把多年收集的公开数据用统计学方法进一步处理，免费为广大考生做参考，内心十分激动！于是想尽自己现在的专长所能，帮黄老师优化一下前端界面，让广大的考生和家长用起来更方便。 同时黄老师也欣然接受了我一直以来的开源直播方式，于是便有了 FCC 中文社区 B 站直播间长期栏目《水歌酱的开源日常》的首期特别节目《编程帮我填志愿》，也欢迎大家关注 FCC B 站账号以接收日常节目的开播提醒~ 使用入门基本操作 选择考生所在省份、分科后，再填入高考成绩，点击查询按钮即可查询到根据往年录取情况有可能考上的学校和专业 可以下拉选择不同的上线概率后重新查询，来筛选相对保险（高概率、保底）的专业和相对有挑战（低概率）的专业 对于公布位次的省份，可以选择按照位次来查询筛选专业 筛选后页面出现过滤按钮，可以输入感兴趣的学校和专业关键字在结果中进行进一步的筛选 每年招生情况都会发生变化，因此考生在查询后可点击学校、专业名称的链接，进一步了解相关专业当年的招生信息 安装为 App 现代浏览器首次访问自动提示安装 确认安装到桌面 已安装到桌面 App 在系统中独立运行 技术知识为了满足黄老师提出的“除 CSS 样式外，简单业务不依赖任何库”要求，水歌本次对填教授 Web 前端代码的重构采用了最新版 BootStrap、DOM API、JavaScript 标准，刚学完 freeCodeCamp HTML、CSS、JS 基础课程的菜鸟也能快速上手~ 以下是这些易学、易用的标准、通用技术的入门文档： HTML 标签、属性 tabindex 全局属性 hidden 全局属性 iframe 标签的 name 属性 template 标签 CSS :empty 伪类选择符 DOM API CSS 选择器 API document.forms ParentNode 接口 ChildNode 接口 Element.prototype.classList HTMLFormElement.prototype.elements BOM API fetch() URL() ECMAScript API、语法 Array.prototype.map() Array.from() ECMAScript 6 模板字符串 with 语句的利弊 async 函数 第三方开源库、云服务 BootStrap 4.5 API Polyfill 自动补丁服务 CodeSandbox 在线 Web 前端项目沙盒 Parcel 零配置打包器 参考文档以上知识点在 FCC 成都社区之前的技术博文有介绍： 《ECMAScript + DOM 骚操作》 《JavaScript 效率工具》 《如何用开源软件办一场技术大会？》","link":"/article/propaganda/college-applier/"},{"title":"星星之火，可以燎原","text":"大家好，我是牛牛，我来自 FCC 成都社区！ 如果你问我为什么要在开篇自我介绍，因为我对 FCC 以及 FCC 的每一个人感到骄傲和自豪！ 💫 故事从这里开始 10 月 24 号在这个对计算机行业来说很特殊的日子，FCC 成都社区承办了 2020 年中国开源年会成都分会场。大会主题是开源向善，开源一词看似是程序员专属，可成都分会场的志愿者大部分却不是计算机专业，有森林保护专业、国际贸易专业、外语专业等。当我问她们为什么会来时，她们答道“看到了，就想来了解一下”。 或许有时就是不经意间听到的某个观点或某句话，就会在自己心中种下了一颗种子，一颗永远不会枯死的种子。 📖 翻开这本书因有幸参加过 18、19 年两届 FCC 成都社区举办的技术大会，所以会不自觉的将本届大会与往届对比，由于今年改成了线上直播模式，所以现场参会观众并不多。说实话差距很大，落差感很大，有些失落难过。 多亏喵喵喵（FCC 成都组织者之一）在 24 号下午组织的闪电演讲让场子“热”了起来，演讲涉及技术、产品、开源、健身等领域。闪电演讲结束后喵喵喵问了一个问题：“各位觉得什么是开源？” 现场顿时安静了下来，直到有个人答道：“白嫖”，观众们笑了，或许看到这两个字的时候你也会不禁一笑。 但细想一下，开源对大部分开发者来说可能就是从 GitHub clone 一个项目，或者从 NPM 引入一个开源库，大家一直在享受着开源带来的便利，但如何通过开源让更多人受益？中国人常说“知恩图报”（或许这个词用在此处不太恰当，但的确想不到更好的词来表述），而“无以为报”不就是白嫖吗？ 我们都是开源的受益者，然而在享受开源项目的便利时，如何去“报恩”？论语有云： 或曰：“以德报怨，何如？”子曰：“何以报德？以直报怨，以德报德” 而何以报开源？我认为只有以开源报开源，并且开源的目的应该是纯粹的。 👨‍💻 受益的只有开发者吗起初我认为只有我们开发者才会受益于开源的便利性（或许很多人和我的想法一样），而闪电演讲过程中 曾征（PX4 布道师） 的演讲却让我有了更深的认知：非洲一个黑人小孩使用 PX4 和竹子开发了一个属于自己的无人机！ 没错，你没有听错使用竹子 🎋 在非洲这种信息技术不那么发达的地方，一个孩子制作出一个无人机是一个大新闻。开源的传播，也让更多不是开发者的人受益，GitHub 第一大开源项目 freeCodeCamp（即 FCC）中有很多课程，从前端、算法到 Python 、深度学习， FCC 也让更多普通人了解到了编程，并且其中有很多人由此找到了一份不错的工作。FCC 成员与 Quincy（FCC 项目创始人，是个可爱的大叔）现场视频时也说道，有越来越多的志愿者加入 FCC，同时 FCC 也在推出越来越多的课程帮助想学编程的人。 细细想来，其实当我们在使用手机、电脑时就是在受益于开源项目。 🌞 故事还没结束会后大家并未散去，而是在会场搬个板凳开起了圆桌会。 水歌想让 FCC 社区 的活动和大会更纯粹，所以也在逐渐减少各种大厂的 加持 和赞助，希望大家能够更自在的交流沟通自己的项目和社区，所以也在坚持在开源市集，但越来越少的赞助和大厂加持让参会人数越来越少。 “从高中搞社团到现在 15 年，越来越多的人受益于开源项目，但是国内开源的氛围却没实质性改变”，虽然我了解开源的时间很短，但听到这番话我却觉得很可悲。在场的各位都表达了自己对开源和如何更好的推广传播开源的想法，他们都是偏理想主义者，有些开发者听到他们的想法可能会觉得是在异想天开。鸟贵有翼，人贵有志，也正是因为他们的存在，因为他们的坚持才守住了国内开源的星星之火，他们单纯、可爱、可敬！ 这些开源的先驱者可能会怀疑自己的努力与尝试是否是值得的。我认为这是有价值的，努力与尝试在其他人心中埋下了伏笔，或许某一天他们的故事就与埋下的伏笔呼应了！ 💕 故事将会继续2018 年成都 Web 前端大会水歌在我心中播种了一颗种子，FCC 成都社区 为其灌溉，种子还在生长，我和 FCC 成都社区 的故事还在继续 🌱 孤阴不长，独阳不生，开源不是靠一己之力就能立即改变整个现状的。FCC 成都 期待更多人的加入，期待更多人能和我们一起传播开源的种子，让其扎根于大地，生根发芽，待其枝繁叶茂，为更多人“遮风避雨”！","link":"/article/summary/a-solitary-spark-and-wars-begin/"},{"title":"fCC开源技术分享活动回顾","text":"2025 年 3 月 1 日周六下午由 fCC 成都社区举办的开源技术分享活动在成都市天府五街 200 号菁蓉汇 2A 栋 5 层炎上台成功举办。 软件工程师会被AI替代吗？ 资深前端工程师彭雪梅就“软件工程师是否会被AI替代”这一话题进行了分享。首先从AI工具的实现步骤入手，将其分为三个阶段：预训练、后训练和强化学习，并结合理论与实操详细讲解了每个阶段的用途和作用。随后，分析了当前软件工程师的市场现状，将其划分为三个层级：能够实现基本功能、能够适当考虑性能和框架优化、以及能够结合业务需求搭建框架并提供解决方案。最后，结合AI工具的实现步骤与软件工程师的现状，探讨了软件工程师是否会被AI替代的可能性。分享结束后，与参与者围绕这一话题展开了讨论，各自表达了不同的观点和见解。分享链接：https://mp.weixin.qq.com/s/Y5BgpdIqoXUaybUjYycF5g 手搓一个Deno脚手架 idea2app 公司的创始人、fCC 成都社区主理事、TS 全栈开发工程师 水歌分享了怎么手搓一个Deno脚手架 ，首先介绍了Deno的用途及其当前的发展现状，随后详细分享了自己搭建Deno脚手架的具体步骤和过程，包括在搭建过程中遇到的问题以及相应的解决方案。接着，带领参与者进行实操，帮助大家更好地理解Deno。分享结束后，与参与者共同探讨了目前Bun、Deno和Node.js各自的优势，并对三者进行了对比分析。Deno脚手架地址：https://github.com/idea2app/Deno-quick-start/tree/main 在活动的结对编程环节调整为自由交流环节后，参与者们展开了轻松愉快的讨论。大家围绕旅游、编程等话题畅所欲言，分享各自的经历和见解。整个交流过程充满了欢声笑语，大家在轻松的氛围中度过了愉快的半小时。 开源技术分享活动作为对技术爱好者提供一个互动交流的学习平台，通过主题分享加理论实践，增强参与者的实操技能，促进知识共享与技能提升。 本次活动圆满结束，感谢所有参与者的积极参与和赞助商的支持。","link":"/article/summary/ai-deno-scaffold-event/"},{"title":"Chrome 性能调试工具","text":"2019 年 06 月 30 日 FCC 分享复盘 分享的示例 上周在 FCC 分享了一次浏览器的渲染性能调优，在分享的过程中大家问到一些问题，并且在分享之后，我自己也发现了一点问题，所以想写一篇文章来总结和复盘。 问：z-index 和合成层有关系吗？答：z-index 跟合成层没有关系，跟渲染层有关系。 参考：层叠上下文 层叠上下文是 HTML 元素的三维概念，这些 HTML 元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的 z 轴上延伸，HTML 元素依据其自身属性按照优先级顺序占用层叠上下文的空间 渲染层保证页面元素以正确的顺序合成，这样才能正确的展示元素的重叠和半透明等等。满足形成层叠上下文条件的 LayoutObject 就会为其创建新的渲染层。 文档中的层叠上下文由满足以下任意一个条件的元素形成： 根元素 &lt;html /&gt; z-index 值不为 auto 的绝对/相对定位 一个 z-index 值不为 auto 的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex opacity 属性值小于 1 的元素（参考 the specification for opacity） transform 属性值不为 none 的元素 mix-blend-mode 属性值不为 normal 的元素 filter 值不为 none 的元素， perspective 值不为 none 的元素， isolation 属性被设置为 isolate 的元素， position: fixed 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考这篇文章） -webkit-overflow-scrolling 属性被设置 touch 的元素 某些特殊的渲染层会被认为是合成层。合成层有单独的 GraphicsLayer。 渲染层提升为合成层的情况： 3D transform &lt;iframe /&gt; &lt;video /&gt; 3D 或者 硬件加速的 2D Canvas 元素 will-change 问：什么工具可以查看 CSS 的属性改变触发渲染的方法？答：可以查看：https://csstriggers.com/，这个网站注明了在不同的浏览器内核下，每种 CSS 属性在默认和改变时会触发哪一种渲染操作，后面会有详细解释。 问：这次分享的是针对的什么渲染引擎答：Blink 这里说一点点浏览器的历史吧，最开始 Chrome 是用的苹果公司的 WebKit，后来谷歌和苹果产生了分歧，谷歌从 WebKit 中复制了一个 Blink 项目，所以我们分析渲染性能是针对的 Blink。 对浏览器渲染引擎感兴趣的可以看： https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/ WebKit 技术内幕 虽然 Blink 是 WebKit 的一个分支，但是有很多细节不同。首先，谷歌把 WebKit 的代码梳理得可读性很高，比如 RenderObject 变成了 LayoutObject，RenderLayer 变成了 PaintLayer。所以这里我需要修正一下分享时的渲染流程图，现在 Blink 内核的渲染流程图是下面这个。 当然除了代码可读性高了，渲染的细节也有改变。 分享的时候有人问到为什么我用了 transform 但是在 Layer tab 没有看到合成层。下来我查证了一下，先看一下下面这张 CSS trigger 的图 最上边的 B、G、W、E 分别代表的是：Blink(Chrome)、Gecko(火狐)、WebKit(Safari)、EdgeHTML（Edge 的内核，不过微软已经宣布 Edge 浏览器将切换至 Chromium 内核，也就是 Blink）。 左侧显示的 CSS 属性。 左边的 BGWE 是设置属性（从默认值修改，相当于一开始没设置 CSS）。右边的 BGWE 是修改属性（对现有的属性值进行修改）。 下面每个小方块的颜色就是对应的渲染流程中触发的方法。 从 transform 会触发的方法可以看到，在 Blink 下只触发了 Composite，而在 WebKit 下触发了 Layout、Paint、Composite。从上面列举的会触发合成层产生情况，可以看出 transform 只有在 3D 的情况下才会形成合成层，而在 2D 的情况下是没有合成层的。 上面这个是我分享的优化成了 transform 的例子。如果我把每个小方块都改成 3D 渲染，layer 显示应该是这样的 所以这里需要修正我所讲的“transform 都会形成合成层”，正确的解释应该是： 在所有引擎下 transform 2D 并不会形成合成层，只有 3D 才会形成合成层 在 Blink 引擎下，本身 transform 2D 不会触发 layout 和 paint，而在 WebKit 引擎下仍然会触发 layout 和 paint。 所以 Chrome 提升动画性能仍然会触发 layout 和 paint 的动画操作改为 transform。但是如果是 3d 情况下，形成合成层的元素太多，会很消耗内存，所以需要做一个平衡。","link":"/article/summary/chrome-performance-summary/"},{"title":"水歌的开源实验","text":"「2020 中国开源年会」官网开发及成都站总结 官网开发 —— 骑马造车展厅需求与日程难题COSCon’20 筹备伊始，组委会分派给我的首要任务是合作伙伴云展厅的开发，以便在疫情尚未平息之时的线上大会给各大合作伙伴一个集中宣传的窗口。 但云展厅的设计图并非一般线下大会在官网贴一屏 logo 那么简单，还有文字简介、宣传视频、加群二维码和入选的议题与讲师等等。面对这样的需求，必然难以用近年技术站流行的 MarkDown 网站生成器来规范而高效地实现，因为去年用 YAML 文件维护前两年的 logo 墙已经很繁琐了。 提到合作伙伴关联的议题、讲师，又让我想起参加 COSCon 2018、2019 时手拿一张尺寸巨大、文字特小的日程表找会场时的痛苦，与参加台湾 COSCUP 2019 手持会议 App 畅游时的体验形成鲜明对比。 OPass logo - 台湾开源会议通用 App 与我一同经历上述 3 场大会的庄表伟老师（开源社 2020 年度理事长），在 COSCon’19 现场曾和我不约而同地提出“要做个开源会议系统”，大会结束后便以产品配开发的搭档火速开干，但又因团队缺乏精力而停摆…… 开源软件一箭三雕但今时不同往日，疫情闭关时折腾的 Headless CMS 正好派上用场。得益于 Strapi 的可视化数据模型设计器，分分钟完成以下数据库表结构设计： 集合类型 用途 备注 User 外部注册用户 非后台用户 Activity 活动 各类小中大型活动 Organization 外部组织 公司、开源社区、公益组织 Partnership 合作关系 活动合作、赞助 Category 内容分类 可关联于多种内容型数据 Program 活动环节 演讲、工作坊、展位 Project 专案 开源、公益项目 Place 场地 室内、户外 Strapi 后台管理界面（数据模型） 不仅如此，运营人员用的内容编辑界面也自动生成了~ Strapi 后台管理界面（内容编辑） 再装上官方的 RESTful API 文档生成器，前端工程师最喜欢的 Swagger UI 瞬间呈现！ Strapi 接口的 Swagger 界面 相比之下，反而在云主机上安装 Python PIP、Docker Compose 和配置 HTTPS 证书花了更多的时间。 于是乎，我只需带着志愿者专注于 Web 前端项目就好了，而且是一次性搞定云展厅、日程表和展位申请表页面~ 反思、反刍、反哺其实办一场大会涉及的信息不止以上内容，还有会前志愿者任务的发布、提交与评价，会中的议题评论，及会后的差旅报销、物资登记等等。同时，一个 NGO 的志愿者积分、财务账目等数据也要长期统计，以便向社会公开。 但大多数组织的信息化还非常初级，数据散落在多个商业工具的免费版里： 表单系统：调查问卷、讲师征集、志愿者报名 表格工具：员工名册、活动日程、物资账目 活动平台：内容介绍、合作伙伴、观众报名 而且国内各商业平台几乎没有可用的 API，最终形成一堆数据孤岛，让组织成员在数据同步与查找的过程中疲于奔命…… 其实，将上述工作稍加梳理，也不需要增加太多数据模型： 集合类型 用途 备注 Task 任务 Contribution 任务贡献 Evaluation 评价 贡献、活动环节的评分 Comment 内容评论 可关联于多种内容型数据 Account 账目 赞助、差旅、采购 Property 物资 设备、纪念品 又因为 Strapi 的数据模型定义自动保存在项目目录的 JSON 文件中，可以直接与代码一起提交到 Git 仓库，加之 GitHub 推出了模板仓库功能，包含上述通用数据模型的 Strapi 项目，就变成了一个综合的组织管理系统，可以发布为一个开源后端脚手架 —— https://github.com/kaiyuanshe/OrgServer 再把替换 Strapi 默认富文本编辑器的组件独立成库，又多了一个方便的第三方插件 —— https://github.com/TechQuery/strapi-plugin-ckeditor Web 前端用 MobX 对接 Strapi 规范接口的通用逻辑也可以抽象出来，做成一个支持响应式渲染的 SDK —— https://github.com/EasyWebApp/MobX-Strapi 以后再用 Strapi 开发项目的效率自然高上加高咯~ 最后，Strapi 官方生态推荐列表也很快收录了上述 3 个项目。","link":"/article/summary/open-source-experiment-of-shui-ge/"},{"title":"7.14 成都社区翻译工作坊回顾","text":"这次翻译工作坊的内容是 News 文章，之后大家也可以用百科作为内容，这是我们社区最近需要重点推进的。 在中文版 News 上线之后，我们是这样规划它的内容的： 和英文版类似，发布技术/产品/设计相关的文章，分享学习编程的经历和求职的经验，分享教学视频，这些内容可以是原创，也可以是翻译。 翻译这部分，我们计划首先从翻译英文版 News 的优质文章开始。之前我们都在这个论坛协作翻译，听取大家的建议之后，我们决定转到 GitHub 协作。 接着，水歌提议说他很早就想组织翻译工作坊，一方面可以帮助大家提升英语水平和熟悉 GitHub 使用，另一方面也可以引导线下活动参与者们更多参与 freeCodeCamp 线上协作，使大家更了解我们的社区在做什么。所以，7 月 14 日，我们在成都社区组织了第一次翻译工作坊。 活动前 静如 @jingruzhang 帮助在 GitHub 翻译仓库理清楚了协作流程，发布翻译任务（issue），我也在逐步增加任务。 7 月 11 日，水歌 @TechQuery 预订活动场地，定下来活动流程，制作报名表；我编写活动报名文案。 我准备 freeCodeCamp 简介 PPT（我会单独发给每个城市社区），详细内容来源于 freeCodeCamp.org 社区概览。 7 月 12 日，开启报名。 活动中 宣传期只有短短两天，报名总人数似乎是 14 人，当天的参与者共 12 人（包括水歌和我）。 活动时间从下午 2 点到 5 点半。 现场共 5 台电脑，还好是结对翻译，大家可以共用电脑（报名文案里我忘了提醒带电脑，我问水歌要不要短信提醒，他说“工作坊不带电脑，来干嘛”，我们都以为大家会有带电脑的默契，然而事实证明该提醒还是得提醒 😂）。 参与者陆续到场，水歌让大家逐个自我介绍，一半人是第一次参加成都社区的活动吧，之前也没有任何铺垫，所以我感觉这个环节气氛有点小尴尬。参与者中有两位是翻译从业者（其中一位女士大概 50 岁吧），对活动好奇就来看看了；还有三位是正在自学编程想要转行的，其他人都是在职开发者，主要目的是练英语吧。当然，还有共同的目的是从社区中认识新朋友，让自己的周末时光充实一点。 接着，我照着 PPT 给大家介绍了 FCC 和我对翻译这件事情的建议“好奇心、同理心、耐心”。我们已经在 GitHub 仓库列出详细的翻译规范，所以我的建议更多是在鼓励大家 enjoy 吧（其实不只是翻译啦，这“三心”也适用于别的很多事情吧 ^_^）。我的初衷是让氛围轻松随意一点，同时让大家多感受 FCC 团队和社区的真实与活力——就像现场一位女生看到 PPT 中的团队照片之后说“Quincy 的名字好熟啊，原来每周给我发邮件的就是创始人啊”——然后我就讲了不少细节故事，大概讲了半小时吧。 我带了一盒 FCC 程序员扑克牌，用于热场。每位参与者随机抽取一张扑克牌，稍微准备一下之后，挨个分享：介绍扑克牌上的程序员，翻译上面的英文句子，讲述自己对这句话的体悟。这个环节蛮有趣，是一个小小的即兴挑战。 然后我们鼓励大家主动分享在热场环节的体验，我记得似乎只有 1 人主动分享了：“Miya 推荐的腾讯翻译君小程序很好用”。 热场之后，氛围变得轻松了些，水歌给大家介绍 GitHub 翻译协作流程，教大家如何 pull request。 然后就开始结对翻译了，这个过程大概 1 小时吧。大家都很认真地讨论，其中有一组很聪明地使用谷歌翻译之后再修订，加快速度。 在有的组遇到一句话不太会翻译的时候，上面提到的两位翻译从业者和我有帮助他们理清楚句子的意思。我也有给我那组两位女生分析一些句子结构。 活动后 活动结束，我们让大家保存好已翻译的内容，回去完成之后再 pull request。合影，自由聊天，部分参与者晚上聚餐。 参与者们很嗨皮地在社区微信群里分享照片，也有发朋友圈，群里有的小伙伴表示羡慕不已“下次一定要参与”。 我跟水歌说隔天发一个反馈表，让大家分享一下参与体验，然而最终没有发。 活动上大家领取了 5 篇翻译任务，10 天过去了，貌似只完成了 1 篇文章吧。我们在群里提醒大家记得完成，两个人回复“ok”。 今天，成都社区公众号发布其中一位参与者的文章，图文并茂，看得出来她很喜欢这个活动，和，我送她的扑克牌 😂 可以提高的地方 水歌提出翻译工作坊可以定期举办，那么我觉得每一期可以提前多几天发布活动文案。 活动前可以把报名者都邀请到群里，自我介绍什么的，线上初步认识一下，也听听大家对活动的期待。广州社区每次活动前就是这么做的，特别好！ 介绍 FCC 社区这个环节的时间要缩短，10 分钟足够了，留多点时间让参与者们多分享、互动。 活动上如果有英语不错的小伙伴可以给大家提供语言帮助，非常好。如果没有的话，大家多用用翻译工具，也还是能搞定大部分内容的，不过不必强求一定要一次性翻译到位，毕竟 pull request 之后还有人帮助校对嘛。 活动后搜集反馈挺重要的。 可以和参与者保持联系，比如问问他们是什么原因没有 pull request。 我的总结大概就是这些了，水歌 @TechQuery 还有什么要补充的吗？ 水歌的补充 我们翻译仓库维护者在准备待翻译文章时，除了在对应 MarkDown 文件中写清原文链接，最好能把原文粘贴到文件中，这样每个译者的 pull request 的变更差异对比界面就能看到双语对比 会前拉群确实可以让大家有所准备，能提高到场率，以前成都这边只有线上工作坊才提前拉群 后面看一下 GitHub API 对文件编辑时的 fork 支持度如何，看能否把我开发的 Git Pager 编辑器给译者用，降低 pull request 的学习成本 会后反馈表后面我做个统一的打分表单方便每次复制","link":"/article/summary/fcc-translation-workshop-0/"},{"title":"FCC 之翻译工作坊","text":"【编者按】一位参加本期工作坊的女生写的活动总结，感谢她和大家的积极参与！ 一、开始之旅当然是再次参加 FCC 成都的活动啦，先上图 二、划重点 FCC 是 freeCodeCamp 不是只讲前端的工作坊呀（对不起原谅我之前没有认真看。其实还有其他学习资料，各种都有呢 还有这个 Quincy Larson 名字很熟悉呀。这不就是隔不了多久就会给我邮箱里发学习资料的人吗？（每次看到邮箱的感觉就是：哇，又有新技术阔以学习了哇 听了 FCC 中文社区创始人、FCC 国际社区唯一中国全职员工 Miya 小姐姐的讲解才知道，原来经常催我学习的人就是创始人呀。 （附上 FCC 介绍的链接） 对于活动的态度。Miya 小姐姐讲的大意是：不用想今天来参加活动的人数是多少，只要做好活动，做你认为有意义的事情。可能这事不大，但可能会改变某些人的一生。 关于翻译的看法：图中有 Miya 小姐姐传授的独门秘籍哟。 关于分享：分享是表达自己呢 那个小礼物扑克呀，是真的好看，质量也好。瞧瞧那光泽，看看那手感，不一样不一样。重点是随便一张都是大佬，随便一握就是几个知识点。大佬在手，便知有没有。 （不行，我要给它们特写，放图！以下） 等等，我们今天的主要任务是翻译啊 三、结对翻译 拿到牌后，现场实时翻译。 讲解翻译规范 正式开始结对，分小组完成任务。 开始翻译之旅，和组员商量确定翻译哪一篇文章。确定后开始协作，比如她有电脑那她负责实际操作和记录，我就负责口头翻译和抉择。 在翻译过程中，有翻译出的中文意思待讨论的部分，刚开始有些争论。后面一点点细细分析后，确定了最后的表述方式。还有很多感受呢。 有人陪着一起做有趣的事，慢慢一起成长的感觉真棒～ 开心，分小组现场翻译的感觉，有点意思哦 四、寻有志同道合的朋友加入我们战队这里是一个小结：快乐的时光总是过的很快。每一次线下交流都会有收获，今天暂且告一小段啦。 成功都是从一个个小点开始积累起来的，这算是一个小小的开始吧。故不积跬步无以至千里，不积小流无以江海。 有兴趣的小伙伴，阔以加入我们。下次翻译坊，期待你的加入哦～ 欢迎认领翻译、校对！ Let’s go to change the world by a little thing.","link":"/article/summary/fcc-technical-translation-0/"},{"title":"如何用开源软件办一场技术大会？","text":"2019 成都 Web 全栈大会技术工作总结 其实今年大会水歌也有不少要分享的心得，可惜忙于大会筹备，没精力准备一个讲题。不过本届大会倒是全面应用了水歌新钻研的技术，会后就和大家简单分享一下。 官网 Web 前端 大会官网 PWA 组件引擎 —— WebCell WebCell 2018 成都 Web 前端大会筹办时，大会官网就用大会开源市集参展者 WebCell 的第一版开发，WebCell 也成为大会当天最火的展位之一。 一年来，其作者水歌一直保持对让 Web 开发更简单的不懈追求，在贺老对 WebCell “装饰器退回 TypeScript 版本”的建议下，花两天时间用 TypeScript 重写出了 WebCell v2 —— Web Components 标准提供的轻量级运行时隔离环境让组件引擎可以用更少的奇技淫巧，降低复杂度（本届大会上慕阳老师的《DevCloud Web Components 实践》也有深入讲解） TypeScript 给 ECMAScript 带来的类型系统不但能充分激发程序员的肌肉记忆，还让本与 HTML 5 &lt;template /&gt; 相差不大的 JSX 通过类型推导如虎添翼 状态管理 —— MobX MobX WebCell 自 v1 以来的装饰器写法与 MobX 十分搭调，v2 用了 TypeScript 就更是无缝兼容，而且还带来了更清爽的开发思路： 前端路由可以基于状态管理与普通组件来实现，而不再是“特殊的库” —— 路径即状态，容器即组件 登录框也无需做成单独的页面，而变成一个容器组件，避免复杂需求下页面跳转时状态的混乱 —— 有登录状态就渲染 children，否则渲染登录框（像后端中间件一样，让具体业务页面不用管登录状态） 组件库 —— BootCell BootStrap 说到 UI 组件库，很多人可能觉得 BootStrap “不好看”，但水歌却对它情有独钟 —— 官方文档示例代码中的 HTML 结构语义化、无障碍 (Accessability) 堪称“教科书”，对 SEO（搜索引擎爬虫）、屏幕阅读器（视障人士）极为友好 它首先是个 CSS 库，其 CSS 工具类很丰富，几乎覆盖所有常见定制需求，日常开发基本不需要写自己的 CSS 文件，且能保持一致的设计规范，对小项目团队非常友好 因此，在如此规范的设计之上实现一个特定框架的组件库，边写业务边封装都是很快的。 工具链 —— Parcel Parcel 现在 Web 前端开发的第一道门槛恐怕不是 this、闭包、异步了，当属 webpack —— 我司业务代码都写好了，就差一个 webpack 配置工程师了…… 所以，我们转而用面向资源的打包器 Parcel，它能在保持 Web 开发原生资源引入方式的同时，自动处理资源的路径转换、依赖安装、编译流程，没有特殊需求则无需配置文件，三条命令搞定 —— # 安装 npm install parcel-bundler -D # 开发 parcel source/index.html # 构建 parcel build source/index.html PWA 框架 —— Workbox Workbox 虽然天朝因为墙的原因而难以使用 Web Push，但 PWA 图标添加到桌面、Service Worker（后台网络缓存）这些特性，国内用的主流操作系统、浏览器基本都支持了，该标准的亲爹 Google 还推出了强大而方便的工具包，让 PWA 真正 Quick start： # 安装 npm install workbox-cli -g # 配置 workbox wizard # 构建 workbox generateSW 【参考】https://tech-query.me/development/pwa-quick-start/ 电子邀请函 前端生成截图 前端截图 —— SVG foreignObject在 Web 前端页面中截图，最负盛名的库莫过于 html2canvas，但它需要把当前网页的 DOM 树克隆进一个 &lt;iframe /&gt;，会意外地触发 Web Components 的重绘，遂放弃。 除此之外，在浏览器更新较快的今天，我们终于可以放心地使用 SVG 带来的福利 —— &lt;foreignObject /&gt;。它能将 HTML 包在 SVG DOM 中渲染，而 SVG 又是可以被 &lt;img /&gt; 引用的图片，截图只需用 &lt;canvas /&gt; 画一下再输出，就变成 PNG、JPG 这些常用格式了~ &lt;body&gt; &lt;svg&gt; &lt;foreignObject&gt; &lt;h1&gt;Hello, SVG!&lt;/h1&gt; &lt;/foreignObject&gt; &lt;/svg&gt; &lt;/body&gt; 【封装】https://github.com/bubkoo/html-to-image 前端请求库 —— KoAJAX国内前端同学最常用的 HTTP 请求库应该是 axios 了吧？虽然它的 Interceptor（拦截器）API 是 .use()，但和 Node.js 的 Express、Koa 等框架的中间件模式完全不同，相比 jQuery .ajaxPrefilter()、dataFilter() 并没什么实质改进；上传、下载进度比 jQuery.Deferred() 还简陋，只是两个专门的回调选项。所以，它还是要对特定的需求记忆特定的 API，不够简洁。 幸运的是，水歌在研究如何用 ES 2018 异步迭代器实现一个类 Koa 中间件引擎的过程中，做出了一个更有实际价值的上层应用 —— KoAJAX。它的整个执行过程基于 Koa 式的中间件，而且它自己就是一个中间件调用栈。除了 RESTful API 常用的 .get()、.post()、.put()、.delete() 等快捷方法外，开发者就只需记住 .use() 和 next()，其它都是 ES 标准语法和 TS 类型推导： import { HTTPClient } from \"koajax\"; var token = \"\"; export const client = new HTTPClient().use( async ({ request: { method, path, headers }, response }, next) =&gt; { if (token) headers.Authorization = \"token \" + token; await next(); if (method === \"POST\" &amp;&amp; path.startsWith(\"/session\")) token = response.headers.Token; } ); 不仅如此，其上传下载进度还是个 Observable 对象（RxJS 粉丝们喜闻乐见），而且是个下文会详述的升级版： import { request } from \"koajax\"; const { upload, download, response } = request({ method: \"POST\", path: \"/files\", body: new Blob([\"Hello, Observable!\"]), responseType: \"json\" }); for await (const { loaded } of upload) console.log(`Upload ${file.name} : ${(loaded / file.size) * 100}%`); const { body } = await response; console.log(`Upload ${file.name} : ${body.url}`); BaaS 后端云服务 —— NodeTS-LeanCloud【声明】笔者是自来水，绝无商业广告之意。 在云服务大行其道的今日，开发应用貌似必谈云原生，本届大会也有阿里云的《从 Infrastructure as Code 到 Open Application Model —— 填补开发到运维的鸿沟》和 AWS 的《无服务器计算架构》两个主题来着力科普云计算架构。但无论是前者的 IaaS（基础设施即服务）还是后者的 FaaS（函数即服务），对于初创全栈应用而言，其粒度不是太大就是太小，水歌还是青睐粒度适中的 BaaS（后端即服务）。 而 BaaS 中的翘楚，国外莫过于 Google Cloud 收购的 Firebase，国内则是 LeanCloud 深耕数年（它的创始人还是 YouTube 的创始人陈士骏，说起来都是谷歌家的，哈哈）。 BaaS 不但能像 IaaS、PaaS 一样基于 Docker 运行完整的各种语言写的后端项目，而且还封装了数据库、对象存储、消息推送、实时通讯等各种常用基础设施，数据库也默认实现了基于角色权限的用户系统和应用内搜索，这一切只需调用 SDK 的 API，而无需关心安装与运维。其数据库的 API 和后端常用的 ORM（对象关系管理）库差不多，SQL、分库分表、负载均衡这些都不用操心了，抄起键盘就撸业务代码才是王道！ 同时，借助其 SDK 的云函数 API，也能在同一个项目里实现 FaaS 的能力，对热衷代码本身的人来说更加灵活。 【模板】https://github.com/TechQuery/NodeTS-LeanCloud Email as a Hook —— IterableObserver经常制作表单的天朝程序员想必知道，国内各大表单服务商无论界面是否花哨、功能是否强大，都没有方便的后端 API，与 Google Forms 等国外平台相去甚远。数据的后续处理只能手工导出 Excel 再转 CSV 导入其它数据库，无论实时性、便捷性，简直不可同日而语。 如何在参会者购票成功后，大会官网可查到其报名信息？这让我们头疼了好久…… 幸好我们的合作方 MikeCRM 有个邮件通知功能，可以用它模拟一个 Web Hook 接口。于是，便找了个基于 IMAP 协议的邮件通知监听库 mail-notifier。 虽然它能实现功能，但随之而来的问题是，邮件客户端重启时集中发来的新邮件事件会并发大量 API 请求，BaaS 服务商会直接断掉后续请求…… 如何将事件流串行起来？大家自然会想到 RxJS，但它有点重。再仔细想一下，事件通常是异步的，异步的串行不就是异步迭代吗？那我们能否将 Observable 封装成 ES 2018 的 Async Iteration 呢？ 其实最初版的 Async Iteration 提案中异步生成器的返回值就是一个 Observable，后来才拆成单独的提案孵化，可以推测二者是能相互转化的。 于是，水歌尝试用已成为标准的 Async Generator 来实现一个 Observable，便有了 Iterable Observer，新邮件的串行处理也可以从离散的 Callback 改写成线性的 Iteration： const newMail = Observable.fromEvent(client, \"mail\"); (async () =&gt; { for await (const { html } of newMail) { await new MikeCRM(html).saveUser(); } })();","link":"/article/summary/web-conf-2019-open-source/"},{"title":"【总结】文言编程工作坊","text":"序夫混沌初开，阴阳分晓。盖两仪化四象，四象生八卦，八卦生无穷，此天地万物之生也。至冯祖降世，悟有无之道，尽天机之正，锻金为骨，化爻为髓，作精妙之仪，御之以电，上可演九章算术，下可推少广方田， 乃开后世之先河。 然则阴阳之道，众人难之，皆欲代之以文，谓之语言。不意甲子之期未至，百家争鸣已然，程式语言之多，繁若《天官》之星宿，奇胜《山经》之走兽。然以文言编程者，似所未有。有奇人 LingDong，宿好文章，且通程式，乃做斯言，行文言编程之事。且承开源之大义，此当吾辈之所以勉励也。 吾辈小子数人，尝创可思摩斯之奥义。结其于文言程式之中，乃凭文法之妙，于方寸之间，创宇宙之万物。行此聚会，以文、程二物会友。固为一乐，并望君能于乐中有所获矣。 始己亥年末，应程式之营所召，有朋数人，结伴于成都以南，紫荆谷中，引水流觞，以身践之，探寻文言程式之妙。较之以前汉字程式者，解其流行之道，悟其语法之意。期间，遇以文言程式难尽示万物之色，则畅言其未来之法。或曰以天干地支所代之，或曰以古法以充其文。诸如此类云云，语尽而意远，相得而益彰。 然则言谈终觉少，尚需躬行之。于是拟定四题，名曰： 问天地之好在 嘶嘶嗡嗡 求斐氏列 可思摩斯 题既定矣，闲话少言，乃以程式会之。 问天地之好在习程之人尽知，欲习一言，必先呼之。是乎，吾等乃以天地好在问之，书之于天地轮回之间，此乃入门之式也，不提。 嘶嘶嗡嗡一言既书，继而解题。题面曰：若有一术，设其能计之以数，然则其计数也，若逢倍三，则以诗之上阙以和之，若逢倍五，则以诗之下阙以和之，若倍三倍五，则和以全诗，问此如何？是谓「嘶嘶嗡嗡」之术也。 欲解此题者，需用以程式条件控之。题面虽简，然则精简之法层出不穷。不期在座者，皆乃浸淫程式之道十数载，仿若庖丁解牛，不出片刻便相继夺彩。 求斐氏列世间万物，看似无甚相关者，冥冥之间却有所连矣。若海螺，若花朵，若星河，凡视之谐者，皆有同理，后世称之为「黄金分割术」。宇宙万物其被设计乎？ 有先祖斐氏，探宇宙规律与其中，乃发现有一数列，自一始之，加相邻两项，以为后续之项。无限周转，则该列可复现此「黄金分割」之美于奥秘之间。 大巧若拙，大道至简。吾辈感先人之明，乃以文言程式求此「斐氏列」，现其于天地轮回之间，感其至妙也。 可思摩斯有朋者秋，乃创「可思摩斯」之书。施其义，则可于「万物初始」之时创精灵若干，且在「天地轮回」之中控其于股掌之间。若精妙习之，实乃天地万物之创始者也。 秋尝观东洋之景，见其精怪，悚之。今与众人以「可思摩斯」之书重现之，以壮众人胆色也。并依此例，阐述于文言程式中创世天地之法。众人习之，皆有所得。 结不觉间，时辰已过，众人乐之，并留念于紫荆谷中，互叮再约之期，乃去。","link":"/article/summary/wenyan-workshop-summary/"},{"title":"计算机中的二进制 | 书香讲 CS 之四","text":"二进制数字之前我们制作出了逻辑门，让计算机可以表示逻辑“真”或“假”。但是只靠这两个状态，我们没法表达更多的信息，这时，我们就需要了解一些数学了。别紧张，这个可能比你初中学的数学还要简单！ 用一个二进制的数可以表示“真”或“假”，我们用数字的方式计为 1 或 0。想要表达更多的信息怎么办呢？让我们想想十进制的数，一个数字可以表示 0 ~ 9，如果想表示 10 以上的数字，我们就在前面加上一位，就能表示出 0 ~ 99 的数字。二进制也是同样，通过在前面添加位数，可以表达更多的信息。 用十进制举例来说，数字 183 代表了什么呢？它表示了 1 个 100、8 个 10 以及 3 个 1 全部加起来： 183 = 1 × 100 + 8 × 10 + 3 × 1 注意我们乘的每个数都比右边的大 10 倍，因为每一位数字可以表示 10 个数字（0 ~ 9），只有超过 9 的才会加一位。这样基于每一位都有 10 个数字的计数方式，就是十进制。 二进制的原理是一样的，只不过它每一位只有 2 个可能的数字（0、1），所以我们要乘的每个数都比右边的大两倍，不再是 100、10、1，而变成了 4、2、1。比如说二进制数 101，就代表了 1 个 4、0 个 2、1 个 1 相加，等于十进制的 5： 101 = 1 × 4 + 0 × 2 + 1 × 1 为了表示更多的信息，我们会有更长的二进制数，比如说 10110111，就代表了十进制的 183： 10110111= 128 × 1 + 0 × 64 + 1 × 32 + 1 × 16 + 0 × 8 + 1 × 4 + 1 × 2 + 1 × 1= 183 二进制计算二进制的加减计算也很简单，我们同样还是从十进制举例。当我们计算 183 + 19 的时候，我们从个位开始，每一位对应相加，如果加出来的结果大于 10，就向下一位进一位： 同样，我们用二进制来计算，结果是一样的： 计算机中的二进制数计算机中，二进制数的每一位叫做 “比特（bit）”。一个 8 个比特的数字最小是 0，最大是 11111111（255），总共能表示 256 个，也就是 2 的 8 次方个不同的数字。 在计算机中，我们处理的二进制位数都是 8 位的倍数，以至于我们给每 8 个比特单独起了个名叫做 “字节（Byte）”。你可能听过 KB 、MB、GB、TB，他们的单位都是字节，前面的字母代表了数量级：KB 代表一千字节，MB 代表一百万字节，GB 代表十亿字节，而 TB 就代表了一万亿个字节，也就是 8 万亿个 0 和 1！ 以前我们玩的“8 位机”，就代表他们的数据都是用 8 个比特来表示的。而现在的计算机一般都是 64 位机。 一个“8 位图像”，就代表它每一个像素点的颜色由 8 个比特来表示，也就是每个点可以有 256 种可能的颜色；而“32 位图像”就表示每个点可能有 2 的 32 次方，也就是 4,294,967,296 这么多种颜色，那可清晰多了！ 8 位图片 64 位图片 负数、非整数并不是所有的数字都是正数，一般计算机会用第 1 位作为标志位来表示正负，1 表示是负数，0 表示是正数。例如一个 32 位的数，第一位表示正负，剩下的 31 位表示数字，能表示的范围就大概是 -2,147,483,648 ~ 2,147,483,648。 表示小数的规则相对复杂些，目前较常用的是 IEEE 754 标准。它将 32 位数设置成了 1 个正负标志位（S）、8 个指数位（E）、23 个有效数字位（M），最后表示的数字（V）计算公式如下： ASCII 码，计算机中的字符表示除了数字以外，计算机还通过给每个字符编上代码的方式，用二进制来表示文字。1963 年发明的 ASCII 码（美国信息交换标准代码）一直通用到现在。ASCII 码由 7 位二进制数表示，可以表达 128 个不同的字符，包括了大写字母、小写字母、数字 0 ~ 9，大部分标点符号及一些换行符、制表符等特殊符号。 比如说：字母“A”就由 65 表示，字母“b”是由 98 表示，标点“!”就用 33 表示等等。 ASCII 码表 UNICODEASCII 码简单易用，它使用不长于一个字节长度的二进制编码来解决了字符的问题。但是，ASCII 码却有个明显的缺陷：它只能供英语使用，其他国家的文字，比如中文有数千个常用字，根本没法用一个字节来编码。 各个国家都研究了自己的多字节编码方案，但因为各个国家的编码方案互不通用，导致在不同系统之间，就会产生乱码问题。例如，以前我们玩台湾或日本开发的计算机游戏，打开是乱码显示，需要使用转码器才能正常玩耍，就是这个原因。 1992 年，Unicode 诞生了，它统一了所有编码的标准，解决了不同国家不同编码标准的问题。常见的 Unicode 是 16 位的，可以表达超过一百万个字符，足够覆盖所有语言的每个字符了 —— 100 多种语言的字母（文字）大概占了 12 万个位置、剩下的还可以表示各种标点符号、数学符号、甚至 Emoji 表情！ 其他编码除了 ASCII 码，Unicode 编码表示字符以外，还有其他常见的例如 MP3、PNG、MP4 等等各种编码格式，可以用来表达声音、图片、视频等信息。我们在计算机中见到的照片、音乐、电影、游戏、网页、甚至操作系统，它们归根到底都是一串很长的“0、1”比特！ 之后了解了计算机基本的表达形式：二进制，以及它的计算以及编码。接下来，我们就会真正走进计算机的“计算”方式，看看在计算机内部是怎么操作这些二进制，来帮助人们完成工作的。下期见~","link":"/article/theory/binary-in-computer/"},{"title":"布尔逻辑与逻辑门 | 书香讲 CS 之三","text":"二进制我们从机械计算机，升级到了机电计算机，再到了电子计算机，逐渐希望用“电”来代替“机械运作”进行计算。减少了机械设备，就能降低计算机的物理磨损，可以使计算更加可靠，也变得更快。 还记得莱布尼茨的步进计算机吗？它用 10 个齿的齿轮来代表十进制数进行计算。然而，当我们试图用电流强弱的程度来表达十进制的时候，却发现受到的干扰太多了（比如计算机电池要没电了，或者电源电压不稳等等）。为了解决这个问题，人们尝试过制造五进制，三进制的电子计算机，却依然不能进行可靠的计算。于是，可以只用电流“开”，“关”两种状态进行表达的二进制计算机被设计了出来。 二进制只有“真”或“假”两个值，也可以表示成“1”或“0”。当电路闭合，电流流过的时候，表示“真”；电路断开，没有电流流过的时候表示“假”，这样的方式很难受到外界的干扰，可以让我们的计算机工作的更加稳定！ 逻辑门电路使用二进制的另外一个原因是，有一整套的数学计算的方法，来专门处理“真”或“假”，那就是布尔代数。它是以 19 世纪的英国数学家 George Boole 的名字来命名的。 Boole 一直致力于用一种类似常规代数的计算方法，来处理亚里士多德哲学中的逻辑问题。对比于代数中的加减乘除，布尔代数也有三个基本计算方式，那就是“与”，“或”，“非”。让我们分别来了解一下，并用晶体管制作出这三种基本门电路： “非”门“非”运算非常简单，它拥有一个输入和一个输出，运算结果就是把原来输入的结果反转： 前面提到，晶体管类似于一个水龙头一样，当接通控制电路的时候，半导体导电，输出就有了电流；断开控制电路的时候，输出就没有电流。 为了制造“非”门，我们需要将晶体管的输入输出极调整一下：我们将晶体管的一极接地，另外一极接通输出电路。这样，当我们接通控制电路的时候，电流就直接流入地面，而不会流过输出电路，只有断开控制电路的时候，电流才流过输出电路。想象成我们把水龙头安在了一个大的排水管上，关闭排水管，家里的水管里才有水；打开排水管，家里的水管就没水了。 “与”门“与”门需要两个输入，只有当着两个输入同时为“真”的时候，输出才为“真”，只要任意一个输入为“假”，则输出就为“假”。 比如：奥巴马是美国总统与奥巴马是黑人，结果为真；奥巴马是美国总统与奥巴马是白人，结果就为假。 制造“与”门电路，我们需要将两个晶体管串联起来。这样，用两个晶体管的控制电路作为输入，就必须两个输入端都接通，输出电路才有电流流过。 “或”门“或”门同样需要两个输入，并且只要任意一个输入为“真”，则输出就为真；只有当两个输入都为“假”的时候，结果为“假”。 同样的例子：奥巴马是美国总统或奥巴马是白人，结果为真；奥巴马是韩国总统或奥巴马是黄种人，结果为假。 制造“或”门电路，我们同样需要两个晶体管，只不过这次我们需要加一些额外的线路将它们并联： 抽象在真实世界中，即使是职业的程序员或工程师也并不总会去关心电流是怎么在计算机里流动的。人们往往会将常用的零件组装成一个粒度更大，使用更方便的工具，而不需要再去关心零件的细节，这样的过程就叫做“抽象”。 同样，我们现在做出了“与”,“或”，“非”三种门电路，人们抽象出了三种符号来分别代替它们： 与门 或门 非门 “异或”门除开这三种基本操作以外，还有个非常有用的布尔运算教做“异或”，异或和或运算非常像，当任意一个输入为“真”的时候，输出为“真”；不同点在于，当两个输入都为“真”，或者两个输入都为“假”的时候，输出为“假”。换句话说，只有当两个输入状态不一样的时候，输出为“真”；两个输入状态一致的时候，输出就为“假”。 利用晶体管来制造“异或”门电路就相当复杂了，还好我们可以用抽象出来的工具：“与”、“或”、“非”门来组装它： 后面会提到，“异或”操作非常有用，所以工程师们将“异或”门抽象成了一个“笑脸”的符号 :)D ，这是新的一层抽象，赶快把它放进工具箱，再也不用关心它是由哪几个门电路或者多少个晶体管组成的了！ 异或门 之后从现在开始，我们终于用电信号来表示我们的数据（真、假）了。并且通过逻辑运算，我们能描述出较为复杂的逻辑，比如：如果小明在周末或情人节买了玫瑰与两张电影票等人看电影，那么小明谈恋爱了为真。 我们用二进制表述出了逻辑，接下来，我们将会看看二进制在计算机里是怎么表示、存储和计算的。","link":"/article/theory/boolean-logic-and-logic-gate/"},{"title":"算术逻辑单元 ALU | 书香讲 CS 之五","text":"ALU 介绍上次我们讲到了计算机如何表示和存储数字以及文字，但计算机真正的目标是进行计算、有意义地处理数字，比如把两个数字相加等等。这些事是由计算机的一个叫“算术逻辑单元（ALU）”的部件来处理的。ALU 是计算机的大脑，也是现代计算机的基石，基本上计算机所有的操作运算都会用到它。 ALU 有 2 单元，1 个算术单元，1 个逻辑单元，所以接下来分两块来分别介绍它们。 英特尔 74181，第一个封装在单个芯片内的完整 ALU 算术单元算数单元负责计算机里所有的数字操作，比如加减法等等。要完成“将两个数相加”这个操作，需要制造出新的部件“加法器”,我们会用之前抽象出的“逻辑门” —— 与门、或门、非门、异或门 —— 来进行更高层次地抽象，组装成我们想要的部件！ 半加器最简单的加法电路，就是拿两个比特（0 或 1）加在一起。它会有 2 个输入，以及 1 个输出：两个输入数字的和。 我们的输入和输出都只有 1 个比特，所以会有以下几种情形出现： 0 + 0 = 0 0 + 1 = 1 1 + 0 = 0 1 + 1 = 2 = 10（二进制） 注意，在二进制里没有 2 这个数字，计算出来的结果需要进位，表示为 10。发现了什么？这 4 个加法结果的末尾和之前讲的“异或门”的输入输出结果一模一样！于是我们放上一个异或门： 但我们 1 + 1 这个运算的结果是 10，有一个“进位”上的数字被置为了 1，所以我们可以用之前的“与门”加入一条“进位”输出电路，来保存这个进位： 我们就制造出了一个“半加器”，把它进行抽象，加入我们的工具箱： 全加器半加器只能计算 1 位二进制的运算，如果超过了 1 位，我们就需要“全加器”。想一想我们之前的二进制计算，半加器相加后可能产生进位，那之后每一位的计算可能就会有 2 个对应位的数字加上“进位”的数字。因此，我们的全加器就会有 3 个输入，以及 2 个输出，它的可能性也多了许多： 我们可以利用半加器来做制作全加器，首先用一个半加器将两位数字相加，再把“进位”的数字输入另一个半加器，与前一个半加器输出的“和”进行运算，最后再用一个“或门”来监测是否有新的“进位”： 这样就制造出了全加器！同样我们把它抽象，加入工具箱： 8 位二进制加法器接下来，让我们看看怎么制作一个 8 位的加法器。假设我们要把两个名字为数字“A”和数字“B”的 8 位二进制的数相加。 首先，我们需要一个半加器把这连个数字的最右边一位“A0”和“B0”加起来，得到一个“和”输出和一个“进位”输出。 然后下一位的数字“A1”和“B1”除了对应相加，还要加上前一位的“进位”输出，因此我们连上一个全加器，同样得到了“和”与“进位”的输出。 再将上一步的“进位”输出连入下一个全加器就可以计算下一位数字了，以此类推，就可以制造出 8 位二进制的加法器了： 注意，我们最后一位的数字计算是有“进位”的，如果两个相加的数过大，在这里产生了进位，结果超出了 8 位，这就叫做“溢出 (overflow)”。 溢出意味着结果超出了对应位数可以表示的数字，这会导致错误和不可预期的结果。例如以前在 8 位机上玩“吃豆人”的时候，如果你玩到了第 256 关（8 位二进制最多可以表达 0~255），那屏幕上就会出现乱码，游戏就会出错： 为了避免“溢出”，我们可以加更多的全加器来制造 16 位、32 位、甚至 64 位的加法器。代价就是需要更多的逻辑门部件来制造，并且每次进位会花一些更多的时间。 其他操作另外，除了加法，算术单元也可以进行其他的运算，大概有一下这些： 加法（ADD） 减法（SUBTRACT） 增量+1（INCREMENT） 减量-1（DECREMENT） 不同的计算也跟加法器类似，是用不同的逻辑门组合出来的。但是在其中并没有乘法或除法，因为简单的 ALU 中并没有专门的器件来处理这两个运算，而是通过重复多次的加法或减法来完成的，例如： 12 × 5 = 12 + 12 + 12 + 12 + 12 但是现代计算机、智能手机等更好的处理器中，为了速度更快，也加入了乘法和除法的运算单元。它们更复杂一些，但也是通过更多个逻辑门的各种组合来实现的！ 逻辑单元顾名思义，逻辑单元在计算机内负责执行逻辑操作。比如之前说的“与”、“或”、“非”、“异或”。另外，它还能做简单的数值测试，比如利用许多个“或门”，来检测一个 8 位数字是否为“0”： ALU 抽象利用大量逻辑门的组合，我们可以构建出一个 ALU。回到一开始提到的英特尔 74181，它只能处理 4 位输入，并且不能直接进行乘除法的计算。即便如此，要构建出它，也用了 70 个逻辑门： 仅仅 4 位的 ALU 已经如此复杂了，而 8 位的 ALU 更是需要几百个逻辑门，因此工程师们在使用 ALU 的时候，将它抽象成了一个符号： 它接受两个操作数输入(InA，InB)，以及 1 个表示要进行的是哪个运算的操作代码 (Opcode)，然后输出一个结果 (Out)。 另外 ALU 还会有各种标志位 (flag)，来表示计算的状态。例如： 进位标志 (Carry flag) 表示这次计算有没有进位，0 标志 (Zero flag) 表示这次计算的结果是不是为 0，这样就可以方便地判断计算是否溢出，或者两个输入的数是否相等。高级的 ALU 中，会有更多的标志位，可以帮助处理器更快更方便地运算。 之后目前为止，我们了解了电子计算机是如何在没有齿轮的情况下进行计算的了。接下来，我们会利用 ALU 来制造计算的 CPU（中央处理器），越来越接近我们现在的计算机了！下次见~","link":"/article/theory/arithmetic-logic-unit/"},{"title":"计算机早期历史 | 书香讲 CS 之一","text":"手动计算设备有记载中，人们最早使用的的计算设备是——算盘。 最早的算盘大约在公元前 2500 年，发明于美索不达米亚。由于当时的社会规模已经远远超出了人们的心算能力（比手指脚趾加一起还多），因此需要帮助计算加减，并且能存储计算状态的手动计算器。 算盘计数：6302715408 随着社会的发展，人们还发明了各种计算工具： 星盘，用于在海上计算维度 计算尺，用于帮助计算乘除法 日晷，用于计算潮汐，天体运动或计时 Computer最早的 Computer 出现于 1613 年，是一种职业，专指负责计算的人。“Computer”们会借助一些工具来帮助计算，但主要还是靠人力。 “computer”们在工作 直到某一天，戈特弗里德·莱布尼茨说：“让优秀的人浪费时间算数简直侮辱尊严，文盲用机器能算得一样准”，于是他发明了步进计算器。步进计算器有一串齿轮，每个齿轮 10 个齿，代表 0-9，每次超过 9 就让前面的进一位，减法时反向运动。经过巧妙的设计，可以方便地进行多次加减法，来完成乘法和除法。 莱布尼茨步进计算器 通过机械化的计算器，大大简化了计算器的操作方式，降低了计算人员的学习成本。但是这种计算器计算较大的数字时，依然很费时间，往往一次计算要耗时几个小时到几天不等。另外因为造价高昂，因此并没有得到足够的重视。 计算表为了快速进行更为复杂的计算（例如指数，对数，三角函数等），人们将计算好的结果提前算好，并制成计算表方便查询。 在军事中，因为经常需要更为快速，精准的机选，计算表的方式得到了广泛的运用。例如在炮兵中，炮手发射的炮弹会因为风力，温度，大气压等等环境因素的变化而影响射程，而很难打中目标。根据使用射程表，通过当前的环境因素和射程，来快速计算出当前应当设置的炮的仰角，大大提高了命中率。 拿破仑军队中的炮兵计算表 但是，如果更换了新的火炮或者炮弹，对应的计算表都需要重新计算，依然会非常耗费人力和时间。 分析机“随着知识的增长和新工具的诞生，人工劳力会越来越少。” Charles Babbage 认为通过机器应该可以自己完成通用的计算过程，并于 1837 年设计出了分析机，可以自动运算一系列运算操作。 Ada Lovelace 为分析机写了假象的程序，并预言：“未来会诞生一门全新的，强大的，专为分析所用的语言“（计算机程序雏形）。 因为设计理念过于超前，分析机的制作成本过高，导致这个设备并没有真正制造出来。但是人们通常认为 Charles Babbage 是通用计算机之父，而 Ada Lovelace 是第一个程序员。 伦敦科学馆的分析机复制品 电动计算器19 世纪末，计算设备往往用于科学或者工程等特定领域。但是随着大量移民导致地人口增长，美国政府在 1890 年的人口普查中却遇到了问题。 美国宪法规定每 10 年进行一次人口普查，统计各项数据，用于分配联邦资金等等。然而在 1890 年需要进行普查的时候，发现根据当时人口数量，统计计算各项数据需要 13 年之久！还没统计计算完就需要进行下一次普查了！ 美国政府找到了 Herman Hollerith，发明了电动机械计算器。这个计算器采用传统步进计算器的方式进行计数，却将其他用于操作的结构用电动设备连接了起来。通过插入打孔的卡片，来控制电路系统，从而代替人力操作来完成统计和计算。 打孔计算器 打孔卡 这种计算器的运行速度大概是手动速度的 10 倍，并在人口普查中为美国政府节省了大约 500 万美金的开支。 这个成绩，使得越来越多的公司意识到打卡计算器的优势。于是，Hollerith 干脆成立了打卡机器公司，并在 1924 年与其他机械制造商合并，改名成为了 IBM（国际商用机器公司）。 之后1900 年代中叶，随着人口爆炸式增长以及贸易的兴起，对数据的计算量大大增加。但是机械计算器在长期运作中造成的磨损，而产生的的计算错误以及成本提高问题越来越严重。人们迫切需求更快更灵活的工具处理大量的数据，这为电子计算机的发展奠定了基础，让咱们下期讨论~","link":"/article/theory/early-computer-history/"},{"title":"电子计算机 - 书香讲 CS 之二","text":"机电计算机的弊端随着人口爆炸型增长，贸易开启、战争需求以及对科学工程更高级的研究，人们对数据计算的要求越来越高。打卡式的机电计算机的出现，代替了人们手工式的计算，极大的提高了计算效率。 世界上最大的机电计算机之一是由 IBM 公司在 1944 年生产的“哈佛马克一号”，这部计算机重达 4500 公斤，由 76 万 5 千个组件，300 万个连接点以及 800 多公里长的导线组成。并且，为了保持它内部的机械装置同步，有一个 15 米长的连接杆将其连接起来，并由一台 5 马力的电机来驱动。 哈佛马克一号的左边部分 哈佛马克一号的右边部分 机电计算机的大脑是继电器，这是一种电控制器件，当接通控制电流的电路的时候，会控制继电器中的机械臂闭合电路，从而使目标器件通电。在机电计算机中，利用继电器来控制电机的运动，来完成计算的目的。 继电器工作原理 然而继电器中的机械臂是有质量的，这导致其无法快速翻转。在 1940 年代，一个好的继电器大概每秒能翻转 50 次左右。在哈佛马克一号上，1 秒钟大约能做 3 次加法，乘法需要 6 秒，除法则需要 15 秒，而做类似三角函数的复杂计算需要的时间达到了 1 分钟以上。 另外，继电器是也是一种机械设备，那么机械的磨损也不可避免，而继电器的损坏会直接造成计算错误。在哈佛马克一号中大约有 3500 个继电器，即使每个继电器的寿命能达到 10 年，平均每天都需要更换一个继电器。 最后，大型机电计算机持续地运转，造成机器温度较高，而吸引了许多昆虫。当时的工作人员排除计算机故障时，从中拖出了大量的死虫子（bug），这也是计算机术语 “bug” 的由来。 电子计算机的开端机电计算机的弊端和上限，让人们必须去寻找更快速稳定的计算机器。还好，科学家们早有准备，John Ambrose Fleming 早在 1904 年就发明了热电子管。 电子管是一种玻璃制成的真空管。把两个电极放在真空管中，其中一个电极可以加热，从而发射电子，让另一个电极带上正电荷吸引电子，就可以形成电流，这种让电子单向流动部件就叫做二极管。 但是如果要用于计算，我们还需要控制电流的开关。Lee de Forest 1906 年在二极管之间加入了控制电极，制作出了三极管。如果向控制电极施加正电荷，则电子就会流动，反之如果施加负电荷，则会阻止电子流动，用于达到控制电路闭合或断开的功能。 电子三极管原理 电子管内没有“机械臂”的运动，减少了磨损，并大大提高了速度，它每秒可以闭合断开电路数千次。电子管逐步运用到计算机中，标志着电子计算机的开端。 1943 年 12 月，Tommy Flowers 设计出了第一个用真空管的计算机“巨人一号”，在英国的“布莱切利园”用于破解纳粹通信密码。它采用了 1600 个真空管，通过插入预先设置好的程序板来进行计算，被认为是第一个可编程的计算机。顺便提一下，两年前，Alan Mathison Turing（阿兰·图灵）也在同一个地方用机电计算机“BOMBE”破解纳粹的英格玛密码。 而 1946 年在宾夕法尼亚大学制造的电子数值积分计算机“ENIAC”，则被认为是第一个真正通用，可编程的电子计算机。它每秒可以进行 5000 次十位数加减法，据统计，在它运行的 10 年中，计算量比之前全人类加起来的计算量都多。 ENIAC 电子管作为电子计算机及各类电子器件的基础，持续了半个世纪之久。然而电子管也有很大的缺陷：它脆弱易碎，并且像灯泡一样会烧坏。在 ENIAC 中，因为电子管的数量巨大，平均每半天就会有一个电子管被烧坏。 现代电子计算机的基础为了进一步降低计算成本，提高计算的可靠性，人们还需要一种新的电子开关。直到 1947 年，贝尔实验室的科学家们发明了晶体管。 晶体管也是一种电子开关，它有两个电极，电极中间有一层有时导电，有时不导电，因此被称为半导体的材料。通过加入一个“门电极”，通过改变门电极上的电荷，我们可以控制半导体材料的导电性，来开关电路。 晶体三极管工作方式 贝尔实验室的第一个晶体管每秒就可以开关上万次。而且，比起玻璃制成的电子管，晶体管是固态的。同时，比起电子管来说，晶体管的体积远远比电子管小，导致了更小更便宜并且更稳定的计算机成为了可能。 电子管（左）与晶体管（右）对比 IBM 1957 年制造出来的 IBM608 是第一个完全采用晶体管制造的计算机。它大约采用了 3000 个晶体管，每秒钟可以进行 4500 次加减法或 80 次乘除法的运算。 IBM 608 IBM 很快把所有的产品都采用了晶体管，大大减小计算机的体积和价格，使计算机逐渐进入了办公室与家庭。 如今，晶体管的普遍体积均小于 50 纳米，甚至可以达到 7 纳米的程度（要知道一张纸的厚度大概等于 10 万纳米！），并且每秒至少能切换上百万次。 因为很多开发半导体与晶体管的公司在加州的“圣克拉拉谷”，而生产半导体的常见材料是硅，所以人们把这里称为“硅谷”。William Shockly 搬到这里，创立了“肖克利半导体”，里面的员工后来成立了“仙童半导体”，仙童半导体里面的员工后来创立出了“英特尔”——当今世界上最大的计算机芯片制造商。 之后从继电器到电子管再到晶体管，我们让计算机的控制部分变得非常地快，并且大大减少了体积和成本。但我们如何用晶体管代替机械设备来做运算，从而减少机械磨损呢？我们在接下来解释这个问题。","link":"/article/theory/electronic-computer/"},{"title":"我不再使用 React.setState 的 3 个理由","text":"Michel Weststrate published in CloudBoost · Jun 15, 2016 自几个月前，我已在所有我新写的 React 组件弃用 React 的 setState 。别误会我，我没有弃用本地组件状态，我只是不再用 React 去管理它，并且令人愉快！ 使用 setState 对初学者来说很棘手。即使经验丰富的 React 程序员在使用 React 自有状态机制时，也很容易引入微妙的 bug，例如： 忘记 React 状态是异步的而引入了 bug，日志输出总是在后面一项。 这篇优秀的 React 文档总结了错误使用 setState 的各种情况： 总的来说，使用 setState 有三种问题： 1. setState 是异步的很多开发者一开始没有意识到这一点，但 setState 是 异步的 。如果你设置一些状态后再查看一下，你将仍看到旧状态。这是 setState 最棘手的部分。setState 调用看起来不像异步的，天真地调用 setState 会引入非常微妙的 bug。接下来的 gist 非常好地演示了这一点： class Select extends React.Component { constructor(props, context) { super(props, context); this.state = { selection: props.values[0] }; } render() { return ( &lt;ul onKeyDown={this.onKeyDown} tabIndex={0}&gt; {this.props.values.map(value =&gt; ( &lt;li className={value === this.state.selection ? \"selected\" : \"\"} key={value} onClick={() =&gt; this.onSelect(value)} &gt; {value} &lt;/li&gt; ))} &lt;/ul&gt; ); } onSelect(value) { this.setState({ selection: value }); this.fireOnSelect(); } onKeyDown = e =&gt; { const { values } = this.props; const idx = values.indexOf(this.state.selection); if (e.keyCode === 38 &amp;&amp; idx &gt; 0) { /* 上 */ this.setState({ selection: values[idx - 1] }); } else if (e.keyCode === 40 &amp;&amp; idx &lt; values.length - 1) { /* 下 */ this.setState({ selection: values[idx + 1] }); } this.fireOnSelect(); }; fireOnSelect() { if (typeof this.props.onSelect === \"function\") this.props.onSelect(this.state.selection); /* 不是你预期的…… */ } } ReactDOM.render( &lt;Select values={[\"状态\", \"应该\", \"是\", \"同步的\"]} onSelect={value =&gt; console.log(value)} /&gt;, document.getElementById(\"app\") ); 猛地一看，这可能看起来还不错。两个事件处理器和一个工具函数在 onSelect 存在时触发事件。然而，这个 Select 组件有个 bug，在上面的 GIF 图中被很好地演示。 onSelect 总是带着 state.selection 旧值被触发，因为 fireOnSelect 工具函数执行时，setState 还 没做完他的工作。我认为此处 React 至少可以把这个方法改名为 _scheduleState_，或让回调参数变成必填。 这个 bug 很容易修复，最棘手的部分是意识到它在这儿。 编辑于 2018 年 1 月 25 日： Dan Abramov 已经热心地写下一个广为人知而有力的 解释 ，从设计的角度讲为什么 setState 是异步的。 2. setState 引起没必要的渲染使用 setState 的第二个问题是，它总会触发重渲染。通常这些重渲染是不必要的。你可以使用 React 性能工具中的 printWasted 方法来找出它什么时间发生。但粗略地讲，有几种原因是一次重渲染为什么可能是不必要的： 新状态实际上和之前的一模一样。这通常可以通过实现 shouldComponentUpdate 来解决。你可能已经使用了一个（纯渲染）库来解决。 有时改变的状态与渲染有关，但并不是所有情况都是。比如当有些数据只条件性可见。 第三，正如 Aria Buckles 在 React Europe 2015 上的演讲所指出的那样，有时候实例状态根本与渲染无关！这通常是与管理事件监听器、计时器 ID 等相关的家务状态。 3. setState 无法捕获所有组件状态接上面最后一点，不是所有组件状态都应该用 setState 存储和更新。更多复杂组件通常有基于生命周期钩子的管理需求，去管理计时器、网络请求和事件等。用 setState 管理这些不仅引起不必要的渲染，还会引起相关生命周期钩子被重新触发，引起奇怪的问题。 用 MobX 管理本地组件状态（惊喜，惊喜）在 Mendix，我们已经依赖 MobX 管理我们所有的状态存储。然而，我们曾使用 React 自有状态机制来处理本地组件状态。最近，我们已经切换到用 MobX 管理本地组件状态。它看起来就像这样： import { observable } from \"mobx\"; import { observer } from \"mobx-react\"; @observer class Select extends React.Component { @observable selection = null; /* MobX 管理的实例 state */ constructor(props, context) { super(props, context); this.selection = props.values[0]; } render() { return ( &lt;ul onKeyDown={this.onKeyDown} tabIndex={0}&gt; {this.props.values.map(value =&gt; ( &lt;li className={value === this.selection ? \"selected\" : \"\"} key={value} onClick={() =&gt; this.onSelect(value)} &gt; {value} &lt;/li&gt; ))} &lt;/ul&gt; ); } onSelect(value) { this.selection = value; this.fireOnSelect(); } onKeyDown = e =&gt; { const { values } = this.props; const idx = values.indexOf(this.selection); if (e.keyCode === 38 &amp;&amp; idx &gt; 0) { /* 上 */ this.selection = values[idx - 1]; } else if (e.keyCode === 40 &amp;&amp; idx &lt; values.length - 1) { /* 下 */ this.selection = values[idx + 1]; } this.fireOnSelect(); }; fireOnSelect() { if (typeof this.props.onSelect === \"function\") this.props.onSelect(this.selection); /* 解决啦！ */ } } ReactDOM.render( &lt;Select values={[\"状态\", \"应该\", \"是\", \"同步的\"]} onSelect={value =&gt; console.log(value)} /&gt;, document.getElementById(\"app\") ); 为了完整性的缘故： 当使用一个同步状态机制时，没有未预期的 bug。 上面的代码片段不但更简洁，MobX 也解决了所有 setState 相关问题： 对状态的改变被立即反应到本地组件状态，让我们的逻辑更简单、代码复用更容易。你不必找补“状态可能还没更新”的事实。 MobX 在运行时确定哪些可观察量与渲染相关。所以，暂时与渲染无关的可观察量将不会触发重渲染，直到它们重新相关为止。因此，当把渲染无关的类属性变为 @observable时，也完全不存在渲染惩罚（或生命周期问题）。 所以，可渲染和不可渲染的状态都能被统一处理。同时，现在我们组件存储的状态和存在其它存储的状态工作方式一模一样。这让重构组件有些琐碎，并移动本地组件状态进一个独立存储，反之亦然。详见这个 egghead 教程的演示。 MobX 高效地把你的组件转化为小型 store 此外，当为 state 应用 observable 时，不会再犯直接向 state 对象赋值的菜鸟错误了。哦，不再操心实现 shouldComponentUpdate 或 PureRenderMixin_，MobX 已处理好这些。最后，你可能好奇，如果我想等到 _setState 完成呢？嗯，你仍可用 compentDidUpdate 生命周期钩子来实现。 听起来好酷！我如何开始使用 MobX？非常简单，照着 10 分钟交互介绍 或观看前述视频。你可以简单地从你的代码库挑一个组件，把 @observer 拍在上面，并引入一些 @observable 属性。你甚至都不需要替换你现有的 setState 调用，当使用 MobX 时它们依然可用。尽管不出几分钟你可能就会发现它们是如此复杂，无论如何你将会把它们换掉 🙂。（哦，如果你不喜欢装饰器，不用担心，它也适用于 ES5）。 长话短说：我已不再用 React 管理本地组件状态，我用 MobX 代替，现在 React 就真的成了“仅为视图”🙂。MobX 现在同时管理本地组件状态和 store 状态。它是简洁的、同步的、高效的和统一的。从经验来看，我发现 MobX 比 React 自有 setState 更容易向 React 初学者解释，它让我们的组件干净而简单。 把 setState 用于状态管理的 JSBin 把 MobX observables 用于状态管理的 JSBin 译者后记MobX 之父这篇文章给我的启发不限于废弃 React 类组件的 this.setState()，更提醒我 —— MobX 装饰器 API 的设计是为了增强 ECMAScript class，为面向对象前端代码提供响应式状态管理，而非发明一套全新的写法。 因此，一切基于 class 的组件引擎均可用 MobX 管理组件内外部状态。而基于类继承的 Web components 不但完全兼容 MobX 装饰器 API，其 DOM props（元素对象属性）的可变数据特性则更是与 MobX 的响应式状态完美契合！ 于是，在通读全文、醍醐灌顶之后，我遵循上述思路，一气呵成地在 2022 年正月十五重写出了 WebCell v3 原型版。接下来的两年虽因忙于创业公司而搁置开发，但在 React 生态中对原文 MobX 思想的深入实践，为 2024 新年一个月的闭关重写提供了丰富的设计经验。 最后，原文中的 React + MobX + JS 代码若改写为 WebCell + MobX + TS，同样简洁清晰： import { DOMRenderer } from \"dom-renderer\"; import { observable } from \"mobx\"; import { WebCell, attribute, component, observer } from \"web-cell\"; interface SelectProps { values: string[]; } interface Select extends WebCell&lt;SelectProps&gt; {} @component({ tagName: \"wc-select\" }) @observer class Select extends HTMLElement implements WebCell&lt;SelectProps&gt; { @attribute @observable accessor values: string[] = []; /* MobX 管理的实例 props */ @observable accessor selection = this.values[0]; /* MobX 管理的实例 state */ render() { const { values, selection } = this; return ( &lt;ul tabIndex={0} onKeydown={this.onKeyDown}&gt; {values.map(value =&gt; ( &lt;li key={value} className={value === selection ? \"selected\" : \"\"} onClick={() =&gt; this.onSelect(value)} &gt; {value} &lt;/li&gt; ))} &lt;/ul&gt; ); } onSelect(value: string) { this.selection = value; this.fireOnSelect(); } onKeyDown = ({ key }: KeyboardEvent) =&gt; { const { values } = this; const index = values.indexOf(this.selection); if (key === \"ArrowUp\" &amp;&amp; index &gt; 0) { this.selection = values[index - 1]; } else if (key === \"ArrowDown\" &amp;&amp; index &lt; values.length - 1) { this.selection = values[index + 1]; } this.fireOnSelect(); }; fireOnSelect() { this.emit(\"select\", this.selection); } } new DOMRenderer().render( &lt;Select values={[\"状态\", \"应该\", \"是\", \"同步的\"]} onSelect={({ detail }: CustomEvent) =&gt; console.log(detail)} /&gt;, document.querySelector(\"#app\") );","link":"/article/translation/3-reasons-why-i-stopped-using-react-setstate/"},{"title":"你应该使用的现代 Git 命令和功能","text":"我们所有软件工程师每天都在使用 git，但大多数人只接触过最基本的命令，如 add、commit、push 或者 pull，好像还停留在 2005 年。 不过，Git 从那时起引入了许多功能，使用它们能让你的生活变得更轻松，下面就让我们来了解一下最近添加的一些现代 Git 命令。 Switch自 2019 年以来，或者更准确地说，自 Git 2.23 版引入以来，我们可以使用 git switch 来切换分支： git switch other-branch git switch - # 切换回上一个分支，类似于 \"cd -\" git switch remote-branch # 直接切换到远程分支并开始跟踪 git checkout 是一个非常灵活的命令。它可以（除其他外）签出或恢复特定文件甚至特定提交，而新的 git switch 只能切换分支。此外，switch 还会执行额外的正确性检查，而 checkout 则不会，例如，如果会导致本地改动丢失，switch 就会中止操作。 RestoreGit 2.23 版新增的另一个子命令/功能是 git restore，我们可以用它将文件恢复到上次提交的版本： # 取消对文件的修改，与 \"git reset some-file.py\" 相同 git restore --staged some-file.py # 取消并丢弃对文件所做的更改，与 \"git checkout some-file.py\" 相同 git restore --staged --worktree some-file.py # 将文件恢复到之前的某个提交，与 \"git reset commit -- some-file.py\" 相同 git restore --source HEAD~2 some-file.py 上述代码段中的注释解释了各种 git restore 使用。一般来说， git restore 替换和简化 git reset 和 git checkout 的使用场景，它们的功能过于复杂。关于 revert、restore 和 reset 的比较，请参阅本文档。 Sparse Checkout下一个是 git sparse-checkout，这是在 2020 年 1 月 13 日发布的 Git 2.25 中添加的一个不起眼的功能。 比方说，你有一个大的 monorepo，其中的微服务被分隔到各个目录中，由于版本库太大，checkout 或 status 等命令执行起来超级慢，但也许你真的只需要处理单个子树/目录。那么，git sparse-checkout 就能帮到你： $ git clone --no-checkout https://github.com/derrickstolee/sparse-checkout-example $ cd sparse-checkout-example $ git sparse-checkout init --cone # 配置 git， 只匹配根目录下的文件 $ git checkout main # 只检出根目录中的文件 $ ls bootstrap.sh LICENSE.md README.md $ git sparse-checkout set service/common $ ls bootstrap.sh LICENSE.md README.md service $ tree . . ├── bootstrap.sh ├── LICENSE.md ├── README.md └── service ├── common │ ├── app.js │ ├── Dockerfile ... ... 在上面的例子中，我们首先 clone repo，但并没有 checkout 所有文件。然后使用 git sparse-checkout init --cone 配置 git 只匹配仓库根目录下的文件。这样，在运行签出后，我们只有 3 个文件，而不是整棵树。要下载/检出特定目录，我们使用 git sparse-checkout set .... 如前所述，这在本地处理庞大的版本库时非常方便，但在 CI/CD 中，当你只想构建/部署 monorepo 的一部分，而不需要检出所有内容时，这对提高流水线性能同样有用。 有关 sparse-checkout 的详细介绍，请参阅本文。 Worktree一个人可能需要同时在单个应用程序（版本库）中开发多个功能，或者当你正在处理某个功能请求时，可能会出现一个 critical 级别的错误，这种情况并不少见。 在这种情况下，您要么需要克隆多个版本/分支的版本库，要么就需要隐藏/丢弃当时正在处理的内容。2018 年 9 月 24 日发布的 git worktree 就是解决这些情况的办法： git branch # * dev # master git worktree list # /.../some-repo ews5ger [dev] git worktree add -b hotfix ./hotfix master # 准备 worktree (new branch 'hotfix') # HEAD 现在是 5ea9faa 已签名提交。 git worktree list # /.../test-repo ews5ger [dev] # /.../test-repo/hotfix 5ea9faa [hotfix] cd hotfix/ # 干净的 worktree, 你可以在其中进行修改并推送 该命令允许我们同时签出同一版本库的多个分支。在上面的例子中，我们有两个分支 dev 和 master。假设我们正在开发分支中开发功能，但有人告诉我们要进行紧急错误修复。与其将更改存储起来并重置分支，不如在主分支的 ./hotfix 子目录下创建一个新的 worktree。然后，我们就可以移动到该目录，进行修改、推送并返回到原始 worktree。 更多详细内容，请参阅本文。 Bisect最后但并非最不重要的是 git bisect，它并不新鲜（Git 1.7.14，2012 年 5 月 13 日发布），但大多数人只使用 2005 年左右的 git 功能，所以我觉得还是值得展示一下。 正如文档页面所描述的：git bisect，使用二进制搜索查找引入错误的提交： git bisect start git bisect bad HEAD # 提供出问题的提交 git bisect good 479420e # 提供你知道正常运行的提交 # Bisecting: 2 revisions left to test after this (roughly 1 step) # [3258487215718444a6148439fa8476e8e7bd49c8] Refactoring. # 测试当前提交... git bisect bad # If the commit doesn't work git bisect good # If the commit works # 根据最后一条命令，Git 在 bad 与 good 之间进行二分查找 # 继续测试直到找原因 git bisect reset # 重置为初始提交 我们先用 git bisect start 显式启动分段会话，然后提供不工作的提交（bad 的提交，很可能是 HEAD）和最后一次已知的正常运行提交或标记。有了这些信息，git 就会检查出介于 bad 和 good 提交之间的一个提交。这时，我们需要测试该版本是否存在漏洞，然后用 git bisect good 告诉 git 它能正常工作，或用 git bisect bad 告诉 git 它不能正常工作。我们不断重复这个过程，直到没有提交，git 就会告诉我们哪个提交引入了问题。 我建议你去文档页面看看，那里有更多关于 git bisect 的选项，包括可视化、重放或跳过提交。 如果你搜索一些与 git 相关的问题，你很可能会在 StackOverflow 上找到有几千个向上投票的答案的问题。虽然这个答案很可能仍然有效，但很可能已经过时，因为它是 10 年前写的。因此，可能还有更好、更简单、更容易的方法。因此，当遇到一些 git 问题时，我建议查看 git 文档，了解最新的命令，这些命令都有很多很好的示例，或者浏览 man 页面，了解多年来添加到老命令中的很多标记（flags）和选项（options）。","link":"/article/translation/modern-git-commands-and-features-you-should-be-using/"},{"title":"对 Python 对环境管理和包管理工具的一次公正评估","text":"Anna-Lena Popkes 动机当我开始使用 Python 并创建我的第一个包时，我感到困惑。创建和管理一个包比我预期的要困难得多。此外，存在多种工具，我不确定该使用哪一个。我相信你们中的大多数人过去也遇到过同样的问题。Python 有大量的工具来管理虚拟环境和创建包，要理解哪一个最适合你的需求可能很难（或几乎不可能）。关于这个话题存在多个演讲和博客文章，但没有一个提供完整的概览或以结构化的方式评估这些工具。这就是本文的目的。我想给你一个真正无偏见的评价，关于现有的打包和环境管理工具。如果你宁愿观看一个演讲，可以看看 PyCon DE 2023 或 EuroPython 2023 的录像。 分类为了撰写本文，我确定了环境和软件包管理的五大重要类别： 环境管理（主要涉及虚拟环境） 软件包管理 Python 版本管理 软件包构建 软件包发布 正如你在下面的维恩图中所看到的，存在大量的工具。有些可以做一件事（即它们是单一用途的），而其他工具可以执行多个任务（因此我称它们为多用途工具）。 让我们从开发者的角度来逐一介绍这些类别。假设您除了工作项目之外，还在进行个人项目。在工作中，您使用的是 Python 3.7，而您的个人项目应该使用最新的 Python 版本（目前是 3.11）。换句话说：您希望能够安装不同的 Python 版本并在它们之间切换。这就是我们的第一个类别，Python 版本管理的意义所在。 在您的项目中，您会使用其他软件包（例如用于数据科学的 pandas 或 sklearn）。这些是您项目的依赖项，您必须安装和管理它们（例如，在新版本发布时进行升级）。这就是软件包管理的意义所在。 由于不同的项目可能需要相同软件包的不同版本，因此您需要创建（和管理）虚拟环境以避免依赖项冲突。用于此目的的工具被归类在环境管理类别中。大多数工具使用虚拟环境，但有些工具使用另一种称为本地软件包的概念，我们将在后面介绍。 一旦您的代码处于适当的状态，您可能希望与其他开发人员共享它。为此，您必须先构建您的软件包（软件包构建），然后才能将其发布到 PyPI 或其他索引（软件包发布）。 接下来，我们将更详细地了解每个类别，包括简短的定义、动机和可用工具。我将更详细地介绍一些单一用途的工具，并在最后的部分单独介绍几种多用途工具。让我们从第一个类别开始：Python 版本管理。 Python 版本管理定义能够控制 Python 版本管理的工具，允许您安装 Python 版本并轻松地在它们之间切换。 动机我们为什么要使用不同的 Python 版本？ 有几个原因。 例如，您可能正在处理多个项目，其中每个项目都需要不同的 Python 版本。 或者您可能正在开发一个支持多个 Python 版本的项目，并且您想要测试所有这些版本。 除此之外，查看最新的 Python 版本提供了什么，或者测试 Python 的预发布版本是否存在错误也是一件好事。 工具我们的维恩图显示了可用于 Python 版本管理的工具：pyenv、conda、rye 和 PyFlow。我们将首先看看 pyenv，并在单独的部分中考虑多用途工具。 PyEnvPython 有一个单一用途的工具可以让您安装和管理 Python 版本：pyenv！ PyEnv 易于使用。 最重要的命令如下： # Install specific Python version pyenv install 3.10.4 # Switch between Python versions pyenv shell &lt;version&gt; # select version just for current shell session pyenv local &lt;version&gt; # automatically select version whenever you are in the current directory pyenv global &lt;version&gt; # select version globally for your user account Virtual environment management（虚拟环境管理）定义环境管理工具可以创建和管理（虚拟）环境。 动机我们为什么首先要使用环境？ 正如开头所提到的，项目有特定的要求（即它们依赖于其他包）。 通常情况下，不同的项目需要相同包的不同版本。 这会导致依赖冲突。 此外，使用 pip install 安装包时可能会出现问题，因为该包与您的系统范围内的 Python 安装放在一起。 其中一些问题可以通过在 pip 命令中使用 --user 标志来解决。 但是，这个选项可能不是每个人都知道，尤其是初学者。 工具许多工具允许用户创建和管理环境。 它们是：venv、virtualenv、pipenv、conda、pdm、poetry、hatch、rye 和 PyFlow。 其中只有两个是单一用途的工具：venv 和 virtualenv。 让我们更详细地了解它们。 VEnvVEnv 是用于创建虚拟环境的内置 Python 包。 这意味着它随 Python 一起提供，用户无需安装。 最重要的命令如下： # Create new environment python3 -m venv &lt;env_name&gt; # Activate an environment . &lt;env_name&gt;/bin/activate # Deactivate an active environment deactivate VirtualEnvVirtualEnv 试图改进 venv。 它提供了比 venv 更多的功能，并且速度更快、功能更强大。 最重要的命令与 venv 的命令类似，只是创建一个新环境更简洁： # Create new environment virtualenv &lt;env_name&gt; # Activate an environment . &lt;env_name&gt;/bin/activate # Deactivate an active environment deactivate 回顾 1 - pyproject.toml在讨论打包之前，我想确保你了解打包最重要的文件：pyproject.toml。 Python 中的打包已经走过了漫长的道路。直到 PEP 518 setup.py 文件被用于打包，使用 setuptools 作为构建工具。PEP 518 引入了 pyproject.toml 文件的使用。因此，在创建包时，你始终需要一个 pyproject.toml 文件。pyproject.toml 用于定义项目的设置、定义元数据以及许多其他内容。如果你想查看示例，请查看 pandas 库的 pyproject.toml 文件。了解了 pyproject.toml 后，我们可以继续看看包管理。 包管理定义能够执行包管理的工具能够下载和安装库及其依赖项。 动机为什么我们关心包？包允许我们定义模块的层次结构，并使用点语法（from package.module import my_function）轻松访问模块。此外，它们使得与其他开发者共享代码变得容易。由于每个包都包含一个定义其依赖项的 pyproject.toml 文件，其他开发者不必单独安装所需的包，而是可以直接从其 pyproject.toml 文件安装包。 工具许多工具都可以执行包管理：pip、pipx、pipenv、conda、pdm、poetry、rye 和 PyFlow。pip 是 Python 社区中众所周知的专用包管理工具。 PIPPython 的标准包管理器是 pip。它随 Python 一起提供，允许你从 PyPI 和其他索引安装软件包。主要命令（可能是 Python 开发人员学习的第一个命令之一）是 pip install &lt;package_name&gt;。当然，pip 还提供了许多其他选项。查看文档以获取有关可用标志等的更多信息。 回顾 2 - Lock file在我们继续讨论多用途工具之前，还有一个对打包很重要的文件：锁文件。pyproject.toml 包含抽象依赖项，而锁文件包含具体依赖项。它记录了为项目安装的所有依赖项的确切版本（例如 pandas==2.0.3）。这使得项目能够在多个平台上重现。如果你以前从未见过锁文件，请查看这个来自 poetry 的文件： 多用途的工具了解了锁文件之后，我们可以开始研究执行多用途的工具。我们将从 pipenv 和 conda 开始，然后再过渡到 poetry 和 pdm 等打包工具。 PipEnv顾名思义，pipenv 结合了 pip 和 virtualenv。正如我们在维恩图中看到的，它允许你执行虚拟环境管理和包管理： pipenv 引入了两个额外的文件： Pipfile Pipfile.lock Pipfile 是一个 TOML 文件（类似于 pyproject.toml），用于定义项目依赖项。当开发者调用 pipenv 命令（如 pipenv install）时，它由开发者管理。Pipfile.lock 允许确定性构建。它消除了对 requirements.txt 文件的需求，并通过锁定操作自动管理。 最重要的 pipenv 命令是： # Install package pipenv install &lt;package_name&gt; # Run Python script within virtual env pipenv run &lt;script_name.py&gt; # Activate virtual env pipenv shell CondaConda 是一个通用的包管理系统。这意味着它不局限于 Python 包。Conda 是一个功能强大的工具，拥有许多功能。有许多教程和博客文章（例如官方教程），因此我在这里不再赘述。但是，我想提一点：虽然可以使用 conda 构建和发布包，但我没有将该工具包含在相应的类别中。这是因为使用 conda 打包的工作方式略有不同，生成的包将是 conda 包。 功能评估最后但同样重要的是，我想介绍一些用于打包的多功能工具。我承诺进行公正的评估。为此，我创建了一个我认为在比较不同工具时很重要的功能列表。这些功能包括： 该工具是否管理依赖项？ ? 它是否解析/锁定依赖项？ ? 是否有干净的构建/发布流程？ ? 它是否允许使用插件？ ? 它是否支持 PEP 660（可编辑安装）？ ? 它是否支持 PEP 621（项目元数据）？ ? 关于这两个 PEP：Python 在打包方面有很多开放和关闭的 PEP。有关完整概述，请查看此页面。我仅出于特定原因包含了 PEP 660 和 PEP 621： PEP 660 是关于基于 pyproject.toml 构建的可编辑安装。当你使用 pip 安装软件包时，你可以选择使用 pip install -e package_name 以可编辑模式安装它。当你正在开发一个软件包并希望你的更改直接反映在你的环境中时，这是一个非常重要的功能。 PEP 621 指定了如何在 pyproject.toml 文件中写入项目的核心元数据。我添加它是为了说明，目前有一个软件包（剧透：它是 poetry）不支持此 PEP，而是使用自己的方式声明元数据。 FlitFlit 试图创建一个将 Python 包和模块放到 PyPI 上的简单方法。它有一个非常具体的用例：它旨在用于打包纯 Python 包（即没有构建步骤的包）。它不关心任何其他任务： Python 版本管理：❌ 包管理：❌ 环境管理：❌ 构建包：✅ 发布包：✅ 这也反映在我们的维恩图中： 功能评估 该工具是否管理依赖项？ ❌ 它是否解析/锁定依赖项？ ❌ 是否有干净的构建/发布流程？ ✅ 它是否允许使用插件？ ❌ 它是否支持 PEP 660（可编辑安装）？ ✅ 它是否支持 PEP 621（项目元数据）？ ✅ 主要命令# Create new pyproject.toml flit init # Build and publish flit publish PoetryPoetry 是打包界中一个众所周知的工具。正如维恩图所示，除了 Python 版本管理之外，它可以做任何事情： Python 版本管理：❌ 包管理：✅ 环境管理：✅ 构建包：✅ 发布包：✅ 查看下面的功能评估，您会发现 Poetry 不支持 PEP 621。在 GitHub 上有一个关于此的开放问题大约 1.5 年了，但它还没有被集成到主代码库中（还）。 功能评估 该工具是否管理依赖项？ ✅ 它是否解析/锁定依赖项？ ✅ 是否有干净的构建/发布流程？ ✅ 它是否允许使用插件？ ✅ 它是否支持 PEP 660（可编辑安装）？ ✅ 它是否支持 PEP 621（项目元数据）？ ❌ 主要命令# Create directory structure and pyproject.toml poetry new &lt;project_name&gt; # Create pyproject.toml interactively poetry init # Install package from pyproject.toml poetry install 依赖管理# Add dependency poetry add &lt;package_name&gt; # Display all dependencies poetry show --tree 运行代码# Activate virtual env poetry shell # Run script within virtual env poetry run python &lt;script_name.py&gt; Lock file首次安装软件包时，Poetry 会解析 pyproject.toml 文件中列出的所有依赖项，并下载软件包的最新版本。Poetry 完成安装后，它会将所有软件包及其下载的确切版本写入 poetry.lock 文件，将项目锁定到这些特定版本。建议将锁定文件提交到项目仓库，以便所有参与项目的人员都锁定到相同版本的依赖项。要将依赖项更新到最新版本，请使用 poetry update 命令。 Build/publish flow（构建/发布流程）# Package code (creates `.tar.gz` and `.whl` files) poetry build # Publish to PyPI poetry publish PDMPDM 是一个相对较新的包和依赖管理器（始于 2019 年），它很大程度上受到 Poetry 和 PyFlow 的启发。您会注意到，我在这篇文章中没有谈论 PyFlow。这是因为 PyFlow 不再积极开发——在快速发展的打包领域中，这是一个必须的条件。作为一个更新的工具，PDM 需要 Python 3.7 或更高版本。与其他工具的另一个区别是 PDM 允许用户选择构建后端。 PDM 是唯一一个（除了 PyFlow）在本地包上实现 PEP 582 的工具，这是一种实现环境管理的替代方法。请注意，此 PEP 最近被拒绝。 如维恩图所示，PDM 位于 Poetry 旁边。这意味着它可以做除 Python 版本管理之外的所有事情： Python 版本管理：❌ 包管理：✅ 环境管理：✅ 构建包：✅ 发布包：✅ PDM 的主要命令与 Poetry 类似。但是，存在的命令较少。例如，目前没有 pdm shell 或 pdm new。 功能评估 该工具是否管理依赖项？ ✅ 它是否解析/锁定依赖项？ ✅ 是否有干净的构建/发布流程？ ✅ 它是否允许使用插件？ ✅ 它是否支持 PEP 660（可编辑安装）？ ✅ 它是否支持 PEP 621（项目元数据）？ ✅ 创建新项目# Create pyproject.toml interactively pdm init # Install package from pyproject.toml pdm install 依赖管理# Add dependency pdm add &lt;package_name&gt; # Display all dependencies pdm list --graph 运行代码# No pdm shell command # Run script within env pdm run python &lt;script_name.py&gt; Lock filePDM 的锁定功能类似于 Poetry。首次安装软件包时，PDM 会解析 pyproject.toml 文件中列出的所有依赖项，并下载软件包的最新版本。PDM 完成安装后，会将所有软件包及其下载的确切版本写入 pdm.lock 文件，将项目锁定到这些特定版本。建议将锁定文件提交到项目仓库，以便所有参与项目的人员都锁定到相同版本的依赖项。要将依赖项更新到最新版本，请使用 pdm update 命令。 Build/publish flow（构建/发布流程）# Package code (creates `.tar.gz` and `.whl` files) pdm build # Publish to PyPI pdm publish HatchHatch 可以执行以下任务： Python 版本管理：❌ 软件包管理：❌ 环境管理：✅ 构建软件包：✅ 发布软件包：✅ 需要注意的是，Hatch 的作者承诺很快就会添加锁定功能，这也应该能够实现软件包管理。 在阅读本文时，请务必查看最新版本的 Hatch，以了解是否已实现此功能。 功能评估 该工具是否管理依赖项？ ❌ 它是否解析/锁定依赖项？ ❌ 是否有干净的构建/发布流程？ ✅ 它是否允许使用插件？ ✅ 它是否支持 PEP 660（可编辑安装）？ ✅ 它是否支持 PEP 621（项目元数据）？ ✅ 创建一个新项目# Create directory structure and pyproject.toml hatch new &lt;project_name&gt; # Interactive mode hatch new -i &lt;project_name&gt; # Initialize existing project / create pyproject.toml hatch new --init 依赖管理# Packages are added manually to pyproject.toml hatch add &lt;package_name&gt; # This command doesn't exist! # Display dependencies hatch dep show table 运行代码# Activate virtual env hatch shell # Run script within virtual env hatch run python &lt;script_name.py&gt; Build/publish flow（构建/发布流程）# Package code (creates `.tar.gz` and `.whl` files) hatch build # Publish to PyPI hatch publish Declarative environment management（声明式环境管理）Hatch 的特别之处在于它允许您在 pyproject.toml 文件中配置您的虚拟环境。此外，它还允许您专门为某个环境定义脚本。这方面的一个示例用例是 代码格式化。 RyeRye 是由 Flask 框架的创建者 Armin Ronacher 最近开发的（第一个版本于 2023 年 5 月发布）。它的灵感很大程度上来自于 rustup 和 cargo，这两个都是 Rust 编程语言的打包工具。Rye 是用 Rust 编写的，并且能够执行我们维恩图中的所有任务： Python 版本管理：✅ 软件包管理：✅ 环境管理：✅ 构建软件包：✅ 发布软件包：✅ 目前，Rye 没有插件接口。但是，由于新版本会定期发布，因此将来可能会添加此功能。 功能评估 该工具是否管理依赖项？ ✅ 它是否解析/锁定依赖项？ ✅ 是否有干净的构建/发布流程？ ✅ 它是否允许使用插件？ ❌ 它是否支持 PEP 660（可编辑安装）？ ✅ 它是否支持 PEP 621（项目元数据）？ ✅ 创建一个新项目# Create directory structure and pyproject.toml rye init &lt;project_name&gt; # Pin a Python version rye pin 3.10 依赖管理# Add dependency - this does not install the package! rye add &lt;package_name&gt; # Synchronize virtual envs, lock file, etc. # This install packages and Python versions rye sync 运行代码# Activate virtual env rye shell # Run script within virtual env rye run python &lt;script_name.py&gt; Build/publish flow（构建/发布流程）# Package code (creates `.tar.gz` and `.whl` files) rye build # Publish to PyPI rye publish 概述 Flit Poetry PDM Hatch Rye 该工具是否管理依赖项？ ❌ ✅ ✅ ❌ ✅ 它是否解析/锁定依赖项？ ❌ ✅ ✅ ❌ ✅ 是否有干净的构建/发布流程？ ✅ ✅ ✅ ✅ ✅ 它是否允许使用插件？ ❌ ✅ ✅ ✅ ❌ 它是否支持 PEP 660（可编辑安装）？ ✅ ✅ ✅ ✅ ✅ 它是否支持 PEP 621（项目元数据）？ ✅ ❌ ✅ ✅ ✅ 不属于这些类别的工具有些工具不属于我的任何类别。它们是： pip-tools 帮助您保持基于 pip 的软件包版本最新。 tox 和 nox 主要用于测试，但也处理虚拟环境。 给本博文提供建议","link":"/article/translation/python-packaging-tools/"},{"title":"Python 潮流周刊#23：35 个容易上手的 Python 小项目","text":"你好，我是猫哥。这里每周分享优质的 Python、AI 及通用技术内容，大部分为英文。标题取自其中两则分享，不代表全部内容都是该主题，特此声明。 本周刊由 Python 猫 出品，精心筛选国内外的 250+ 信息源，为你挑选最值得分享的文章、教程、开源项目、软件工具、播客和视频、热门话题等内容。愿景：帮助所有读者精进 Python 技术，并增长职业和副业的收入。 微信 | 博客 | 邮件 | GitHub | Telegram | Twitter 本周刊的源文件归档在 GitHub 上，已收获 730+ star 好评，如果你也喜欢本周刊，就请给颗 star 支持一下吧：https://github.com/chinesehuazhou/python-weekly 🦄 文章&amp;教程1、20 个令人兴奋的 Python 项目创意 经常看到有人问：有没有简单易上手的 Python 项目推荐？不妨看看这篇文章，它介绍了 20 个小项目的想法，另外原作者已经实现了很多项目，源码可从文中的仓库地址获取。 2、Python 3.11 vs Python 3.12 之性能测试 文章在配备 AMD 锐龙 7000 系列和第 13 代英特尔酷睿处理器的不同机器上共进行了 91 种基准测试，详细给出了各项数值。 3、当我遇见了 Guido van Rossum 作者在今年 Pycascades 上做了演讲“Python 中用元类作元编程”，并遇见 Guido，他们聊了一些 Python 使用中的话题以及如何成为 CPython 核心开发者。 4、通过阅读代码学习：Python 标准库设计决策解释 程序员提升能力的一个方法是大量阅读优秀的代码，Python 标准库就是很好的选择。但标准库茫茫之多，该选择哪些呢？文章作者推荐了这些：statistics、pathlib、dataclasses、graphlib。 5、使用 Stripe、Vue.js 和 Flask 开发收款功能 国人的付费意愿差，独立开发者选择出海掘金的话，大多会选择用 Stripe 账号。这篇教程使用 Stripe 实现网站的收款功能，前后端技术栈为 Vue 和 Flask。 6、使用 Python 调用 Rust 的三种方法 介绍了 Python 调用 Rust 的三种方法：HTTP、IPC（进程间通信） 和 FFI（外部函数接口）。 7、如何开发 FastAPI 的中间件？ FastAPI 内置了一些中间件，但你可能还需要量身定制自己的中间件。文章介绍了 FastAPI 中间件原理及内置的中间件，然后基于函数和基于类来实现自定义中间件，给出了最佳实践建议以及相应的测试用例。 8、Django 项目实现无密码身份验证 文章介绍了三种无密码的身份验证方法：基于邮件的身份验证、使用 OAuth 进行身份验证和使用超链接进行身份验证；介绍了它们的优点、局限性以及使用的注意事项。 9、在发布 Python 项目前，建议用上这 4 个工具 有什么工具可以简化开发工作流程，遵循行业构建良好软件的最佳实践？文章分享了 4 种好用的工具：Poetry、Pre-commit 钩子、Makefiles、python-dotenv。 10、我们必须聊聊 Flask Flask 最近发布了 3.0 版本，Werkzeug 也同时发了 3.0 版本，但它引入了不向后兼容的更改！作者吐槽 Flask 总是出现版本不兼容的问题，给出了不少例子和原因分析，希望 Flask 核心开发不要做无端的重构，要三思而行。（文章出自《Flask Web Development》一书的作者） 11、基于 ProPainter 技术去除图片以及视频水印 介绍使用 ProPainter 框架来解决视频去水印问题，它引入了双域传播的新方法和一种高效的遮罩引导视频 Transformers，增强了视频修复的性能，同时保持了计算效率，成本更低。 12、Google Sheets 也能用 Python 了 微软在 8 月让 Excel 支持了 Python，现在一家名为 Neptyne 的公司推出了一款在 Google Sheets 中使用 Python 功能的产品。文章介绍了它的基本情况。 🎁Python 潮流周刊🎁 已免费发布了 23 期，访问下方链接，即可查看全部内容：https://pythoncat.top/tags/weekly 如果你觉得周刊有价值，请表达小小心意，赞赏一下猫哥吧~~ 🐿️ 项目&amp;资源1、一个 Python 知识问答网站 一个很简洁的网站，有近百道选择题，大多是 Python 基础语法相关的内容。来测一下你都学会了么？ 2、CardStock：跨平台的 GUI 构建工具 它提供了一个类似于绘图程序的编辑器，用于构建图形用户界面，支持文本、图形、图像、按钮、输入框和 Web 视图等元素；提供了一个代码编辑器，可添加事件驱动的 Python 代码。 3、python-package-template：标准化的 Python package 模板 它内置了单元测试、代码检查、格式化、包管理、pre-commit 配置、GitHub Actions 等众多方便的工具，可以很方便的管理 Python 项目。（投稿自@Undertone0809） 4、pipeless：一个计算机视觉框架 轻松构建与部署可实时分析及操作视频流的应用，无需构建和维护多媒体 pipeline。支持插件，例如使用 Kafka 实时处理事件、使用 YOLOv8 模型等。 5、RealtimeSTT：强大、高效、低延迟的语音转文本库 它具有高级语音活动检测、唤醒词激活和即时转录功能，使用的技术栈有：语音活动检测（WebRTCVAD、SileroVAD）、语音转文本（Faster Whisper）、唤醒词检测（Porcupine）。 6、Chrome-GPT：可控制 Chrome 的 AutoGPT 代理 它利用 Langchain 和 Selenium 使 AutoGPT 代理能够控制 Chrome 会话。支持以交互方式滚动、单击和输入网页上的文本，从而可以导航和操作 Web 内容。（star 1.4K） 7、ZenNotes：Windows 记事本，支持翻译和 TTS 一个简约的 Windows 记事本程序，支持翻译、TTS、Markdown，基于 PyQt-Fluent-Widgets 开发而成。 8、kr8s：用于 Kubernetes 的客户端库 用于 k8s 的一个简单、可扩展的 Python 客户端库，如果你用过 kubectl，就会觉得它很熟悉。 9、swirl-search：用 AI 同时搜索多个数据源 可搜索多个内容源并返回 AI 的排名结果，支持连接到数据库（SQL、NoSQL、Google BigQuery）、公共数据（谷歌、Arxiv）、企业数据源（Microsoft 365、Jira、Miro 等）。 10、sentry：面向开发者的错误跟踪和性能监控平台 一个强大的错误跟踪和性能监控平台，还支持定期任务监控、代码覆盖率、会话重播、告警、安全策略等功能，支持 100 多种平台和框架，支持 30+ 编程语言。（star 35.4K） 11、15 个 Python 小项目 这个仓库收录了一些 Python 小项目及其实现代码，跟本期周刊的第一则分享相似。（star 1K） 12、ssh-audit：SSH 服务器和客户端安全审计 用于审查 SSH 的配置，支持 SSH1 和 SSH2 协议，支持 Linux 和 Windows，可识别安全漏洞、不安全密钥、不安全算法等，并给出安全建议。另外它也有在线版本 。（star 2.6K） 🐢 播客&amp;视频1、哥本哈根 2023 Django Day 演讲视频 Django Day 是一个专门围绕 Django 框架和 Django 社区的活动，目前视频列表中有 11 则视频。 2、Talk Python To Me #434：用 Python 构建移动 APP Python 能够用于开发移动端应用么？能不能用 Python 实现端到端的移动应用开发？这期播客邀请了几个移动端 APP 的开发者聊了相关话题。 🐱 赞助&amp;支持如果你喜欢周刊，请分享给其他需要的同学，让更多人可以从中受益～ 如果你觉得周刊有价值，请随意赞赏 或 买杯咖啡 进行支持！ 如果你想帮助周刊办得更好，欢迎向我们投稿或提出建议：投稿/建议通道 如果你是品牌方或广告主，欢迎私信我，洽谈赞助与合作事项。 🐼 欢迎订阅 微信公众号：除更新周刊外，还发布其它原创作品，并转载一些优质文章。（可加好友，可加读者交流群） 博客 及 RSS：我的独立博客，上面有历年原创/翻译的技术文章，以及从 2009 年以来的一些随笔。 GitHub：你可以获取本周刊的 Markdown 源文件，做任何想做的事！ 邮件：在 Substack 上开通的频道，满足你通过邮件阅读时事通讯的诉求。 Telegram：除了发布周刊的通知外，我将它视为一个“副刊”，补充发布更加丰富的资讯。 Twitter：我的关注列表里有大量 Python 相关的开发者与组织的账号。","link":"/article/translation/python-trend-weekly-2023-10-22/"},{"title":"你正在错过的最新 Docker BuildKit 功能","text":"随着 BuildKit 的引入，Docker 的构建后端得到了显著改进，并增添了许多强大的新功能。然而，很多用户并不了解这些新功能。因此，本文将向你介绍那些你绝对应该了解并开始使用的 BuildKit 功能，助你更好地利用 Docker。 Debugging（调试）让我们从最常见的任务 - 调试 开始。一直以来，调试 docker build 都是一件痛苦的事情。当 RUN 或 COPY 命令失败时，你很难查看上下文并调试问题所在，通常只能求助于添加 RUN ls -la 等命令来获取更多信息。 然而，随着 docker buildx debug 的引入，这一切都将成为过去！ export BUILDX_EXPERIMENTAL=1 docker buildx debug --invoke /bin/sh --on=error build . [+] Building 1.2s (14/18) docker:default ... ------ &gt; [builder 5/6] RUN exit 1: ------ Dockerfile:10 -------------------- 8 | RUN pip3 install -r requirements.txt 9 | 10 | &gt;&gt;&gt; RUN exit 1 11 | 12 | COPY . /app -------------------- ERROR: process \"/bin/sh -c exit 1\" did not complete successfully: exit code: 1 [+] Building 0.0s (0/0) docker:default Launching interactive container. Press Ctrl-a-c to switch to monitor console Interactive container was restarted with process \"u6agxp1ywqapemxrt8iexfv4h\". Press Ctrl-a-c to switch to the new container / # ls -la total 72 drwxr-xr-x 1 root root 4096 May 5 12:59 . drwxr-xr-x 1 root root 4096 May 5 12:59 .. drwxr-xr-x 1 root root 4096 May 4 10:11 app ... 如上述代码片段所示，我们首先通过设置 BUILDX_EXPERIMENTAL 环境变量来启用实验性的 BuildKit 功能。然后，我们使用 docker buildx debug 命令启动构建过程。如果构建过程中的任何步骤发生错误，我们将自动进入容器内部，并可以自由探索上下文和进行调试。 需要注意的是，我们使用了 --on=error 选项，这表示只有在构建失败时才会启动调试会话。 调试文档，获取更多细节 环境变量如果你之前使用 BuildKit 运行过构建，你一定注意到了它那花哨的新日志输出格式。虽然看起来很漂亮，但在调试时却不太实用。 好消息是，我们可以通过设置一个环境变量来切换回简洁的日志输出格式： export BUILDKIT_PROGRESS=plain 你也可以将其设置为 rawjson ，虽然这种格式对人类来说绝对不可读，但如果你想以某种方式处理日志，它可能会很有用。 或者，如果你喜欢基于 TTY 的动态输出，但不喜欢默认的颜色，那么你可以通过以下方式更改它们： BUILDKIT_COLORS=\"run=green:warning=yellow:error=red:cancel=cyan\" docker buildx debug --invoke /bin/sh --on=error build . 会有如下输出: 查看 环境变量文档 导出容器BuildKit 还引入了 导出器(exporters) 的概念，它定义了如何保存构建的输出。其中两个最有用的选项是 image 和 registry。image 正如你所期望的那样，将输出保存为容器镜像，而 registry 导出器会自动将镜像推送到指定的镜像仓库： docker buildx build --output type=registry,name=martinheinz/testimage:latest . 我们只需要使用 --output 选项并指定类型为 registry 以及目标地址即可。此选项还支持一次指定多个镜像仓库： docker buildx build --output type=registry,\\\"name=docker.io/martinheinz/testimage,docker.io/martinheinz/testimage2\\\" . 最后，我们还可以提供 --cache-to 和 --cache-from 选项，例如使用镜像仓库中的现有镜像作为缓存源： docker buildx build --output type=registry,name=martinheinz/testimage:latest \\ --cache-to type=inline \\ --cache-from type=registry,ref=docker.io/martinheinz/testimage . ... =&gt; CACHED docker-image://docker.io/docker/dockerfile:1.4@sha256:9ba7531bd80fb0a8...1e24ef1a0dbc ... =&gt; CACHED [builder 2/5] WORKDIR /app 0.0s =&gt; CACHED [builder 3/5] COPY requirements.txt /app 0.0s =&gt; CACHED [builder 4/5] RUN --mount=type=cache,target=/root/.cache/pip pip3 install -r requirements.txt 0.0s =&gt; CACHED [builder 5/5] COPY . /app 0.0s =&gt; CACHED [dev-envs 1/3] RUN &lt; CACHED [dev-envs 2/3] RUN &lt; CACHED [dev-envs 3/3] COPY --from=gloursdocker/docker / / 0.0s =&gt; preparing layers for inline cache 0.0s ... 镜像工具docker buildx 有一个简单但方便的子命令叫做 imagetools，它允许我们在不拉取镜像的情况下检查镜像仓库中的镜像。文档 中包含许多示例，但对我来说最有用的是获取远程镜像的哈希值： docker buildx imagetools inspect alpine --format \"{{json .Manifest}}\" | jq .digest \"sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6b\" 最新的 Dockerfile 语法BuildKit 还通过所谓的 Dockerfile 前端 带来了新的 Dockerfile 语法。要启用当前最新的语法，我们需要在 Dockerfile 的顶部添加一个指令，例如： # syntax=docker/dockerfile:1.3 FROM ... 要查找版本，你可以查看 dockerfile-upstream。 Here-docs我想提到的第一个 Dockerfile 语法改进是 _here-docs_，它允许我们将多行脚本传递给 RUN 和 COPY 命令： # syntax = docker/dockerfile:1.3-labs FROM debian RUN &lt;","link":"/article/translation/recent-docker-buildkit-features/"},{"title":"67 个你的浏览器不想让你知道的奇怪调试技巧","text":"一份实用而不显眼的黑客高手列表，让您充分利用浏览器的调试器。假设您对开发工具有中级或更高程度的了解。 高级条件断点通过在您意想不到的地方使用会产生副作用的表达式（有预期之外的结果），我们可以从诸如条件断点等基本功能中榨取出更多的功能。 日志断点、跟踪断点例如，我们可以在断点中使用 console.log。日志断点是指不会暂停执行并将日志记录到控制台的断点。尽管 Microsoft Edge 已经内置了日志断点有一段时间，Chrome 则是在 v73 版本中才添加了这个功能，但 Firefox 却没有。不过，我们可以使用条件断点 (conditional breakpoints) 在任何浏览器中模拟这一功能。 如果您还想记录该行代码的执行次数，请使用 console.count 代替 console.log。 更新（2020 年 5 月）：所有主流浏览器现在都直接支持日志断点/跟踪断点 (Chrome Logpoints，Edge Tracepoints，Firefox Logpoints) 监视窗格您还可以在监视窗格中使用 console.log。例如，要在调试器中每次暂停应用程序时转储 localStorage 的快照，可以创建一个 console.table(localStorage) watch Pane： 或者，要在 DOM 突变后执行表达式，请设置 DOM 变化断点（在元素检查器 Element Inspector 中）： 然后添加观察表达式 (watch expression)，例如记录 DOM 的快照：(window.doms = window.doms || []).push(document.documentElement.outerHTML)。现在，在修改任何 DOM 子树之后，调试器将暂停执行，新的 DOM 快照将位于 window.doms 数组的最后一个。(没有办法创建不暂停执行的 DOM 突变断点)。 跟踪调用堆栈举个例子，你有一个 showSpinner 的函数和一个 hideSpinner 的函数，但在代码的某个地方，你调用 show 方法时没有调用匹配的 hide 方法。如何找到未配对显示调用的来源？在 show 方法的条件断点中使用 console.trace，运行代码，找到 show 方法的最后一次堆栈跟踪，然后点击调用者进入代码： 改变程序行为通过使用对程序行为有副作用的表达式，我们可以在浏览器中即时更改程序行为。 例如，你可以覆盖 getPerson 函数的参数 id。由于 id=1 的值为 true，这个条件断点会暂停调试器。为避免这种情况，可在表达式中添加 , false。 快速、简单的性能分析您不应该用条件断点 (conditional breakpoint) 评估时间之类的东西来性能分析，但如果您想快速而又肮脏地测量某个程序运行所需的时间，可以在条件断点中使用控制台计时 API。在起点设置一个条件为 console.time('label') 的断点，在终点设置一个条件为 console.timeEnd('label') 的断点。每次运行要测量的内容时，浏览器都会在控制台中记录运行时间。 利用函数的参数个数按参数个数中断只有在当前函数被调用并包含 3 个参数时才暂停：arguments.callee.length === 3 在重载函数 (overloaded function) 有可选参数时非常有用。 在函数参数个数不匹配时设置断点仅在调用当前函数时使用了错误的参数数时暂停：(arguments.callee.length) != arguments.length 在查找函数调用站点中的错误时非常有用。 运行时间跳过页面加载页面加载 5 秒后才暂停：performance.now() &gt; 5000 当您想设置断点，但只想在初始页面加载后暂停执行时很有用。 跳过 N 秒如果在接下来的 5 秒钟内遇到断点，则不暂停执行，但随时可以在之后暂停：window.baseline = window.baseline || Date.now(), (Date.now() - window.baseline) &gt; 5000。 可以随时从控制台 (console) 重置计数器：window.baseline = Date.now() Using CSS根据计算的 CSS 值暂停执行，例如，仅在文档正文背景颜色为红色时暂停执行：window.getComputedStyle(document.body).backgroundColor === \"rgb(255,0,0)\" 仅限偶数次调用每执行一次后暂停一次：window.counter = window.counter || 0, window.counter % 2 === 0 根据采样暂停仅在随机抽样执行该行时暂停，例如，仅在每执行 10 次该行时暂停 1 次：Math.random() &lt; 0.1 此处永不暂停 Chrome Edge Firefox Safari 右键单击边栏位置并选择 Never Pause Here（此处永不暂停），Chrome 浏览器会创建一个条件断点，false，永远不会触发。这样调试器就不会在这一行暂停。 当你想将某一行从 XHR 断点中排除、忽略正在抛出的异常等时，它就会派上用场。 自动分配实例 ID通过在构造函数中设置以下条件断点，自动为类的每个实例分配唯一 ID：(window.instances = window.instances || []).push(this) 然后检索唯一 ID：window.instances.indexOf(instance) (例如，在类方法中使用 window.instances.indexOf(this)) 编程触发使用全局布尔值选取一个或多个条件断点： 然后通过编程切换布尔值，例如 从控制台手动输入 window.enableBreakpoints = true; 从其他断点 从控制台上的计时器 setTimeout(() =&gt; (window.enableBreakpoints = true), 5000); 等等 监视类 (class) 的调用 Chrome Edge Firefox Safari 您可以使用 Chrome 浏览器的 monitor 命令行方法轻松跟踪对类方法的所有调用。例如，给定一个类 Dog class Dog { bark(count) { //计数 /* ... */ } } 如果我们想知道对 “Dog” 的所有实例的所有调用，请将此内容粘贴到命令行中： var p = Dog.prototype; Object.getOwnPropertyNames(p).forEach(k =&gt; monitor(p[k])); 就会在控制台中得到输出结果： &gt; function bark called with arguments: 2 如果想暂停任何方法调用的执行（而不只是记录到控制台），可以使用 debug 代替 monitor。 从特定实例 Chrome Edge Firefox Safari 如果您不知道该类，但有一个实例： var p = instance.constructor.prototype; Object.getOwnPropertyNames(p).forEach(k =&gt; monitor(p[k])); 当您想为任何类的任何实例（而不仅仅是 Dog 类）编写一个执行此操作的函数时，该函数非常有用。 调用并调试一个函数在调用要在控制台中调试的函数之前，调用 debugger。例如 function fn() { /* ... */ } 从您的控制台： debugger; fn(1); 然后 “Step into next function call”（进入下一个函数调用），以调试 fn 的实现。 当你不想查找 fn 的定义并手动添加断点时，或者当 fn 与函数动态绑定，而你不知道源代码在哪里时，这种调试器就很有用。 在 Chrome 浏览器中，您还可以选择在命令行中调用 debug(fn)，调试器会在每次调用 fn 时暂停执行。 在 URL 改变时暂停执行在单页面应用程序修改 URL (即发生路由事件) 之前暂停执行： const dbg = () =&gt; { debugger; }; history.pushState = dbg; history.replaceState = dbg; window.onhashchange = dbg; window.onpopstate = dbg; 至于如何创建一个能在不中断导航的情况下暂停执行的 dbg 版本，读者可自行决定。 另外，请注意，这种方法无法处理直接调用 window.location.replace/assign 的情况，因为页面在赋值后会立即销毁，所以没有任何调试内容。如果你仍然想要查看这些重定向的原网址（并在重定向时调试你的状态），在 Chrome 中你可以使用 debug 来调试相关的方法： debug(window.location.replace); debug(window.location.assign); 调试属性读取操作如果你有一个对象，并想知道它的某个属性何时被读取，可以使用一个带有 debugger 调用的对象获取器。例如，将 {configOption: true} 转换为 {get configOption() { debugger; return true; }} （在原始源代码中或使用条件断点）。 当你向某个程序传递一些配置选项，并希望查看这些选项的使用情况时，它就会派上用场。 使用 copy() Chrome Edge Firefox Safari 您可以使用 copy() 控制台 API 将浏览器中有趣的信息直接复制到剪贴板，而无需截断任何字符串。您可能想复制一些有趣的内容： 当前 DOM 的快照：copy(document.documentElement.outerHTML) 资源的元数据（如图像）：copy(performance.getEntriesByType(\"resource\")) 格式化后的大型 JSON blob：copy(JSON.parse(blob)) 本地存储的转储：copy(localStorage) 等等。 调试 HTML/CSSJS 控制台有助于诊断 HTML/CSS 的问题。 在禁用 JavaScript 的情况下检查 DOM在 DOM 检查器中按下 ctrl + \\ (Chrome/Windows) 可以随时暂停 JS 的执行。这样您就可以检查 DOM 的快照，而不必担心 JS 会改变 DOM 或事件（如鼠标悬停）会导致 DOM 从您脚下发生变化。 检查一个难以捉摸的元素假设您要检查一个 DOM 元素，而该元素只有在有条件的情况下才会出现。检查该元素需要将鼠标移动到该元素上，但当您尝试移动时，该元素却消失了： 为了检查元素，您可以将以下内容粘贴到控制台中：setTimeout(function () {debugger; }, 5000);。这将为您提供 5 秒钟的时间来触发用户界面，一旦 5 秒计时器计时结束，JS 的执行就会暂停，元素也不会消失。您可以自由地将鼠标移到开发工具上，而不会丢失元素： 在暂停执行 JS 时，您可以检查元素、编辑 CSS、在 JS 控制台中执行命令等。 在检查依赖于特定光标位置、焦点等的 DOM 时非常有用。 记录 DOM 的快照复制当前状态下的 DOM： copy(document.documentElement.outerHTML); 每秒记录一次 DOM 的快照： doms = []; setInterval(() =&gt; { const domStr = document.documentElement.outerHTML; doms.push(domStr); }, 1000); 或者直接转存 (dump) 到控制台： setInterval(() =&gt; { const domStr = document.documentElement.outerHTML; console.log(\"snapshotting DOM: \", domStr); }, 1000); 监视焦点元素(function () { let last = document.activeElement; setInterval(() =&gt; { if (document.activeElement !== last) { last = document.activeElement; console.log(\"Focus changed to: \", last); } }, 100); })(); 查找加粗元素const isBold = e =&gt; { let w = window.getComputedStyle(e).fontWeight; return w === \"bold\" || w === \"700\"; }; Array.from(document.querySelectorAll(\"*\")).filter(isBold); 仅限后代元素或者只是检查器中当前所选元素的后代： Array.from($0.querySelectorAll(\"*\")).filter(isBold); 引用当前选定的元素控制台中的 $0 是对元素检查器中当前选定元素的自动引用 (automatic reference)。 前面的元素 Chrome Edge Firefox Safari 在 Chrome 和 Edge 中，你可以使用 $1 访问你上次检查的元素，使用 $2 访问上上次检查的元素，以此类推。 查看事件监听器 Chrome Edge Firefox Safari 在 Chrome 浏览器中，您可以使用 getEventListeners($0) 检查当前选定元素的事件监听器，例如 监视元素的事件 Chrome Edge Firefox Safari 调试选定元素的所有事件：monitorEvents($0) 调试选定元素的特定事件：monitorEvents($0, [\"control\", \"key\"]) 脚注 除非浏览器标识另有说明，否则 Chrome、Firefox 和 Edge 浏览器均支持提示功能： Chrome Edge Firefox Safari","link":"/article/translation/browser-debugging-tricks/"},{"title":"打造一款人工智能工具，即时总结书籍内容","text":"无需从头到尾阅读一本书，就能掌握其要点 在本文中，我们将使用 Python、Langchain 和 OpenAI embeddings 构建一个简单但功能强大的书籍摘要器。 用 DALL-E 3 生成上图。 面临的挑战GPT-3 和 GPT-4 等人工智能模型功能强大，但也有其局限性。其中一个重要的限制就是上下文窗口，它限制了模型在同一时间可以考虑的文本数量。这意味着你不能把整本书输入模型，然后期待得到一个连贯的摘要。此外，处理大量文本的成本也很高。 解决方案为了克服这些挑战，我们设计了一种既经济又高效的方法。流程如下： 简化流程以下是我们如何将长篇大论的书籍转化为简明扼要的摘要： 拆分（Splitting）与嵌入（Embeddings）： 我们将图书分解成小块，并将其转换为嵌入。这一步的成本出奇地低。 聚类（Clustering）: 接下来，我们对这些嵌入内容进行聚类，找出书中最具代表性的部分。 摘要（Summarization）: 然后，我们使用更具成本效益的 GPT-3.5 模型对这些关键部分进行摘要。 合并摘要（Combining Summaries）: 最后，我们使用 GPT-4 将这些摘要拼接成一个流畅的叙述。 通过仅在最后一步使用 GPT-4，我们成功地降低了成本。 现在，让我们来分析一下代码和每个步骤背后的原理。 让我们深入代码，一步步构建我们的摘要器。 步骤 1: 加载图书首先，我们需要读取图书内容。我们将支持 PDF 和 EPUB 格式。 import os import tempfile from langchain.document_loaders import PyPDFLoader, UnstructuredEPubLoader def load_book(file_obj, file_extension): \"\"\"Load the content of a book based on its file type.\"\"\" text = \"\" with tempfile.NamedTemporaryFile(delete=False, suffix=file_extension) as temp_file: temp_file.write(file_obj.read()) if file_extension == \".pdf\": loader = PyPDFLoader(temp_file.name) pages = loader.load() text = \"\".join(page.page_content for page in pages) elif file_extension == \".epub\": loader = UnstructuredEPubLoader(temp_file.name) data = loader.load() text = \"\\n\".join(element.page_content for element in data) else: raise ValueError(f\"Unsupported file extension: {file_extension}\") os.remove(temp_file.name) text = text.replace('\\t', ' ') return text 步骤 2: 分割和嵌入文本人工智能模型有消耗 token 限制，这意味着它们无法一次性处理一整本书。通过将文本分割成块，我们可以确保人工智能可以摘要每一部分。 我们将文本分割成块，然后将它们转换成嵌入。嵌入将文本快速转换为紧凑的数字形式，计算量极小，因此整个过程既快速又经济。 from langchain.text_splitter import RecursiveCharacterTextSplitter from langchain.embeddings import OpenAIEmbeddings def split_and_embed(text, openai_api_key): text_splitter = RecursiveCharacterTextSplitter(separators=[\"\\n\\n\", \"\\n\", \"\\t\"], chunk_size=10000, chunk_overlap=3000) docs = text_splitter.create_documents([text]) embeddings = OpenAIEmbeddings(openai_api_key=openai_api_key) vectors = embeddings.embed_documents([x.page_content for x in docs]) return docs, vectors 步骤 3: 聚类嵌入我们使用 KMeans 聚类对相似的内容块进行分组。在我的版本中，正如你在下面看到的，我发现 11 个聚类（clusters）对于大多数书籍来说都很有效。但你也可以根据自己的实际情况进行调整。 在这里，我们将整本书转化为块（chunks），然后再转化为嵌入（embeddings）。这些嵌入根据相似度进行分组（grouped）。对于每一组，我们都会选出最具代表性的嵌入，并将其映射回相应的文本块（text chunk）。 from sklearn.cluster import KMeans import numpy as np def cluster_embeddings(vectors, num_clusters): kmeans = KMeans(n_clusters=num_clusters, random_state=42).fit(vectors) closest_indices = [np.argmin(np.linalg.norm(vectors - center, axis=1)) for center in kmeans.cluster_centers_] return sorted(closest_indices) 步骤 4: 总结具有代表性的内容我们将使用 GPT-3.5 摘要选定的数据块。 from langchain.chains.summarize import load_summarize_chain from langchain.prompts import PromptTemplate def summarize_chunks(docs, selected_indices, openai_api_key): llm3_turbo = ChatOpenAI(temperature=0, openai_api_key=openai_api_key, max_tokens=1000, model='gpt-3.5-turbo-16k') map_prompt = \"\"\" You are provided with a passage from a book. Your task is to produce a comprehensive summary of this passage. Ensure accuracy and avoid adding any interpretations or extra details not present in the original text. The summary should be at least three paragraphs long and fully capture the essence of the passage. ```{text}``` SUMMARY: \"\"\" map_prompt_template = PromptTemplate(template=map_prompt, input_variables=[\"text\"]) selected_docs = [docs[i] for i in selected_indices] summary_list = [] for doc in selected_docs: chunk_summary = load_summarize_chain(llm=llm3_turbo, chain_type=\"stuff\", prompt=map_prompt_template).run([doc]) summary_list.append(chunk_summary) return \"\\n\".join(summary_list) 步骤 5: 创建最终摘要我们使用 GPT-4 将各个摘要合并成一个最终的、有内涵的摘要。 from langchain.schema import Document from langchain.chat_models import ChatOpenAI def create_final_summary(summaries, openai_api_key): llm4 = ChatOpenAI(temperature=0, openai_api_key=openai_api_key, max_tokens=3000, model='gpt-4', request_timeout=120) combine_prompt = \"\"\" You are given a series of summarized sections from a book. Your task is to weave these summaries into a single, cohesive, and verbose summary. The reader should be able to understand the main events or points of the book from your summary. Ensure you retain the accuracy of the content and present it in a clear and engaging manner. ```{text}``` COHESIVE SUMMARY: \"\"\" combine_prompt_template = PromptTemplate(template=combine_prompt, input_variables=[\"text\"]) reduce_chain = load_summarize_chain(llm=llm4, chain_type=\"stuff\", prompt=combine_prompt_template) final_summary = reduce_chain.run([Document(page_content=summaries)]) return final_summary 将一切汇集在一起现在，我们将所有步骤合并到一个函数中，该函数接收上传的文件并生成摘要。 # ... (previous code for imports and functions) def generate_summary(uploaded_file, openai_api_key, num_clusters=11, verbose=False): file_extension = os.path.splitext(uploaded_file.name)[1].lower() text = load_book(uploaded_file, file_extension) docs, vectors = split_and_embed(text, openai_api_key) selected_indices = cluster_embeddings(vectors, num_clusters) summaries = summarize_chunks(docs, selected_indices, openai_api_key) final_summary = create_final_summary(summaries, openai_api_key) return final_summary 测试摘要器最后，我们可以用一个图书文件来测试我们的摘要器。 # Testing the summarizer if __name__ == '__main__': load_dotenv() openai_api_key = os.getenv('OPENAI_API_KEY') book_path = \"path_to_your_book.epub\" with open(book_path, 'rb') as uploaded_file: summary = generate_summary(uploaded_file, openai_api_key, verbose=True) print(summary) 总结该工具可帮助您快速了解任何书籍的要点。我们采用的方法不仅便宜，而且适用于任何篇幅的书籍。 请记住，摘要的质量取决于聚类 (clustering)和摘要提示 (summarization prompts)，因此可以根据自己的需要随意调整。 你可以在这里试用 Streamlit 应用程序并查看摘要器： GPT 摘要应用程序。 希望本文对你有所帮助。如果您有任何问题或反馈，请留言或联系我们。 祝您编码愉快！:)","link":"/article/translation/build-an-ai-tool-to-summarize-books-instantly/"},{"title":"浏览器开发者工具中不应该再有秘密","text":"更新: 由于这篇文章正在 Hackernews 上热传，我在每个标题后的括号中为每个提示添加了支持环境的信息。当我说明 Chromium 浏览器 时，指的是所有使用 Chromium 内核并具有所有开发者工具的浏览器。这包括 Chrome 浏览器、Microsoft Edge、Brave 以及其他更多浏览器。在此提醒一下： Microsoft Edge 是 Windows 10/11 系统自带的浏览器，基于 Chromium，因此从平台角度来看与 Chrome 浏览器类似。它们在用户体验和核心服务方面有所不同。Edge 开发者工具与谷歌密切合作，将我们添加到产品中的工作带回 Chromium 核心。但是，我在这里谈到的一些东西是微软 Edge 的实验和独有功能，它可在 Windows、Mac 和 Linux 上使用。有些功能只能通过 Edge DevTools for VS Code 扩展在 Visual Studio Code 中使用。 这是我今年 9 月在 CityJS 上发表的演讲。我是 Microsoft Edge 开发者人员工具的首席产品经理，这些都是我在开发工具、记录工具和查看用户反馈时遇到的问题。 你可以在 Youtube 上观看演讲视频。 下面是我所写的所有内容： 1. Console 远不止是打印日志!（所有浏览器的开发者工具都遵循该标准） 毫无疑问，除了元素工具，控制台是浏览器开发者工具中使用最多的部分。特别是，人们喜欢通过在代码中添加 console.log() 来调试，以了解发生了什么。虽然这样做存在一些问题，也有更好的调试脚本的方法，但既然人们都这么做了，那我们就来谈谈如何让这种体验变得更好。 第一个问题是产品上线后未删除的日志信息塞满了控制台。查找所需的信息变得令人望而生畏，而解决这个问题的最好办法就是了解 控制台过滤选项 。使用这些选项，你可以将控制台的报告过滤为你所关心的内容，并屏蔽掉大量杂音。 你想输出什日志?使用 console.log() 的下一个问题是，我们似乎只记录了值，却忘了添加它们的来源。例如，当你使用下面的代码时，你会得到一个数字列表，但你不知道什么是什么。 console.log(width); console.log(height); 要解决这个问题，最简单的方法是用大括号把要记录的内容包起来。这样，控制台就会同时记录你想知道的内容的名称和值。 console.log({ width }); console.log({ height }); 添加到你的控制台词汇 除了 console.log() 之外，你还可以使用 更多方法 。例如，console.warn() 记录警告，console.info() 记录信息，console.error() 记录错误信息。这不仅会使控制台的显示略有不同，而且还会使信息具有不同的日志级别，这意味着更容易对其进行过滤。 控制台中的错误和断言 在控制台中显示错误不同于抛出错误，但向维护或调试产品的人员显示问题的严重性仍然是个好主意。另一个有趣的方法是 console.assert()，它只在满足特定条件时记录信息。你经常会发现自己在编写 if 语句时，里面包含了一个 console.log()。使用assert()后，这条语句就变得多余了，在清理调试代码时就少了一件要担心的事。 追溯源头 你经常会发现自己添加了一个 console.log('called') 或类似内容来测试某个功能是否被触发。一旦有了这个功能，下一件事通常就是找出是什么调用了该方法。这就是console.trace()的作用，因为它不仅会告诉你某个方法被调用了，还会告诉你调用来自哪里。 将控制台信息分组如果要记录的内容很多，可以使用 console.group('name') 和 console.groupEnd('name') 在控制台中以可折叠和可展开的方式封装信息。你甚至可以定义组默认是展开还是折叠。 在控制台中以表格形式显示和过滤大量信息如果你想以日志形式显示大量信息，那么阅读这些信息可能会令人望而生畏。console.table() 方法会在控制台中以表格形式显示类似数组的数据，你可以通过给它一个数组来过滤你想显示的属性。 例如，你可以使用 let elms = document.querySelectorAll(':is(h1,p,script') 从文档中获取所有 H1、段落和脚本元素，并使用 console.table(elms) 以表格形式显示这些信息。由于不同的元素有大量的属性和属性，因此生成的表格非常难读。如果使用console.table(elms,['nodeName', 'innerText', 'offsetHeight']) 过滤出你感兴趣的内容，你就会得到一个只有这些属性及其值的表格。 复制和粘贴这些信息时，表格结构会保持不变，可以轻松地将数据导入到 Excel 或 Word 中 像 jQuery 一样锋利 : $() and $$()控制台自带了许多方便使用的方法，称为 Console Utilities 。其中两个非常有用的方法是 $() 和 $$()，它们分别是 document.querySelector() 和 document.querySelectorAll() 的替代方法。它们不仅会返回你所期望的 nodeList，还会将结果转换为数组，这意味着你可以直接在结果上使用 map() 和 filter()。以下代码将抓取当前文档中的所有链接，并返回一个数组，数组中的对象仅包含每个链接的 href 和 innerText 属性，即 url 和 text 属性。 $$(\"a\").map((a) =&gt; { return { url: a.href, text: a.innerText }; }); 2. 你可以在没有源访问权限的情况下进行日志记录，实时表达式和日志点(Chromium 浏览器) 添加 console.log() 的常规方法是将其放在代码中想要获取信息的地方。但你也可以深入了解你无法访问和更改的代码。Live 表达式 是在不更改代码的情况下记录信息的好方法。它们还能记录不断变化的值，而不会让控制台满屏日志，从而降低产品的运行速度。你可以从下面的截屏中看到它们的不同之处： 日志点是一种特殊的断点。你可以右键单击开发者工具源代码工具中 JavaScript 的任意一行，然后设置一个日志点。你会被要求提供一个要记录的表达式，并在执行该行代码时在控制台中获得其值。这意味着从技术上讲，你可以在网络上的任何地方注入一个 console.log()。我早在八月份就写过关于日志点的文章，你可以在下面的截屏中看到演示： 3. 你可以在浏览器之外使用 VS code 调试器进行日志记录(Chromium 浏览器 和 VS Code) 在 Visual Studio Code 中启动调试会话时，可以生成一个浏览器实例，调试控制台就会变成浏览器开发者工具中的控制台。我曾在七月份的博客中详细介绍过这一点，所以你可以阅读如何做到这一点。官方文档 中也有更多内容。 你还可以观看我展示功能的一分钟视频： 4. 你可以向任何网站注入代码，片段（Snippets）和重写（Overrides）(Chromium 浏览器) 片段(Snippets) 是开发者工具中针对当前网站运行脚本的一种方法。你可以在这些脚本中使用控制台实用工具，它是编写和存储通常在控制台中执行的复杂 DOM 操作脚本的绝佳方法。你可以通过片段编辑器或命令菜单在当前文档的窗口上下文中运行脚本。在后一种情况下，以 ! 开头，然后键入要运行的代码段名称即可。 重写(Overrides) 允许你存储远程脚本的本地副本，并在页面加载时覆盖它们。举例来说，如果你的整个应用程序的构建过程很慢，而你又想试一试，这就非常好用。此外，它还是替代第三方网站恼人脚本的绝佳工具，而无需使用浏览器扩展。 5. 你可以检查(inspect)和调试(debug)的东西比你知道的要多得多！(Chromium 浏览器) 你可能从 Google Chrome、Brave 或 Microsoft Edge 等浏览器中了解到 Chromium 开发者工具，但它们在更多环境中可用。任何基于 Electron 的应用程序都可以启用这些工具，你可以使用这些工具窥探引擎盖下的内容，看看产品是如何完成的。例如，这可以在 GitHub Desktop、Visual Studio Code 中使用，你甚至可以使用开发者工具调试浏览器的开发者工具！ 如果你检查一下开发者工具，就会发现它们是用 HTML、CSS 和 TypeScript 编写的。使用这些技术是一个令人兴奋的环境，因为你知道你的代码将在哪个渲染引擎中运行,这在网络上是永远无法知道的。 Edge 在 Visual Studio Code 的开发者工具(Microsoft Edge 使用 VS Code 扩展) 这些工具的可嵌入性也使我们能够为你提供一种在浏览器之外使用它们的方法。Microsoft Edge Tools for Visual Studio Code 扩展将这些工具带到了 Visual Studio Code 中。这样，你就可以在代码编辑器旁边使用可视化调试工具，而不必总是在两者之间跳来跳去。当你开始调试会话并单击 “开发者工具”（Developer Tools）图标时，工具就会打开，或者首次打开时，系统会提示你安装扩展。 6. 肮脏的秘密与开发者工具进行亲密合作，并获得反馈和使用信息，这让我了解了一些 肮脏的秘密。第一个是，尽管我们所有人都对开发者工具的所有惊人功能感到非常兴奋，但用户只使用了其中的一小部分。许多在演示和视频教程中被誉为自切片面包以来最好的东西实际上很少被打开，更不用说被使用了。我以为这是因为缺乏文档记录，所以我们花费了大量的时间来更新DevTools 文档，以确保其中的所有内容都被描述和解释，但这不是问题所在。文档似乎是人们在谷歌、Stack Overflow 或社交媒体渠道没有找到任何结果后的最后手段。 开发人员的工具变得复杂不堪，如何解决这个问题？(Microsoft Edge) 可能是因为浏览器的开发者工具在过去几年中有机地发展壮大，让人目不暇接。这让我很烦恼，我认为我们应该做得更好。说到开发者工具，我有一句口头禅： 开发者工具不应期望人们成为专家，而应随着时间的推移把他们变成专家。 我们正在想办法让这一切变得更容易，你很快就会在 Microsoft Edge 中看到这些想法。我们的一个想法是 “聚焦模式(Focus Mode)”。我们不再向你显示所有工具和选项卡，而是将工具按不同的使用情况进行分类，如 “元素/CSS 调试(Elements/CSS debugging)”、“源代码/JavaScript 调试(Sources/JavaScript Debugging)” 或 “网络检查(Network inspection)”。然后，我们只显示相关工具，隐藏所有可能会造成混淆或碍事的工具。 我们正在开发的另一项功能是 “信息覆盖(informational overlays)”。你可以获得一个帮助按钮，打开开发者工具的叠加信息，解释每个工具是什么、如何使用以及提供文档链接。我们希望这将使人们更容易了解更多的功能。 编写代码与调试结果之间仍然存在脱节现象(Microsoft Edge) 尽管现在的工具令人惊叹，但编写和调试之间仍然存在脱节。大多数情况下，我们在编写代码、创建应用程序后，会在浏览器中查看哪些地方无法正常工作。然后，我们使用浏览器开发者工具来调整和修复这些问题。然后，我们还需要解决一个大问题：如何将使用浏览器开发者工具创建的更改返回到代码中？大多数情况下，答案是 “复制并粘贴，或者试着记住需要更改的内容”。 我们目前正在研究两种方法来简化这一过程。一种是在可用时用 Visual Studio Code 代替开发者工具内的编辑器，并在使用浏览器开发者工具时更改硬盘上的文件。另一种是 VS Code 扩展的一部分，可以在使用开发者工具时更改编辑器中的源代码，但在更改磁盘上的文件时仍有最终决定权。我在 Edge 博客上描述了问题和可能的解决方案，你也可以观看以下两个截屏视频，了解它们的实际效果。 Visual Studio 代码中的 CSS 镜像: 如果…… Visual Studio Code 成为浏览器内开发者工具的编辑器，会发生什么？ 7. 你们是开发人员工具的受众和客户！（适用于所有浏览器，但此处显示的渠道仅限于 Microsoft Edge） 作为开发人员，你是开发人员工具的主要受众。我们愿意听取你的反馈意见，最近对工具的许多更改都是外部开发人员要求的直接结果。我们通过提供直接与我们联系的上下文方式，尽可能地简化这一过程。例如，Visual Studio Code 扩展有显著的链接和按钮供你报告问题(report issues)和功能需求(request features)。 扩展插件的源代码 也在 GitHub 上，你可以在那里提交 issues。 浏览器内的开发者工具也有一个直接向我们提供反馈的按钮。为了便于你提供可操作的反馈，该按钮包含了大量自动信息。 它会自动记录发生问题的 URL、截图并发送诊断数据。我们还要求你提供电子邮件，以备我们需要更多信息，你还可以添加附件和如何重现问题的信息。我们每天都会检查这些反馈，很多伟大的发明和错误修复都来自于此。 分享到 Mastodom 分享到 Twitter 我的其它作品 开发人员倡导手册 在 Amazon 购买 在 Leanpub 购买 技能分享课程: 优化开发人员工作流程的工具和技巧 改善产品无障碍环境的工具 JavaScript 工具包： 编写更简洁、更快速、更优秀的代码 揭开人工智能的神秘面纱： 了解机器学习 Christian Heilmann 博客chris@christianheilmann.com 邮箱 (请不要就客座文章与我联系，我不做这种事！)我是一个首席项目经理，在德国柏林生活和工作。 主题由 Chris Heilmann 制作。SVG 图标由 Dan Klammer 制作。由 MediaTemple 主持。由 Coffee 和 Spotify Radio 提供技术支持。 获取订阅，所有酷孩子都在使用 RSS！","link":"/article/translation/developer-tools-secrets-that-shouldnt-be-secrets/"},{"title":"从零开始构建容器：层","text":"在 Depot，我们专注于为容器镜像提供最快的构建服务。我们主要通过以下方式实现这一目标： 提供对强大计算和存储的即时访问。 优化构建过程本身以使其尽可能快。 我们将 Depot 运行在 AWS 之上，为每个 Depot 项目使用大型 16 核机器。这些机器使用原生 Intel 和 Arm CPU，避免了多平台镜像的仿真。并且我们使用带有 NVMe SSD 的 Ceph 集群为它们提供分布式缓存存储。这一切都使得执行 RUN 语句变得快速，并使缓存查找和写入变得快速。 对于构建过程本身，除了对构建过程进行许多高级优化之外，我们目前正在对构建过程本身进行许多低级优化。 为了更好地理解其中一些优化，了解 OCI 容器镜像层格式本身很有帮助。 层格式它们只是 tar 包！ OCI 镜像规范 为容器镜像（“Docker 镜像”）定义了一个容器镜像，它是由“层”和元数据组成的集合。每一层都是一个以 tar 归档 形式存储的文件集合。 当镜像被解包时，各层相互堆叠形成容器的文件系统。从概念上讲，这可以看作是在彼此之上提取每个 tar 包，直到拥有整个文件系统，或者将所有层“联合”在一起。 以这个 Dockerfile 为例： FROM ubuntu:22.04 COPY hello.txt . COPY world.txt . 构建时，这将生成一个包含三层的容器镜像： 一个包含 Ubuntu 22.04 基础镜像文件的“层”（tar 包） 一个包含 hello.txt 文件的“层”（tar 包） 一个包含 world.txt 文件的“层”（tar 包） 解压生成的镜像后，容器文件系统将如下所示： / ├── bin/ ├── boot/ ├── dev/ ├── etc/ ├── home/ ├── lib/ ├── media/ ├── mnt/ ├── opt/ ├── proc/ ├── root/ ├── run/ ├── sbin/ ├── srv/ ├── sys/ ├── tmp/ ├── usr/ ├── var/ ├── hello.txt └── world.txt 这将包含 Ubuntu 22.04 基础层中的所有文件，以及第二层中的 hello.txt 文件，以及第三层中的 world.txt 文件。 如今，像 Docker 和 BuildKit 这样的工具会为 Dockerfile（或多阶段 Dockerfile 的目标阶段）中的每个 RUN、COPY、ADD 等语句生成一个 tar 层。请注意，这不是 OCI 镜像规范的要求，该规范没有指定如何创建层。 OCI 容器镜像只是一组 tar 包。 组装 OCI 镜像如果容器镜像层只是 tar 包，并且它们被联合在一起形成容器文件系统，那么如何才能在后面的层中删除或修改文件呢？ 处理已修改的文件修改文件很简单：如果一个文件包含在多个层中，则最后包含该文件的层 wins。例如 FROM scratch RUN echo \"hello\" &gt; example.txt RUN echo \"world\" &gt; example.txt 这将生成一个包含两层的镜像： 一个包含 example.txt 文件的 tar 包，其中包含文本 hello 一个包含 example.txt 文件的 tar 包，其中包含文本 world 解压后，第一层的 example.txt 文件将被第二层的 example.txt 文件覆盖，从而生成一个容器文件系统，其中包含一个 example.txt 文件，其中包含文本 world。 处理已删除的文件但是，已删除的文件该如何处理？ 例如： FROM scratch RUN echo \"hello\" &gt; example.txt RUN rm example.txt 为此，OCI 镜像规范定义了一种特殊的文件，称为 whiteout 文件。 Whiteout 文件是带有特殊名称的空文件，它告诉容器运行时应从容器文件系统中删除某个路径。 Whiteout 文件有一个特殊的.wh.前缀，后跟要删除的文件的名称。 例如，上面示例生成的第二层将包含一个名为 .wh.example.txt 的零字节文件。 这指示容器运行时在解压该层时从容器文件系统中删除 example.txt 文件。 注意： 这是容器构建中安全漏洞的常见原因。如果一个文件包含在较早的层中，然后在较晚的层中被删除，则该文件的内容仍然存在于容器镜像内容中。这可能导致泄露敏感信息，例如凭据或私钥。 还有一种特殊的 whiteout 文件，称为 opaque whiteout，名为 .wh..wh..opq。该文件指示容器运行时删除与 opaque whiteout 文件位于同一目录中的所有文件和目录。例如，如果一个层包含一个名为/example/.wh..wh..opq的文件，则指示容器运行时删除 /example 目录下的所有文件和目录。 最后，层通常以 gzip 压缩的 tar 包（扩展名为.tar.gz）的形式分发，以节省存储空间并减少网络数据传输。请注意，该规范还支持未压缩的 tar 包（.tar）和 zstd 压缩的 tar 包（.tar.zstd）。 Overlay filesystems（叠加文件系统）像 containerd 或 podman 这样的容器运行时负责在运行容器之前将镜像的层（tar 包）解压到一个目录中。这被称为容器的 rootfs 或根文件系统。 实际上，对于每个启动的容器，依次将每一层解压到 rootfs 目录中，并注意应用文件修改或删除 whiteout 文件，这将非常缓慢。相反，容器运行时通常使用特殊的文件系统来有效地将各层组合成一个单一的文件系统。 其中一种文件系统是 overlayfs，它是 Linux 内核的一项功能，允许多个目录组合成一个单一目录。这是 Docker 和 Podman 使用的默认文件系统。 使用 overlayfs 时，每一层都会被解压到一个单独的目录中，然后容器运行时会告诉 Linux 内核将这些目录相互叠加挂载。然后，内核将组合后的目录作为单个目录呈现给容器运行时。 Overlayfs 本身支持 whiteout 文件的概念，因此容器运行时在挂载层时会将 OCI 镜像 whiteout 文件转换为 overlayfs whiteout 文件。 这使得每个镜像层只需解压一次，因此从同一个镜像运行多个容器非常快，并且在镜像之间共享公共基础层非常高效。Linux 内核处理将各层组合成单个文件系统的所有复杂性。 使用 eStargz 的惰性镜像层虽然镜像层“仅仅”是包含文件的 tar 归档文件，但可以通过扩展格式来提高存储和传输效率。eStargz 镜像格式就是一个例子。 eStargz 镜像仍然是有效的 tar 归档文件，但它们的构建方式很特殊，允许元数据文件描述压缩 tar 包中每个文件的具体位置。这允许在无需从注册表下载整个层并解压缩的情况下访问这些文件。 例如，要在 eStargz 层中找到特定文件，容器运行时将执行以下操作： 获取压缩 tar 包的末尾，其中包含层中所有文件的索引（TOC） 从 TOC 中读取文件的字节偏移量和长度 从注册表中获取指定的字节范围 对于大型层来说，这可以显著节省下载大小和时间。 这种优化在启动容器时非常有用，因为容器可以在整个镜像下载完成之前就开始运行。然后，随着容器的运行和文件的访问，这些文件会从注册表中延迟加载。 这对构建镜像也很有帮助。我们构建的 depot.ai 就是一个例子。借助 depot.ai 镜像，Hugging Face 中流行的机器学习模型被打包成与 eStargz 兼容的镜像。然后，当将这些机器学习模型复制到新的容器镜像中时，Depot 只需要下载 COPY 请求的文件。这比下载整个模型仓库要快得多，尤其是在模型仓库包含多种格式的模型而只需要一种格式的情况下。 这类优化的其他例子还包括 AWS 的 SOCI 快照程序、Nydus 镜像格式和 Red Hat 的 zstd:chunked。 优化层构建考虑到容器镜像层本质上是 tar 包，我们正在探索各种层构建过程的优化方法，使其更快、更高效： Depot 目前支持创建和使用 eStargz 镜像。 Depot 使用多个 CPU 核心并行压缩 tar 包。目前，我们会将层 tar 包分成多个块，并使用 gzip 并行压缩每个块，然后将这些块连接在一起。这会导致压缩后的 tar 包略大一些，但压缩速度会大大提高。 我们正在研究并行构建单层的方法，构建一层意味着从文件目录创建 tar 包。目前，这是按顺序完成的，但 tar 存档头的构建可以并行化。 我们正在探索构建层不需要 Dockerfile 的替代方法。目前，Dockerfile 是描述容器构建的最常见方式，但考虑到层是 tar 包，因此可以直接制作 tar 包。 优化容器构建过程还有很多方面，我们希望将来能分享更多我们的工作。如果您对这些内容感兴趣，请随时通过 Twitter 或 Discord 与我们联系。","link":"/article/translation/building-container-layers-from-scratch/"},{"title":"如何快速学习","text":"人们常说互联网已经实现了教育民主化：人类知识的总和只需要谷歌搜索即可获取！然而，获取信息只是故事的一半；你还需要能够将原始信息转化为可用的技能。 对于我们很多人来说，这两者之间的差距可能会导致类似于 教程地狱 的情况——不断地做一个又一个教程，却从未觉得自己在取得实质性的进展。 学习如何有效地学习是非常重要的，尤其 是作为一名软件开发人员；学习新知识几乎就是整个工作的全部！如果你能快速掌握新语言/框架/工具，你会比一般的开发人员 更高效 。这有点像超级能力。 在这篇博文中，我将分享我关于学习的心得，并展示我如何快速掌握新技能！ 混合指导学习和非指导学习广义上讲，有两类学习： 指导型学习： 阅读教程、参加课程、观看 YouTube 视频。任何你在跟随指导的活动。 非指导型学习： 从头开始创建自己的项目、扩展教程、在文档中查找信息。任何你不跟随指导的活动。 如果你只跟随指导资源，你会陷入教程地狱。你将无法掌握作为一名开发人员取得成功所需的解决问题的技能。当你尝试创建自己的项目时，你不知道从哪里开始。会觉得自己花了很多时间练习却没有获得任何实际的、实用的技能。 另一方面，如果你完全专注于非指导学习，学习过程会非常漫长。没有经验丰富的指导，你需要重新发明每一个轮子，花费几天或几周解决已经解决的问题。这是一条漫长而令人沮丧的道路。在最坏的情况下，你可能会完全放弃，错误地认为你不够聪明。 一些课程意识到了这种对立关系，并会包括非指导学习的机会。比如扩展目标、思维实验和挑战性练习。我希望这种类型的资源能更常见一些！ 让我们看看如何将一些非指导学习融入指导资源中的一些想法。 故意犯错如果你和我一样，你不喜欢犯错。你希望一切都能第一次就完美进行。 这种心态在生活中通常是有帮助的，在其他领域也有帮助。如果你是一名汽车修理工，错误可能会花费数百美元的零件费用。如果你是一名牙医，一个错误可能会毁掉某人的微笑。 但是在软件开发中，错误是免费的！如果我们犯了错误，可以切换回编辑器，修改代码，然后再试一次。我们甚至还有一些有用的错误信息（有时）可以指引我们方向。这是一种不可思议的奢侈，我们并没有充分利用它。 当我跟随教程时，我喜欢玩代码。不要逐字逐句地复制/粘贴提供的代码，试着进行实验：如果省略其中一行会发生什么？或者更改某些值会发生什么？ 我尝试像科学家一样行事。如果我对这段代码的工作方式有一个假设，我会通过更改代码并观察它是否以我预期的方式崩溃来检验这个假设。当我发现我的假设有缺陷时，我可能会从教程中偏离，去谷歌上做一些研究。或者如果这个问题看起来太深，我可能会把它列入“稍后探索的事情”清单中。 这个过程帮助我们避免了无主动意识地跟随教程，复制/粘贴代码而不真正理解它做了什么或为什么我们要这样做的危险循环。 学习是一个主动的过程。探究代码有助于我们建立对正在发生的事情的心理模型。 教程渐隐多年前，当我刚起步时，我使用了一个我称之为“教程渐隐”的方法。 具体操作如下： 按照教程逐字逐句地操作，一步一步地进行。 完成后，将代码重置为初始状态，并最小化教程。看看在不看教程的情况下你能走多远。当你卡住时，重新打开教程，但一旦你解开困惑，就再次将其最小化。 重复这个过程，直到你可以从头到尾完成教程而不看说明。 就像上面描述的科学家心态一样，这个过程很有用，因为它迫使你集中注意力。教程逐渐淡出，你最终学会了在没有指导的情况下创建事物。 这种方法非常有效，但并不是每个人都喜欢反复创建同样的东西。不过，如果你曾经挣扎于“教程地狱”，这可能值得一试！ 扩展教程假设我们通过这个 官方教程 学习 React 并创建了一个井字棋游戏。 当你完成教程时，你将创建一个功能齐全但非常简单的游戏。 我们可以为它添加各种有趣的功能： 记录每个玩家赢得了多少场比赛 用更多的展示组件增强 UI 允许配置棋盘大小（4x4, 5x5） 添加一个可以与玩家对战的 AI 趣味元素！（动画、音效、胜利时的彩带等） 要有创造力，并选择你真正感兴趣的事情！ 这种策略很好，因为你避免了空白画布的压力。你已经有了一个功能齐全、理解透彻的项目。你是在坚实的基础上添加砖块。 它还有一个好处：如果你对教程项目进行了显著扩展，可以在你的作品集中将其作为亮点！我在我的书《创建一个有效的开发者作品集》中深入探讨了这个策略。 创建相关项目一旦你完成了井字棋项目，你可能会有点不确定接下来该做什么。 在跳到另一个教程之前，尝试从头开始创建一个类似的项目可能是个好主意。 例如，也许你可以制作一个宾果游戏！你可以利用一些新技能（状态管理、事件监听），但在一个稍微不同的背景下。你可能会遇到一些教程中没有涉及的难题；你可以在谷歌上做些调查，尝试找到解决方案！ 如果你真的无法解决，可以暂时搁置这个项目。再做几个教程，然后回来看你是否已经学到足够的知识来突破自己的知识局限。 我见过这种策略被描述为“一个有指导，一个无指导”。跟随一个有指导资源，如教程，然后花费相同的时间创建一个类似的（但无指导的）项目。如果教程教你如何创建一个 Instagram 克隆版，尝试自己创建一个 Twitter 克隆版！ 找到正确的平衡点当我刚开始学习旅程时，我倾向于主要专注于有指导的学习。当我还在努力掌握语法和基础知识时，很难以无指导的方式构建任何东西！ 然而，当我变得越来越熟悉后，平衡就会发生变化。我花更多的时间进行无指导的学习，构建那些对我来说有趣的东西。当遇到新的或不熟悉的问题时，我会寻找教程，但随着经验的积累，这种情况会越来越少。 我的图表看起来像这样： 你的图表可能看起来有些不同；最终，找到正确的平衡点取决于你自己！重要的是，我们不要只专注于有指导的学习或无指导的学习。 心态培养多年前，我和一些朋友去打保龄球。 我表现得很差。我的大多数球都进了沟。到比赛结束时，我的得分是小组中最低的。 有两种不同的方式来解释这种情况： 我就是不擅长打保龄球，我永远不会擅长。保龄球根本不是我的菜。 我不擅长打保龄球。但如果我愿意，我可以成为一个优秀的保龄球选手。 这有一种自我实现预言的性质：无论你选择哪种解释都是正确的。如果你认为你的保龄球技能水平是固定的，它就会是。如果你相信自己可以提高，你就会提高！ 如果你想快速学习新技能，培养正确的心态至关重要。 软件开发从来都不是一帆风顺的。不可避免地，我们会遇到一个困难的问题，即代码无法达到我们的预期。 这可能会导致一个充满沮丧和自我怀疑以及冒名顶替综合症的下行螺旋，或者它可以被视为一个极好的学习机会。只要你有正确的心态，没有什么比难以理解的错误信息更能帮助你快速学习。 说实话，我们从挣扎和失败中学到的比从轻松成功中学到的要多得多。有了成长心态，虽然挣扎可能不一定有趣，但感觉很有成效，就像一次好的锻炼。 了解更多关于 培养成长心态 的信息。 目标和动机我们生活在一个社交媒体炒作的世界里，很容易感到有压力，要跟上潮流，学习每一个在 Twitter 上出现的流行 JS 库。 就我个人而言，每次我试图这样做，结果都不太好。😅 我只是对为了学习而学习并没有特别的动力。为了让我保持动力，我需要有一个令人兴奋和具体的目标。 例如：几年前，我发现了 Beat Saber，这是一款 VR 视频游戏。在这个游戏中，你用光剑攻击方块，与音乐同步。每首歌都有一个独特的编舞。 有软件让用户可以创建自己的编舞（在社区中称为“地图”），但我并不是它的忠实粉丝。我想为 Beat Saber 创建自己的地图编辑器。 经过几个月的艰苦和偶尔令人沮丧的工作，我实现了我的目标： （如果你对这个项目感兴趣，可以在线观看，在 Github 上查看代码，或观看关于其开发的会议演讲！） 在这个项目之前，我没有任何 3D 经验，我必须学习大量关于 WebGL、Three.js 和 react-three-fiber 的知识。学习是困难的，无论你的成长心态有多么培养得当，总会有些日子事情进展不顺利。 但因为我有一个具体的目标，是我真正想要的，我能够克服挫折并继续进步。如果我只是为了好玩或者因为我认为它会让我的简历看起来更好而学习这些东西，我可能很快就放弃了。 不同的人受到不同事物的激励，所以我并不是说你需要找到一个特定的项目来创建。但我确实认为有一个明确的目标是很重要的，某个你真正感兴趣的东西。否则，在最初的新奇感消失后，维持所需的动力将变得很困难。 记忆事物我的记忆力 非常 差。 这可能有点问题；如果你不能记住事情，学习东西会很难！幸运的是，我有一个系统：间隔重复。 这里是间隔重复的核心思想：为了增强记忆，你需要在记忆即将消退时访问它。每次你增强记忆，它的持续时间就会稍微长一点。 这听起来很复杂，但有一些工具可以帮你跟踪这个过程。我个人使用 Leitner 盒，这是一个装有几百张索引卡的物理盒子。每天，我会复习一小部分卡片。 如果你对间隔重复感兴趣，我强烈建议你看看 Nicky Case 的这篇可探索的解释：《如何永远记住任何事情》。 建立日常习惯假设我们承诺每周花 7 个小时学习新东西。你认为是每天花一个小时在这个活动上更有效，还是每周日连续花 7 个小时更有效？ 据我的经验，花费较少的时间但更频繁地进行会 更 有效。 我意识到并非每个人都有这种奢侈的结构，但如果你能做到，我强烈建议你尝试每天花一点时间在你试图学习的东西上。 我有一些关于为什么这种方式对我来说更有效的假设： 每晚，大脑会处理并承诺当天学到的东西。我希望每天都能利用这一点，而不仅仅是每周一次！ 因为我每天都练习，可以直接从上次中断的地方继续。我不必花费大量时间刷新记忆和重新开始。 正如我们所谈论的，在新奇感消失后维持动力可能很困难。如果你能将其融入日常生活，你就不必太担心动力问题；不管你感觉如何，它变成了你只需要做的事情。 公开学习我是 Swyx 的 公开学习 理念的忠实粉丝。 主要思想是，通过发布我们所学的内容，我们可以帮助未来的自己。当我们发现新事物时，我们应该创建一个记录它的文档，比如博文、推文或 YouTube 视频。 这可能有点违背直觉；为什么要在“学习时间”写博文呢？这不是浪费时间吗？ 公开学习有很多好处，我发现了以下几点： 你有没有试图向某人解释某事，结果发现自己并不像你想象的那样彻底理解它？写博文有同样的效果。这是揭示你心理模型中的缺陷/漏洞的最佳方法，以便你可以修复它们。 世界上最糟糕的感觉是遇到一个你知道自己已经解决过的 bug，但你记不起如何解决它。如果你写了一篇关于它的博文，你可以参考它！ 通过分享你的学习，你成为开发者社区的积极参与者。你可以结交朋友和建立联系。这既有趣又有成就感，更不用说在找新工作或启动新企业时的好处了！ 需要注意的一点是：不要陷入设置完美博客数周的陷阱！从像 Dev 这样的平台上发布开始，甚至只是发布在 Twitter 上！在我建立博客之前，我在 Medium 上发布了数十篇博文。如果你发现自己真的喜欢公开学习，你可以随时迁移到一个华丽的定制博客。😄 技能网络最近，我开始自学如何使用 Blender 创建 3D 插图。 我还是个初学者。目前，我大概投入了约 150 个小时的时间。但我已经能够创建一些看起来不错的艺术作品。以下是我制作的一些东西： 我能够如此快速地学习，是因为遵循了这篇博文中列出的所有技巧。但还有一个我手中的王牌：互补技能 。 事情是这样的，3D 插图不是一项单一的技能；它是多个技能组成的集合。其中一些，比如创建 3D 模型，对我来说是全新的，我必须从头学起。但其中一些是我有经验的技能网络的一部分。 例如：我有点业余摄影爱好。几年前，我学会了构图，如何在视口中排列元素以获得引人注目的镜头。我可以在我的渲染中定位对象时利用这些技能。 这是一个特别具体的例子，但其他的例子则更为模糊。多年来，我在前端开发工作的过程中培养了对细节的关注。所有这些像素推敲帮助我为倒角和厚度设定合适的值。而我做 UI 设计的工作帮助我理解色彩理论和美学。 你不一定会认为我已经拥有的技能会与 3D 插图产生协同作用，但它给了我一个极大的不公平优势。 在我看来，技能就像财富。你积累的技能越多，它们增长的速度就越快。在一个领域中获得的想法和技术可以在另一个领域中发挥作用。 我并不是说你应该成为一个完全的通才——拥有深厚的专业知识仍然是值得的！但你的技能网络越广，在学习新事物时你的优势就越大。 有时，学习资源会利用这一点。例如，我正在制作一个 CSS 课程，《为 JavaScript 开发者准备的 CSS》。我专门为 JS 开发者创建它，因为我知道我可以利用大量的预先存在的知识来简化学习 CSS 的过程。我们不是从零开始创建，而是利用你对 JS 的知识来解释 CSS，复制/粘贴你已经拥有的心理模型。 我的目标是改变你与 CSS 的关系。很多 JS 开发者觉得它令人沮丧且违反直觉。如果你想提升你的 CSS 技能，你可以了解更多关于课程的信息。 在这篇博文中我覆盖了 很多 内容，真的很感谢你坚持到最后 💖 祝你在学习旅程中好运！","link":"/article/translation/how-to-learn-stuff-quickly/"},{"title":"我所知道的关于固态硬盘的一切","text":"使用 NAND 闪存的固态硬盘，它们与机械硬盘的区别，以及它们如何影响文件删除和恢复。 介绍我开始写这篇相当长的文章是为了自己的学习收益，当时我从 2006 年的旧款 Win 8 250GB 硬盘驱动的电脑升级到了一台带有 128GB SSD 的戴尔 Optiflex 3010。在系统盘上，我从未使用过超过 30 或 40GB 的空间，而且我既不是游戏玩家，也不是狂热的电影或音乐收藏家。至少在电脑上不是。随着我对我的新设备的不断摸索，我越来越意识到我对 SSD 中的 NAND 闪存了解甚少，不知道 SSD 是如何工作的，它们是如何读取、写入和存储数据的，以及它们使用了哪些技巧？我可以想象硬盘驱动器（HDD）在旋转的表面上写入微小的磁性记录，但 SSD 完全不同，差别巨大。 关于 SSD，还有一些长期的误解，如果能够有些思考，甚至消除其中一些，那将是很好的。也许我自己也曾怀有不少误解。不管它是如何开始的，这篇文章逐渐发展成了一篇中级技术讨论。如果你只需要知道 SSD 安静、可靠、快速，并且能够使用多年，那么就没必要再读下去了。然而，如果你认为了解如何读取 3D TLC NAND 闪存单元是有趣的，那么你别无选择，只能继续深入了解。 尽可能多的详细信息来源于企业和私人技术文章，特别是来自希捷（Seagate）和西部数据（WD），以及名字很有趣的 Flash Memory Summit（闪存峰会）。我所做的一些结论是尝试运用我能理解的逻辑和常识。NAND 闪存控制器的复杂性，它们操作方法的多样性，以及它们发展的速度，使得理解它们，更不用说跟上它们的步伐，至少可以说是困难的。我不能说我写的内容没有混淆或者完全正确，但它更像是一本指南而不是圣经。也会有一些重复的内容。而且很快它就会过时。 我感激那些我借鉴的人，也将感激那些无需任何回报（除了贡献的满足感）就指出任何错误的人。我试图解释固态硬盘（SSD）与众不同的地方，以及为什么我们根深蒂固的硬盘驱动器（HDD）思维很难理解它。 第一个误解可能是 SSD 的复数：从语法上讲，应该是 SSDs，但 SSD’s 几乎同样常见。在这里，我将坚持使用 SSD、SSDs。 软件和硬件本文写于 2019 年及之后，几乎完全围绕以个人电脑或笔记本电脑存储设备形式出现的 NAND 闪存展开，我们将其称为固态硬盘 (SSD)。我不会通过提及无处不在的闪存驱动器或其他 NAND 闪存设备来使事情变得更加复杂。如果存在显著差异，我将尝试在发生差异时进行说明，但默认情况下指的是内置驱动器。本文不涉及手机等设备中的闪存存储。 本文的大部分细节内容是在我的电脑运行 Windows 10 家庭版系统时编写的，该系统配备了一个相当普通的内置 2.5 英寸西部数据 Green 120 GB 固态硬盘。该硬盘使用慧荣科技 SM2258XT 主控和四个 32 GB 的闪迪 05497 032G 15nm 3D TLC 闪存芯片，并内置了容量未知的 SLC 缓存。由于本文试图讨论固态硬盘作为一个整体的行为，因此使用什么主机操作系统或文件系统应该无关紧要，但在我的例子中是 Windows 和 NTFS。本文中的内容并非针对特定品牌或类型的固态硬盘，而应该是通用的。我们真正要讨论的是固态硬盘的工作原理。 我唯一使用的额外软件应用程序是 Recuvae（Piriform 出品），HexDen (HxD)。Recuva 可以列出活动文件和已删除文件及其簇分配，而 HexDen 是一款非常实用且功能强大的十六进制编辑器。Recuva 可从 www.piriform.com （现在是 https://www.ccleaner.com/ ） 免费获取，HexDen 也可从 www.mh-nexus.de 免费获取。我使用这两款软件的便携版（portable versions）。 所有的结论和观点完全是来自我个人的工作经历，以及从我自己的电脑上获取的任何数据。在接受这些话作为真理之前，最好验证或至少同意我的推理。这里的很多内容是对一个非常复杂主题的简化解释。 SSD 物理内部结构打开固态硬盘，你会有些失望，只有一块小型印刷电路板，上面有几颗 NAND 闪存芯片和一颗主控芯片，重量轻，而且有点脆弱。至于主控内部的软件，我只能概括其基本任务。主控和内存芯片一样，通常都是从外部制造商处购买的，这似乎是司空见惯的事情。固态硬盘主控软件是专有的，非常复杂，而且受到高度保护，但所有主控都必须执行基本任务，即使我们不太清楚它是如何实现的。这里只能讨论这些任务，真正聪明的调整和技巧只能由制造商知晓。我将从一些基础知识开始。 NAND 闪存我不打算深入探讨 NAND 闪存的内部结构，在维基百科上已经有足够多令人困惑的文章了。你真正需要知道的是，NAND（非与门）闪存利用浮动栅晶体管阵列来存储信息。浮动栅可以没有电子的充电状态，处于空（empty）逻辑状态，或者在不同的电压阈值下充满电子，处于表示某个值的逻辑状态。NAND 闪存是非易失性的，即使 SSD 没有通电，它也能保持其状态。哦，对了，之所以称之为 flash（闪存），是因为可以同时擦除（flashed）大量的单元。 但如果你想了解更多，继续吧。这里的术语单元（cell）和晶体管（transistor）指的是同一物理实体，可以互换使用，我不会一直重复使用 NAND 这个词。 闪存包含多个二维晶体管阵列，并支持三种基本操作：读取、编程（写入）和擦除。除了闪存阵列外，闪存芯片还包括命令和状态寄存器、控制单元、解码器、模拟电路、缓冲器以及地址和数据总线。一个单独的芯片承载着 SSD 控制器，它向闪存芯片发送读取、编程或擦除命令。在读取操作中，控制器将物理地址传递给闪存芯片，闪存芯片定位数据并将其发送回控制器。在编程操作中，数据和物理地址都会传递给芯片。在擦除操作中，只有物理地址会传递给芯片。 闪存芯片的锁存器存储从闪存阵列传输到芯片和从芯片传输出的数据，而在读取操作期间，感应放大器用于检测比特线上的电压。控制器使用状态寄存器监控发送到芯片的命令。控制器还包括错误检查和纠正（EEC）算法，来管理芯片中的错误和可靠性问题，并确保读取或写入的数据是正确的。 阵列的每一行通过字线（Word line）连接，每一列通过比特线（Bit line）连接。在行和列的交叉点是一个浮动栅晶体管，或称为单元，逻辑数据就存储在这里。字线并行连接到晶体管，比特线串行连接。比特线的端部连接到感应放大器。 闪存阵列被划分为块，块又被划分为页。在一个块内，与每条字线相连的单元构成一个页。与位线相连的单元则表示块中的页数。常见的页面大小为 4k、8k 或 16k，128 到 256 个页面组成一个 512k 到 4mb 大小的块。页是芯片控制单元可寻址的最小数据粒度。 读取或编程操作涉及芯片控制器使用块解码器选择相关块，然后使用页解码器选择块中的页。芯片控制器还负责激活正确的模拟电路，以产生编程和擦除操作所需的电压。 虽然每行的单元格数名义上与页面大小相等，但每行的实际单元格数却高于每页的标称容量。这是因为每个页面都包含一组备用单元和数据单元。备用单元存储该页面的 ECC 位以及页面的物理地址到逻辑地址映射。控制器还可在备用区中保存有关页面的其他元数据信息。在读取操作过程中，整个页面（包括备用区中的位）都会传输到控制器。控制器中的 ECC 逻辑会检查并纠正读取的数据。在编程操作期间，控制器会将用户数据和 ECC 位传送到闪存。 系统启动时，控制器会扫描整个闪存阵列中每个页面的空闲区域，将逻辑地址到物理地址的映射加载到自己的内存中（控制器中可能有其他保存映射数据的技术）。控制器在闪存转换层（FTL）中保存逻辑地址到物理地址的映射。FTL 还执行垃圾回收，清除写入后的无效页面，并执行损耗均衡，确保所有闪存块都得到均衡使用。 由于闪存不支持原地更新，所以在内容可以被编程之前，页面需要被擦除；但不同于以页面粒度进行的编程或读取操作，擦除操作是以块粒度执行的。 2D、3D, 和 Layers（层）在闪存架构中，一个平面闪存块，也就是一个二维的存储单元阵列，被称为 2D 闪存。如果一个或多个这样的阵列叠放在一起，那么就是 3D 闪存。3D NAND 闪存建立在一块芯片上，最多可达 32 层，是为了在平面闪存达到尺寸限制时降低成本而设计的：3D 闪存的生产成本几乎与 2D 相当，但存储容量大大增加。在 2D 和 3D 中，每个页面（即行）中的存储单元由单词线连接，而页面中的每个偏移量（即列）中的存储单元则通过位线连接（简单地说）。 3D 闪存与层叠式闪存不同，后者是将多个独立的超薄芯片堆叠在一起。这种做法成本高得令人望而却步。大多数现代消费级固态硬盘（2010 年代）都使用 3D TLC 闪存。 我能看到其中一个单元吗？终端用户闪存的单元尺寸极小，通常为 15 纳米，范围从 43 纳米到 12 纳米不等。实际上，单元尺寸或单元直径具有误导性，因为所述尺寸并非单元任何尺寸的测量值，而是芯片上离散组件之间距离的度量。芯片上的硅层厚度约为 0.5 至 3 纳米：相比之下，氢原子的直径为 0.1 纳米，而芯片制造中使用的硅原子为 0.2 纳米。一纳米 (nm) 确实非常小，仅为一米的十亿分之一，打个比方，如果一毫米相当于一颗标准弹珠的大小（约 13 毫米），那么一米就相当于地球的大小。十亿倍的威力令人印象深刻。 SLC、MLC、TLC、QLC 及其未来发展单级单元（SLC）有一个电子电荷阈值来指示一个位的状态，即一或零。多级单元（MLC）存储一个电压来表示两个位的状态，有三个不同的阈值分别代表 11、10、00 和 01。三级单元（TLC）存储三个位的状态，包括 111、110、100、101、001、000、010 和 011。如果有人感兴趣的话，可以推导出四级单元（QLC）使用的 15 个阈值。（我见过其他版本的阈值表示位的含义。） 不幸的是，当双级单元被开发出来时，它被称为多级单元，并被赋予了 MLC 这个缩写，这迫使每个人在想要指代多个级别的存储单元时都要费力地打出“多级单元”这个词。如果它被称为双级单元，我们就可以自由地使用 DLC、TLC 和 QLC，并用 MLC 来描述所有这些，但现在为时已晚。如果闪存只停留在 SLC 阶段，有其是/否、一/零的状态，这些解释将更容易写，希望也更容易理解。 在多级单元中，物理 NAND 页面代表两个或更多的逻辑页面。属于 MLC 的两个位分别映射到两个逻辑页面。奇数编号的页面（包括零）映射到最不重要的（右手）位，偶数编号的页面映射到最重要的（左手）位。同样，属于 TLC 的三个位分别映射到三个逻辑页面，而 QLC 映射到四个逻辑页面（TLC 和 QLC 的页面编号是未知的）。 多层单元需要支持的位数越多，其性能就越受影响。对于 SLC，控制器只需要检查是否超过了一个阈值。而 MLC 单元可以有四个值，TLC 有八个，QLC 有 16 个。为了读取单元的正确值，SSD 控制器需要使用精确的电压和多次读取来确定单元中的电荷。很明显，如果一个物理页面支持多个逻辑页面，那么该页面的读写频率将高于 SLC 页面，从而影响其使用寿命。此外，显而易见的是，TLC SSD 只需要 SLC 设备三分之一的物理单元，因此我的 120 GB TLC SSD 实际上只包含 40 GB 的 NAND 单元。 高使用率的企业级 SSD 曾经是 SLC 的天下，因为它具有更高的速度、耐用性、可靠性和读/写能力，而 MLC 和 TLC 也逐渐被企业级应用所接受。终端消费级 SSD 市场则获得了更便宜、容量更大，但速度更慢、更脆弱的多层单元。 为什么空代表一？任何仍在关注这一点的人可能已经注意到，单层和多层单元都有一个共同点，那就是一个空的单元格（其中浮栅没有电荷）代表一。与 HDD 不同，HDD 中任何位模式都可以写入任何位置，而 SSD 页面上存在一个默认的逻辑状态 1。这是因为单元上只有一个编程功能，即跨浮栅移动电子。NAND 闪存单元只能被编程为零状态，而没有能力编程为一。对于多层单元，所有页面的默认值仍然为 1，但即使在单元格被编程并且栅极上有电子存在之后，逻辑 1 仍然可以表示。 自从斐波那契在 1202 年将带有零概念的印度-阿拉伯数字系统引入欧洲数学以来，人类的思维就将零与空联系在一起，将一与满联系在一起。空着却代表一，这让人相当困惑，而且似乎主要来自于惯例（空状态可以代表零，但需要在数据线上使用反相器）。可能是电路不那么复杂，也可能是空单元格传导电荷的能力意味着它是一。 它们都是 SLC在讨论了这么多之后，或许有必要强调一点：无论预期用途如何，所有 NAND 闪存的物理结构都是 SLC（单层存储）。即使你能观察 TLC（三层存储）单元的内部，你也不会看到 101、011 或任何类似的数字。一个单元格中永远只可能存在一定数量的电子，无论这个数量如何解释。SSD 控制器知道应该将单元格视为 SLC、MLC 还是其他类型，并相应地对其进行编程、测量电子数量，并确定它代表的逻辑值。但即使是四层单元格也只能包含一个值，就像 SLC 单元格一样。 迷思与误解现在我们来谈谈迷思、误解以及撰写本文的真正原因：当 SSD 页面被读取、写入和重写时会发生什么？这将如何影响已删除文件的恢复？一方面，我们有 NTFS，它专为 HDD 设计，远早于 SSD 的普及；另一方面，我们有 NAND 闪存，它有其独特的运作方式；此外，还有数十亿人多年来已经习惯了 HDD 的使用方式和预期。在这里，如果没有特别说明，我将交替使用 SSD 和 NAND 闪存，尽管这样说并不完全准确。 存储设备控制器所有 HDD、SSD 和闪存驱动器都有一个内部控制器。用微软的话来说，控制器使得存储设备能够对主机进行“抽象化”。这种抽象是通过逻辑块寻址（LBA）实现的，其中存储设备上每个能够被寻址的簇都由主机通过一个递增的数字（LBA）来识别。存储设备控制器将该数字映射到设备上的扇区或页面。对于主机来说，这种映射是恒定的，一个簇会一直映射到同一个 LBA，直到主机更改它。在 HDD 上，这种关系是物理的、固定的：简单来说，HDD 控制器只是读取和写入主机要求的任何扇区。它不需要考虑以前那里有什么，它只是按照指令行事，将新数据写入旧数据之上。它之所以这样做，是因为它可以这样做，没有什么可以阻止新的簇直接写入旧簇的相同扇区之上。而在 SSD 上，情况就不同了。 对于 SSD，主机仍然使用 LBA 寻址系统，并不断协调 LBA 和簇号之间的关系。它知道该设备是一个 SSD，并有一些技巧来适应这一点，但这些技巧将在后面介绍。然而，SSD 控制器有许多技巧来协调为 HDD 编写的文件系统与 NAND 闪存的需求。 闪存转换层（FTL）主机仍然使用 LBA 寻址来对 SSD 进行读写操作，因为它不知道其他方式。这些命令会被 SSD 控制器上的闪存转换层 (FTL) 拦截。FTL 维护着一个 LBA 到物理块地址 (PBA) 的映射表，并将转换后的 PBA 传递给控制器。之所以需要这个映射表，是因为与 HDD 不同，LBA 到 PBA 的关系是易失的。之所以易失，是因为 NAND 闪存的写入数据方式。 一个空的页面，所有单元都未充电，默认情况下包含全 1。然而，如果使用十六进制编辑器查看 SSD 的空扇区，它将显示为一组零。这是因为空页面没有分配给 LBA/PBA 映射表。相反，如果对一个空页面发出读取请求，则会返回一个默认的零页面。这适用于未分配的簇和属于文件的簇：SSD 不会分配一个页面并将所有单元从 1 改为 0。 浮栅晶体管在深入了解读取和写入操作之前，这一部分可能会有所帮助，在这里，单元格和（FG）晶体管可以互换使用（一个单元格就是一个晶体管）。如果想了解更多关于浮栅金属氧化物半导体场效应晶体管（Metal-Oxide-Semiconductor Field-Effect Transistors，简称 MOSFET）的信息，可以随时查阅维基百科。 浮栅 MOS 晶体管有三个端子：栅极、漏极和源极。当一个电压被施加到栅极上时，电流就可以从源极流向漏极。施加到栅极的低电压会导致从源极到漏极的电压按比例变化。当电压升高时，这种比例响应会停止，不管怎样栅极都会关闭。 浮栅中的电荷会改变晶体管的电压阈值，即栅极关闭的点。当栅极电压高于某个值，大约 0.5 伏时，栅极总是会关闭。当电压低于这个值时，栅极的关闭由浮栅电压决定。 如果浮栅没有电荷，那么施加到栅极的低电压就会关闭栅极，并允许电流从源极流向漏极。如果浮栅带有电荷，那么需要施加更高的电压到栅极上，栅极才会关闭并且电流才会流动。浮栅中的电荷改变了为了使栅极关闭并导电所必须施加到栅极上的电压。 SSD 读取NAND 闪存的设计并没有固有的特性来阻止对单个单元格的读取和写入。然而，为了符合 NAND 闪存设计的目标——即简单和小巧——NAND 芯片接受的标准命令被构造成页面是最小的可寻址单元。这样就省去了存储额外指令和单元格到页面映射所需的空间。 要读取单个页面及其内部的单元格，需要将该页面与块内的其他页面隔离开来。为此，未被读取的页面会被临时禁用。 同一块内的同一行（一个页面）的所有单元格/晶体管通过字线（Word Line）并联连接到晶体管的栅极。同一列（单元格偏移）的所有晶体管串联在一起，通过位线（Bit Line）连接，将一个的漏极与下一个的源极相连。在每个位线的末端是一个感应放大器。进行读取操作时，除了正在读取的页面外，所有字线上都会施加一个穿透电压。穿透电压接近或高于可能的最高阈值电压，并迫使所有未被读取页面中的晶体管关闭，不管它们是否存储了电荷。所有位线都会通入低电流。 正在读取的页面的字线会被给予一个参考电压，所有位线感应放大器进行读取。储存了足够电子数量的晶体管不会被参考电压关闭，位线电流不会通过源/漏链传递到感应放大器。没有电荷，或电荷低于阈值的晶体管会被参考电压关闭，并将位线电流传导到感应放大器。为了确定多级单元格的逻辑状态，需要进行多次不同阈值电压的读取。 （为了增加或避免更多的混淆，浮栅晶体管可以是开启或关闭状态。开启状态的栅极不导电，关闭状态的栅极则导电。所以如果栅极是开启的，就没有电流能通过；如果关闭了，就能通过。难怪我们会感到困惑。） 由此可见，要读取块中的一个页面，块中每个页面的所有晶体管都需要接收一个穿透电压或一个或多个参考电压。即使块中的其他页面部分或全部为空，这一点似乎仍然适用。这在下面的读取干扰中变得很重要。 读取存储理解 SLC 读取背后的概念相当容易。SLC 闪存只应用一个阈值，因此只需要一个测试电压——浮栅要么关闭，要么不关闭。如果阈值电压使栅极关闭，则位线电流流向读出放大器，存储值为 1。如果没有，则为 0。 多级单元则不同，存储值位序背后的原因也变得明显。在 MLC 中，可能的用户信息位组合为 11、10、00 和 01，由三个阈值分隔。读取最高有效位 (l/h) 只需要读取一次中间阈值电压。如果栅极关闭，则最高有效位为 1，如果未关闭，则最高有效位为 0，无论最低有效位是什么。要读取最低有效位 (r/h)，需要读取两次，一次读取阈值一，一次读取阈值三。如果读取阈值一使栅极关闭，则最低有效位设置为 1，不需要读取第二次。如果栅极打开，则读取阈值三。如果它关闭，则最低有效位设置为 0。如果没有，则值为 1。 TLC 单元中的位组合为 111、110、100、101、001、000、010 和 011，由七个阈值分隔，更难以理解。与 MLC 一样，最高有效位仍然只需要读取一次中间阈值。中间位需要读取两次，分别在阈值二和六，最低有效位需要读取四次，分别在阈值一、三、五和七。 所有基于最高有效位 (l/h) 的多单元页面都被视为 SLC，只需要读取一次即可确定用户信息位值。 SSD 写入NAND 闪存最重要的方面，也是 HDD/SSD 路径上最大的分叉点，以及接下来所有内容的基础和关键因素是，数据只能写入空的 SSD 页面。这并不是什么新鲜事，也不是什么未知的事情，但它对数据安全和恢复有着最大的影响。 虽然 SSD 可以读写单个页面，但它们不能覆盖页面，因为将 0 变回 1 所需的电压会损坏相邻的单元。所有写入和重写都需要一个空白页。与 HDD 不同，HDD 会将完整的簇写入磁盘，无论之前有什么内容，写入 SSD 页面的行为是分配一个默认值为全 1 的空白页，并对需要更改为 0 的单元施加电荷。这对多级单元和 SLC 都是一样的，因为无电荷全 1 的模式要么被替换为代表另一种模式的电荷，要么保持不变。这是一个一次性的过程。 当发出写入请求时，会分配一个空页面（通常在同一个块内），然后写入数据。FTL 中的 LBA/PBA 映射会更新，以便将新页面分配给相关的 LBA。LBA 对主机来说始终保持不变：无论分配哪个页面，主机都不会知道。如果用户数据被重写或分配了一个新文件，这个过程是相同的：唯一的区别是重写的工作量会稍微多一些。旧页面将被标记为无效，主机将无法访问，但仍会占用其块内的空间，因为它无法被重用。 虽然很容易理解写入 SLC 页面的过程，但多级单元页面的情况更难想象。控制器会将新的写入累积到 SSD 缓存中，直到收集到足够多的逻辑页面来填充一个物理页面，然后才会写入物理页面。这需要对页面进行最少的写入次数。如果修改了多级页面中的一个逻辑页面，则需要分配一个新页面并重写所有逻辑页面，因为物理页面中的各个值无法更改。如果删除了一个逻辑页面，那么我推测该逻辑页面会被标记为无效，当该块成为垃圾回收的候选对象时，任何有效的逻辑页面都会在写入之前进行合并。换句话说，一个多级页面，或者至少是其中的大部分，将始终包含一整套逻辑页面。 很明显，如果 NAND 闪存以这种方式处理数据写入（事实也确实如此），那么 SSD 最终将充满有效和无效的页面，性能也会逐渐降低到爬行的程度。虽然单个 SSD 页面无法擦除，但一个块可以擦除，这种方法用于将块恢复到可写状态。为了加快这一过程，并确保始终有一组空块可用于写入，SSD 控制器会使用垃圾回收。 垃圾回收从最简陋到容量最高的 SSD，垃圾回收功能都已启用：如果没有它，NAND 闪存将无法使用。垃圾回收是 SSD 控制器的一部分，主机并不知道它的工作。在最简单的形式中，GC 会选取一个包含有效和无效页面的块，将有效页面复制到一个新的空块中，更新 LBA 映射表，并将旧块放入无效块池中。在那里，该块及其页面将被重置为空状态，并将该块添加到可用块池中。因此，应该始终有一组可用块可用于写入活动。只要 SSD 通电，GC 就会执行其工作，无法停止。GC 例程有各种复杂的技术，所有这些技术都是专有的，而且主要只有制造商才知道。 当一个全新的 SSD 从工厂出厂时，写入操作会以渐进的线性模式逐渐填满驱动器，直到可寻址存储空间被完全写入。然而，一旦垃圾回收开始，数据写入的方式（顺序写入还是随机写入）就会影响性能。顺序写入的数据会写入整个块，当数据被替换时，整个块会被标记为无效。在垃圾回收期间，不需要将任何数据移动到另一个块。这是最快的垃圾回收方式，也就是说，没有垃圾需要回收。当数据被随机写入时，无效页面会分散在整个 SSD 中。当垃圾回收作用于包含随机写入数据的块时，必须将更多数据移动到新块，然后才能擦除该块。 垃圾回收难题垃圾回收可以在后台进行（当主机空闲时），也可以在前台进行（当写入需要时）。虽然后台垃圾回收看起来更可取，但它也有缺点。如果主机在空闲时使用节能模式，垃圾回收要么会等待设备重新启动，从而导致用户延迟以完成垃圾回收，要么会唤醒设备并缩短电池寿命，而此时主机处于“空闲”状态。此外，垃圾回收并不知道它正在回收的数据。不可避免的是，一些数据在进行垃圾回收后不久就会被删除，从而导致另一轮垃圾回收和随之而来的额外和不必要的写入（写入放大，即实际写入与数据写入的比率）。前台垃圾回收看似与性能背道而驰，但它避免了节能问题，只在实际需要时才进行写入，并且借助快速缓存和高度发达的垃圾回收算法，不会给用户带来明显的性能损失。现代垃圾回收的趋势似乎是前台回收，或者前台和后台回收的组合。 基于前台垃圾回收，以及大多数用户活动都是随机的，那么不可避免的结论是，SSD 将在其大部分生命周期中处于满容量状态，如果我们指的是可用块，即使分配给主机的空间看起来很低。 然而，SSD 还存在另一个潜在问题，这与一个历史事件有关：文件系统的设计方式。 文件系统 —— 非眼见为实主机文件系统的设计可以追溯到 HDD 称霸的时代，因为 SSD 那时还没有以可用且价格合理的形态出现。文件系统没有考虑到 NAND 闪存的需求。文件在不断地更新：它们被分配、移动和删除，大小也在增长和缩减。文件系统处理这些操作的方式与 NAND 闪存的工作机制不兼容。 值得强调的是，存储设备对主机操作系统是抽象的。虽然资源管理器以人类完全可以理解的形式显示了一系列文件夹和文件，但这只是一种假象。资源管理器显示的是一个完全由文件系统表中的元数据创建的逻辑结构。存储设备控制器对文件、文件夹、表或操作系统一无所知：HDD 或 SSD 看到的只是读取或写入特定扇区的命令，而它们也忠实地执行了这些命令。然而，SSD 与 HDD 相比有一个优势，它知道哪些页面保存着数据并映射到 LBA，哪些页面是空的、不保存有效数据且未映射到 LBA。相反，HDD 不需要知道这些，对 HDD 来说，所有扇区都是一样的。 文件删除在 NTFS 文件系统中，当一个文件被删除时，主文件表 (MFT) 中的对应条目会被标记为已删除，并且集群位图也会被修改，将该文件占用的集群标记为可重用。整个删除过程只在 MFT 和集群位图中进行。这对 HDD 来说完全足够了，因为 NTFS 可以随时重用 MFT 条目和集群。 在 SSD 上，从 NTFS 的角度来看，这个过程完全相同，因为 NTFS 没有其他删除文件的方法。然而，SSD 看到的只是 HDD 看到的内容，即对几个页面的更新。HDD 和 SSD 都不知道正在更新的是 MFT 和集群位图，因为它们对这些东西一无所知。由于已删除文件的集群上没有任何活动，因此 SSD 中保存这些集群的页面仍然映射到 FTL 中的 LBA。SSD 的 FTL 无法知道这些页面不再被 NTFS 分配：对 SSD 来说，这些页面仍然有效，不会被垃圾回收清理。 由于这些“死”页面被分配给了 LBA，因此当分配或扩展文件并且主机使用该 LBA 时，它们可能会被释放。在这种情况下，该页面将被标记为无效，并使用一个新页面。然而，最终不可避免地会出现大量未被标记为垃圾回收的未使用和不需要的数据，这些数据会被 SSD 控制器毫无意义地维护，并且无法重用。为了克服这个问题，并将主机对已分配和未分配页面的视图与 SSD 的视图关联起来，从 Windows 7 开始，NTFS 获得了 TRIM 命令。 SSD 检测尽管文件系统对存储设备进行了抽象，但为了启用文件系统针对 SSD 的一些优化，它需要知道设备是 HDD 还是 SSD。有多种方法可以做到这一点，包括查询设备的转速，对于 SSD 来说，转速应该是零（或者可能是一）。这似乎是最广泛使用和最有效的方法。 TRIMTRIM 并非缩写，而是一条 SATA 指令，由文件系统发送至 SSD 控制器，用于指示特定页面不再包含有效数据，可以进行垃圾回收。在 Windows 系统中，只有 NTFS 卷支持 TRIM。文件删除、分区删除和磁盘格式化都会触发 TRIM。TRIM 指令需要 SSD 支持并在 NTFS 中启用才能生效。 你可以使用命令 fsutil behavior query disabledeletenotify 来检查 TRIM 是否在操作系统中启用。如果返回值为 0，则表示 TRIM 已启用。但这并不代表 SSD 支持 TRIM（甚至不能确定是否安装了 SSD），不过目前所有现代 SSD 都支持某种版本的 TRIM。 SATA 协议定义了三种不同类型的 TRIM，SSD 驱动器也实现了这三种类型： 非确定性 TRIM：在执行 TRIM 后，每次读取命令都可能返回不同的数据。 确定性 TRIM (DRAT)：在执行 TRIM 后，所有读取命令都返回相同的数据（即结果是确定的），并且在写入新数据之前不会改变。 TRIM 后确定性读取零 (DZAT)：在执行 TRIM 后，所有读取命令都返回零，直到该页面被写入新数据。 需要注意的是，虽然 DRAT 在读取时返回数据，但返回的数据并不是 TRIM 之前的用户数据，而是一些随机数据。 幸运的是，非确定性 TRIM 很少使用，而且 Windows 也不支持 DRAT。因此，读取已 TRIM 的页面（使用十六进制编辑器很容易做到）会调用 DZAT，并在发出 TRIM 命令后立即返回零。尽管物理页面可能没有在 TRIM 命令之后立即被清理，但 SSD 控制器知道在已 TRIM 的页面地址上没有保存有效数据。 TRIM 告诉 FTL（闪存转换层），分配给特定逻辑块地址 (LBA) 的页面将被归类为无效。当一个块不再有任何空闲页面，或者达到特定阈值时，该块就成为垃圾回收的候选对象。活动数据会被复制到一个新的空块中，而原始块会被擦除并重新可用。 TRIM 是一种异步命令，会被排队等待低优先级操作。它不需要也不发送响应。TRIM 队列的大小是有限的，在高负载情况下，一些 TRIM 命令可能会被丢弃。这种情况不会有任何提示，因此一些不需要的页面可能会逃过垃圾回收。 RETRIMWindows 系统中的磁盘碎片整理工具（现已更名为 存储优化）提供了一个优化 SSD 的选项。但这并不会对 SSD 进行碎片整理，而是向 NTFS 集群位图中标识的所有未分配页面发送一系列 TRIM 命令。 这种全局 TRIM（或称为 RETRIM）命令的运行粒度经过精心设计，可以确保 TRIM 队列永远不会超过其允许的大小，并且不会丢弃任何 RETRIM 命令。存储优化工具会每月自动运行一次 RETRIM。 预留空间所有 NAND 闪存设备都使用预留空间，即额外容量，用于额外的写入操作、控制器固件、坏块替换以及 SSD 控制器使用的其他功能。这些容量并不是与用户容量物理隔离的，而仅仅是超出主机可分配空间的一部分。随着 SSD 的使用，这些额外空间中的特定页面会动态变化。 希捷公司表示，最小预留空间是二进制和十进制命名约定之间的差异。SSD 作为存储设备销售，其容量以 GB（1,000,000,000 字节）为单位。然而，NAND 闪存属于内存，以 GiB（1,073,741,824 字节）为单位，这使得最小预留空间比例略高于 7.37%。即使 SSD 在主机看来已满，它仍然拥有 7.37% 的可用空间来维持功能和执行写入操作（尽管写入性能会非常糟糕）。 除了内置的 7.37% 之外，制造商可能会进一步减少用户可用的容量，并将其作为额外的预留空间。主机也可以通过分配一个不使用驱动器全部容量的分区来创建额外的预留空间。未分配的空间将自动被控制器用作动态预留空间。 例如，我的西部数据 SSD 有四个 32 GB 的芯片，但标称容量为 120 GB，这意味着它预留了 8 GB 作为额外的预留空间。再加上 7.37% 的最小值（9.4 GB），总共 17.4 GB 的预留空间几乎占总容量的 15%。 磨损均衡有些文件写入一次后就保持不变，而有些文件则会频繁更新。因此，一些块几乎不会进入无效块池，其擦写次数非常低，而另一些块则每隔几分钟就会进入一次池，擦写次数非常高。为了分散磨损，使所有块的擦写次数相等，并保持 SSD 在其使用寿命内的性能，就需要使用磨损均衡技术。 磨损均衡使用算法来识别擦除次数最低的块，并将内容移动到擦除次数高的块；并在分配新数据时选择擦除次数低的块。与垃圾回收一样，磨损均衡的复杂程度远远超出了我的理解范围，更不用说解释了。 读取干扰SSD 读取操作并非完全免费，需要付出一定的代价。如上所述，读取一个页面会在该块中的所有其他单元上产生穿通电压。这种电压可能低于单元可以保持的最高阈值，但它仍然会在单元上产生微弱的编程效应，从而无意中改变其阈值电压。穿通电压会导致电隧道效应，使未读取单元的电压向更高的值移动，从而干扰单元内容。随着闪存单元尺寸的减小，晶体管氧化层变得更薄，进而增加了这种隧道效应，未读取的闪存单元只需要更少的相邻页面读取操作就会受到干扰，并进入不同的逻辑状态。保持较低阈值的单元更容易受到读取干扰的影响。 因此，每次读取都可能导致同一块中其他未读取单元的阈值电压向更高的值移动。在大量读取操作之后，这可能会导致这些单元出现读取错误。每个块都会保留一个读取计数，如果超过该计数，则会重写该块。SLC 单元的读取计数很高，大约为 100 万次，25 纳米 MLC 单元的读取计数较低，大约为 40,000 次，而 15 纳米 TLC 单元的读取计数则更低。 文件恢复在 SSD 上，NTFS 删除文件的过程与在 HDD 上完全相同，只是多了 TRIM 命令。TRIM 命令（假设它被执行）和一些 SSD 的特性会破坏任何实际恢复已删除文件的可能性。 如上所述，TRIM 命令在 SSD 控制器中有一个对应的设置，即 DRAT 和 DZAT。（我不认为任何知名品牌的 SSD 会使用非确定性 TRIM，而且我认为 Windows 不支持 DRAT，但我没有证据。）DZAT 的实现意味着，一旦 TRIM 命令成功执行（在大多数情况下，这会在文件删除后立即执行），任何读取已 TRIM 页面的尝试都将返回零。页面上的数据在被垃圾收集器处理之前仍然存在，但这些数据无法通过任何实际方法或任何通用软件从主机访问。 垃圾回收独立于主机设备，并由 SSD 控制器决定何时调用。一旦该过程开始，就无法停止，除非关闭 SSD 的电源。一旦重新上电，垃圾收集器将恢复其职责，直到完成。 对于最终用户来说，在现代 SSD 上恢复已删除的文件几乎是不可能的，而在 Windows 下，这几乎是不可能的。从理论上对芯片进行检查很可能会显示出经过压缩和加密的数据，这些数据分布在多个块上，并且不可能将多个页面中的一个数据页与另一个数据页关联起来。有一种非常小的可能性可以恢复最近删除的文件，方法是立即关闭 SSD 的电源，并将其送到专业的 数据恢复公司。在有足够的时间和金钱的情况下，他们可能会恢复一些数据。 在删除文件（例如运行 Piriform 的 CCleaner）之后，在 SSD 上运行 Recuva。找到的已删除文件（以及可能的文件的其余部分）的标题都将为零。这是 TRIM 和 DZAT 在几秒钟内完成的工作，从而扼杀了任何恢复已删除文件的可能性。当然，TRIM 可以被禁用，但代价是性能下降，但如果要删除以后可能需要的文件，最好还是谨慎一些。 安全删除文件安全删除文件的概念，在删除之前覆盖文件的数据，是无关紧要的，并且如果选择除零以外的任何其他模式，只会对 SSD 造成额外且毫无意义的磨损。即使使用零覆盖也会导致写入事务日志和其他文件，因此永远不应该在 SSD 上使用安全删除文件。擦除可用空间对于无意义的写入来说要糟糕得多，而且比安全删除文件更加徒劳无功。删除的文件根本就不存在了。 OCZ 论坛传说几年前（作为对这些大段文字的一点轻松调剂），OCZ 论坛上充斥着恢复 SSD 性能的最新方法：运行 Piriform 的 CCleaner 擦除可用空间功能，并使用零进行一次覆盖。虽然性能可能已经恢复，但逻辑和常识却荡然无存。当时的理论是，用零覆盖页面等同于擦除块（这在 TRIM 出现之前）。这是无稽之谈，从一开始就应该很明显。空页面的默认状态是全 1，而不是零，而且软件怎么可能擦除 NAND 闪存？真正的原因是，当 CCleaner 用零填充页面时，SSD 控制器只是取消了页面的映射，并向主机显示默认的零页面。然后，无效页面成为垃圾收集的候选对象，这为写入提供了更大的块池，从而获得了更好的性能。这是一种在 RETRIM 发明之前的类似技术。 SSD 碎片整理关于固态硬盘的一条准则是永远不要对其进行碎片整理。虽然将簇重新排列到相邻页面几乎没有什么好处（有一点好处）——固态硬盘在随机读取时没有明显的开销——但固态硬盘碎片整理并非完全禁止。事实上，从 Windows 8 开始，如果满足某些条件，存储优化器将对固态硬盘进行碎片整理。如果启用了系统还原，碎片级别高于 10%，并且自上次碎片整理以来至少过去了一个月，Windows 存储优化器计划维护将对固态硬盘进行碎片整理。这就是微软所说的传统碎片整理，它不是优化（RETRIM）。启用系统还原时，需要进行碎片整理以减少卷快照文件上的区段。 每月进行一次碎片整理没有什么可怕的。大多数用户不会达到 10% 的碎片标准，因此将运行简单的 RETRIM，而 Windows 10 用户无论如何都不会进行碎片整理（默认情况下，Windows 10 中禁用了系统还原）。固态硬盘寿命的减少不会被注意到。此外，尽管固态硬盘不受随机读取的影响，但文件确实会变得碎片化，这意味着 I/O 会显着增加。偶尔清理一下是有益的。 固态硬盘寿命： 许多用户担心固态硬盘的使用寿命。是的，连续的写入/擦除循环，以及额外和不可见的写入放大，确实会影响 NAND 闪存的寿命。使用固态硬盘确实会将其磨损。我的西部数据 Green 120 GB 固态硬盘，一款来自信誉良好的制造商但成本最低的三层单元 (TLC) 固态硬盘，估计寿命为 100 多万小时，写入限制为 40 TB。100 万小时是 114 年，所以我们可以忘记这一点。至于写入，以每天 1 GB 的速度（远远超过我目前的数据使用率），将需要相同的 114 年才能达到 40 TB。即使有巨大的写入开销，这款固态硬盘在可预见的未来也不会磨损。如果所有 128 GiB 的可用闪存都得到平等使用，则 40 TB 相当于每个单元 312 次写入，这是一个非常保守的数字。 结语唯一要补充的是，NAND 闪存、固态硬盘，尤其是固态硬盘控制器，远比我在这里写的内容、我所知道的、我可能理解的以及我可能解释的更加复杂、精密和难以理解。我还应该加上“秘密”一词，因为它们的软件是专有的。虽然机械硬盘是以极低的成本实现的复杂机电工程的奇迹，但固态硬盘是以略高的成本实现的同样出色和复杂的电子和软件产品。我们应该对两者都心存感激。 你可以点击此处，返回我的主页 如果你有任何问题意见或想指出的问题，请告诉我：请发送电子邮件至 kes@kcall.co.uk。 © Webmaster. All rights reserved.","link":"/article/translation/everything-i-know-about-ssd/"},{"title":"关于 Git 错误信息的说明","text":"在写关于 Git 的文章时，我注意到很多人都在纠结 Git 的错误信息。我已经习惯这些错误信息很多年了，所以花了很长时间才明白大家为什么会困惑： 有时我确实被错误信息弄糊涂了，我只是习惯了被弄糊涂而已 当 Git 给我的错误信息不是很有参考价值时，我有很多策略来获取更多信息。 所以，在这篇文章里，我将逐一分析 Git 的错误信息，列出每条信息中我认为容易混淆的地方，并谈谈当我被错误信息弄糊涂时该怎么做。 改进错误信息并不容易在开始之前，我想说的是，通过思考这些错误信息令人困惑的原因，让我对维护 Git 的难度肃然起敬。几个月来我一直在思考 Git 的问题，但对于其中一些错误信息，我真的不知道该如何改进。 在我看来，改进错误信息有以下几点困难： 如果你想出一个新信息的创意，很难说它是否真的更好！ 改进错误信息之类的工作经常得不到资助 错误信息必须翻译（Git 的错误信息被翻译成 19 种语言） 也就是说，如果你觉得这些消息令人困惑，希望这些注释能够在一定程度上帮助澄清它们。 error: git push on a diverged branchgit push To github.com:jvns/int-exposed ! [rejected] main -&gt; main (non-fast-forward) error: failed to push some refs to 'github.com:jvns/int-exposed' hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. git status On branch main Your branch and 'origin/main' have diverged, and have 2 and 1 different commits each, respectively. 我觉得有些事情令人困惑: 无论分支是 behind（落后） 还是 diverged（偏离），您都会收到完全相同的错误信息。从这条信息中无法判断是哪个分支：您需要运行 git status 或 git pull 才能知道。 它说 failed to push some refs（推送某些引用失败），但并不完全清楚推送失败的是哪些引用。我相信所有推送失败的引用都会以 ！[rejected]在前一行，在本例中，只有 main 分支。 困惑时我喜欢做的事 我会运行 git status 来了解当前分支的状态。 我想我几乎从来没有尝试过一次推送多个分支，所以我通常会完全忽略 Git 关于哪个分支推送失败的说明 - 我只是假设它就是我的当前分支 error: git pull on a diverged branchgit pull hint: You have divergent branches and need to specify how to reconcile them. hint: You can do so by running one of the following commands sometime before hint: your next pull: hint: hint: git config pull.rebase false # merge hint: git config pull.rebase true # rebase hint: git config pull.ff only # fast-forward only hint: hint: You can replace \"git config\" with \"git config --global\" to set a default hint: preference for all repositories. You can also pass --rebase, --no-rebase, hint: or --ff-only on the command line to override the configured default per hint: invocation. fatal: Need to specify how to reconcile divergent branches. 我认为这里最令人困惑的是，git 给你提供了大量的选项：它说，你可以任选其一： 在本地配置 pull.rebase false, pull.rebase true, 或者 pull.ff only 或全局配置 或运行 git pull --rebase 或者 git pull --no-rebase 很难想象一个初学 git 的人如何能轻松地利用这个提示，自己整理出所有这些选项。 如果我向朋友解释这个问题，我会说 “你可以用git pull --rebase 或git pull --no-rebase 来解决这个问题。如果你想设置一个永久的偏好，你可以用git config pull.rebase false 或git config pull.rebase true。 我觉得 git config pull.ff only 有点多余，因为这是 git 的默认行为（虽然并不总是这样）。 我喜欢在这里做 运行 git status 查看当前分支的状态 也许运行 git log origin/main 或 git log 查看分支提交的情况 通常会运行 git pull --rebase 来解决它 如果我想丢弃本地提交（local work）或远程提交（remote work ），有时会运行 git push --force 或 git reset --hard origin/main（例如，因为我不小心提交到了错误的分支，或者因为我在一个只有我在用的个人分支上运行了 git commit --amend 并想强制推送）。 error: git checkout asdf (a branch that doesn’t exist)git checkout asdf error: pathspec 'asdf' did not match any file(s) known to git 这有点奇怪，因为我的意图是检出一个分支，但git checkout却在抱怨一个不存在的文件路径（path）。 出现这种情况是因为 git checkout 的第一个参数既可以是分支也可以是文件路径，而 git 无法知道你的意图是哪个。要改进这一点似乎很棘手，但我可能会期待类似 No such branch, commit, or path: asdf（没有这样的分支、提交或路径：asdf）这样的提示。 我喜欢在这里做 理论上，用 git switch 代替会更好，切换分支，但我还是一直用 git checkout。 一般来说，我只记得我需要把它理解为分支 asdf 不存在。 error: git switch asdf (a branch that doesn’t exist)git switch asdf fatal: invalid reference: asdf git switch 只接受分支作为参数（除非你传递了 -d），那它为什么会说 invalid reference: asdf 而不是 invalid branch: asdf 呢？ 我认为原因在于，在内部，git switch 试图在其错误信息中提供帮助：如果你运行 git switch v0.1 来切换到一个标签，它会说： git switch v0.1 fatal: a branch is expected, got tag 'v0.1'` 所以，git 试图通过 fatal: invalid reference: asdf 传达的意思是“asdf不是一个分支，但也不是一个标签，或者其他任何引用”。从我的各种git polls来看，我的印象是很多 git 用户根本不知道什么是 git 中的 reference（引用），所以我不确定他们是否理解了这一点。 我喜欢在这里做90% 的情况下，当 git 错误信息中出现 reference 时，我都会在脑海中把它替换成 branch。 error: git checkout HEAD^git checkout HEAD^ Note: switching to 'HEAD^'. 您处于 detached HEAD（分离的 HEAD）状态。您可以四处看看，进行试验性改动并提交，还可以通过切换回分支来放弃在此状态下所做的任何提交，而不会影响任何分支。状态下的任何提交，而不会影响任何分支。 如果你想创建一个新的分支来保留你创建的提交，可以在 switch 命令中使用 -c 来实现（现在或以后）。示例 git switch -c 或者使用: git switch - 通过将配置变量 advice.detachedHead 设为 false 关闭该建议 HEAD 现在的位置是 182cd3f，添加 swap byte order 按键 这是一个难题。肯定有很多人对这条信息感到困惑，但显然也有很多人在努力改进它。对于这个问题，我没什么好说的。 我喜欢在这里做 我的 shell 提示会告诉我是否处于分离的 HEAD 状态，一般来说，在这种状态下我不会提交新的内容。 当我看完我想看的旧提交后，我会运行 git checkout main 或其他命令返回到某个分支 message: git status when a rebase is in progress这不是一条错误信息，但我还是觉得它本身有点令人困惑: git status interactive rebase in progress; onto c694cf8 Last command done (1 command done): pick 0a9964d wip No commands remaining. You are currently rebasing branch 'main' on 'c694cf8'. (fix conflicts and then run \"git rebase --continue\") (use \"git rebase --skip\" to skip this patch) (use \"git rebase --abort\" to check out the original branch) Unmerged paths: (use \"git restore --staged ...\" to unstage) (use \"git add ...\" to mark resolution) both modified: index.html no changes added to commit (use \"git add\" and/or \"git commit -a\") 我认为有两点可以说得更清楚: 如果把 You are currently rebasing branch 'main' on 'c694cf8'.（您正在重定向 ‘c694cf8’ 上的分支main） 放在第一行而不是第五行，我觉得会更好。现在第一行并没有说明您正在重定向哪个分支。 在本例中， c694cf8 实际在 origin/main， 所以我觉得 You are currently rebasing branch 'main' on 'origin/main'（您正在‘origin/main’上重定向分支‘main’）可能更清楚。 我喜欢在这里做我的 shell 提示包括了当前正在重置（rebasing）的分支，所以我依赖它而不是 git status 的输出。 error: git rebase when a file has been deletedgit rebase main CONFLICT (modify/delete): index.html deleted in 0ce151e (wip) and modified in HEAD. Version HEAD of index.html left in tree. error: could not apply 0ce151e… wip 我仍然感到困惑的是，index.html 是在 HEAD 中修改的。但什么是 HEAD？是我开始合并（merge）/重置（rebase）时的提交，还是另一个分支的提交？ 答案是如果是合并，HEAD 就是你的分支，如果是重置，它就是 另一个分支，但我总觉得很难记住。 我个人认为，如果能在信息中列出分支名称，会更容易理解，就像这样： CONFLICT (modify/delete): index.html deleted on `main` and modified on `mybranch` error: git status during a merge or rebase (who is “them”?)git status On branch master You have unmerged paths. (fix conflicts and run “git commit”) (use “git merge –abort” to abort the merge) Unmerged paths: (use “git add/rm …” as appropriate to mark resolution) deleted by them: the\\_file no changes added to commit (use “git add” and/or “git commit -a”)我觉得这条信息和上一条信息一样让人困惑：上面写着 deleted by them:，但 they 指的是什么，取决于你是进行了合并（merge）、重置（rebase）还是 cherry-pick。 对于 merge，them 是您合并进来的另一个分支 对于 rebase，them 是您运行 git rebase 时所在的分支 对于 cherry-pick， 我猜这是你 cherry-picked 的提交 困惑时我喜欢做的事 努力回忆我做过的事 如果我不记得了，运行 git show main --stat 或别的什么，看看我在 main 分支上做了什么 error: git cleangit clean fatal: clean.requireForce defaults to true and neither -i, -n, nor -f given; refusing to clean 我只是觉得这有点令人困惑，你需要查一下 -i、-n 和 -f 是什么意思才能理解这个错误信息。我个人太懒了，所以即使我用了 10 年的 git clean 也不知道 -i 代表什么（interactive），直到我写下这篇文章。 困惑时我喜欢做的事通常，我只是胡乱运行 git clean -f 来删除所有未跟踪的文件，并寄希望于最好的结果，不过现在我知道了 -i 代表什么，也许会改用 git clean -i。看起来安全多了。 就这样！希望这些内容对您有所帮助！","link":"/article/translation/notes-on-git-error-messages/"},{"title":"一些杂七杂八的 Git 知识","text":"我一直在慢慢地写关于 Git 工作原理的文章。我以为自己已经对 Git 相当了解了，但像往常一样，当我试图解释一些东西时，我又学到了一些新东西。 现在回想起来，这些事情都不会让人感到惊讶，但我之前并没有想清楚。 事实是: index， staging area 和 –cached 都是一回事 储藏包含多个提交 并非所有引用都是分支或标签 merge commits（合并提交）不是空的 就这样 让我们来谈谈它们！ index， staging area 和 –cached 都是一回事运行 git add file.txt，然后运行 git status，就会看到这样的内容： git add content/post/2023-10-20-some-miscellaneous-git-facts.markdown git status Changes to be committed: (use \"git restore --staged ...\" to unstage) new file: content/post/2023-10-20-some-miscellaneous-git-facts.markdown 人们通常称之为 staging a file（暂存文件） or adding a file to the staging area（将文件添加到暂存区域）. 当你用 git add 添加文件时，git 会在幕后将文件添加到它的对象数据库（在 .git/objects）中，并更新一个名为 .git/index 的文件来引用新添加的文件。 在 Git 中，这个 staging area(暂存区)实际上有三个不同的名字。所有这些都指向同一个东西（文件 .git/index）： git diff --cached git diff --staged 这个文件对应 .git/index 我觉得我应该早点意识到这一点，但我没有，所以就这样了。 储藏包含多个提交当我运行 git stash 来储藏我的更改时，我一直对这些更改的去向感到困惑。事实证明，当你运行 git stash 时，git 会用你的更改创建一些提交，并用一个名为 stash 的引用标记它们（位于 .git/refs/stash 中）。 我们先把这篇博文储藏起来，然后查看 stash 引用的日志： git log stash --oneline 6cb983fe (refs/stash) WIP on main: c6ee55ed wip 2ff2c273 index on main: c6ee55ed wip ... some more stuff 现在我们可以查看 2ff2c273 提交，看看它包含了什么内容： git show 2ff2c273 --stat commit 2ff2c273357c94a0087104f776a8dd28ee467769 Author: Julia Evans Date: Fri Oct 20 14:49:20 2023 -0400 index on main: c6ee55ed wip content/post/2023-10-20-some-miscellaneous-git-facts.markdown | 40 ++++++++++++++++++++++++++++++++++++++++ 不出所料，它包含了这篇博文。这很合理！ 实际上，git stash 会创建两个独立的提交：一个是索引提交，另一个是你尚未暂存的改动提交。我发现这有点振奋人心，因为我一直在开发一个工具来快照和还原 git 仓库的状态（我可能会发布，也可能不会发布），我想出了一个非常类似的设计，所以这让我对我的选择感觉更好。 显然，stash 中的旧提交会保存在 reflog 中。 并非所有引用都是分支或标签Git 文档中经常泛泛地提到 references（引用），有时我觉得有点混乱。就我个人而言，在 Git 中，99% 的情况下，references（引用）指的是branch（分支）或 HEAD，而另外 1% 的情况下，references（引用）指的是 tags（标签）。实际上，我以前并不知道有什么引用不是分支、标签或 HEAD 的例子。 但是现在我知道了一个例子, stash（储藏）是一个引用，它不是分支或标签！所以这很酷。 以下是我的博客 git 仓库中的所有引用（除了 HEAD）： find .git/refs -type f .git/refs/heads/main .git/refs/remotes/origin/HEAD .git/refs/remotes/origin/main .git/refs/stash 显然，还有一个名为 git notes 的 git 命令，它可以在 .git/refs/notes 下创建引用。 merge commits（合并提交）不是空的下面是我创建的两个分支 x 和 y，每个分支都有一个文件（x.txt 和 y.txt），并将它们合并。让我们看看合并提交。 git log --oneline 96a8afb (HEAD -&gt; y) Merge branch 'x' into y 0931e45 y 1d8bd2d (x) x 如果运行 git show 96a8afb，提交看起来是空白的：没有差异！ git show 96a8afb commit 96a8afbf776c2cebccf8ec0dba7c6c765ea5d987 (HEAD -&gt; y) Merge: 0931e45 1d8bd2d Author: Julia Evans Date: Fri Oct 20 14:07:00 2023 -0400 Merge branch 'x' into y 但是如果我将合并提交分别与它的两个父提交进行比较，你会发现确实存在差异： git diff 0931e45 96a8afb --stat x.txt | 1 + 1 file changed, 1 insertion(+) git diff 1d8bd2d 96a8afb --stat y.txt | 1 + 1 file changed, 1 insertion(+) 现在回想起来，合并提交实际上并非“空的”（它们是仓库当前状态的快照，就像任何其他提交一样），这似乎很明显，但我从未想过为什么它们看起来是空的。 显然，这些合并差异为空的原因是合并差异只显示冲突。如果我创建一个包含合并冲突的仓库（一个分支在同一个文件中添加了 x，另一个分支添加了 y），并显示我解决冲突的合并提交，它看起来像这样： git show HEAD commit 3bfe8311afa4da867426c0bf6343420217486594 Merge: 782b3d5 ac7046d Author: Julia Evans Date: Fri Oct 20 15:29:06 2023 -0400 Merge branch 'x' into y diff --cc file.txt index 975fbec,587be6b..b680253 --- a/file.txt +++ b/file.txt @@@ -1,1 -1,1 +1,1 @@@ - y -x ++z 看起来它试图告诉我一个分支添加了 x，另一个分支添加了 y，而合并提交通过改为放置 z 来解决它。但在前面的例子中，没有冲突，所以 Git 根本没有显示差异。 （感谢 Jordi 告诉我合并差异是如何工作的） 就这样我会尽量保持这篇博文的简短，也许等我学到更多 Git 知识后会再写一篇博文。","link":"/article/translation/some-miscellaneous-git-facts/"},{"title":"理解容器镜像层","text":"容器非常了不起。它们允许简单的进程像虚拟机一样运行。这种优雅的背后是一套模式和实践，最终使一切都能正常工作。设计的根源在于层。层是存储和分发容器化文件系统内容的基本方式。这种设计既非常简单，同时又非常强大。在今天的文章中，我将解释什么是层，以及它们在概念上是如何工作的。 构建分层镜像当你创建一个镜像时，你通常会使用一个 Dockerfile 来定义容器的内容。它包含一系列命令，例如： FROM scratch RUN echo \"hello\" &gt; /work/message.txt COPY content.txt /work/content.txt RUN rm -rf /work/message.txt 在底层，容器引擎会按顺序执行这些命令，为每个命令创建一个“层”。 但这究竟是如何实现的呢？ 最简单的理解方式是将每一层都视为一个目录，其中包含所有已修改的文件。 让我们通过一个可能的实现方法的例子来逐步解释。 FROM scratch 表示此容器从零内容开始。 这是第一层，它可以用一个空目录 /img/layer1 来表示。 创建一个第二个目录 /img/layer2 并将 /img/layer1 中的所有内容复制到其中。 然后，执行 Dockerfile 中的下一条命令（将一个文件写入 /work/message.txt）。 这些内容被写入 /img/layer2/work/message.txt。 这是第二层。 创建一个第三个目录 /img/layer3，将 img/layer2 中的所有内容复制到其中。 下一个 Dockerfile 命令需要将主机的 content.txt 复制到该目录。 该文件被写入 /img/layer3/work/content.txt。 这是第三层。 最后，创建一个第四个目录 /img/layer4，将 img/layer3 中的所有内容复制到其中。 下一条命令删除消息文件 img/layer4/work/message.txt。 这是第四层。 为了共享这些层，最简单的方法是为每个目录创建一个压缩的 .tar.gz 文件。为了减小总文件大小，任何未经修改、只是从上一层复制的文件都会被删除。为了明确何时删除了文件，可以使用 whiteout 文件 作为占位符。该文件只需在原始文件名前加上前缀 .wh.。例如，第四层会将删除的文件替换为名为 .wh.message.txt 的占位符。当一个层被解包时，任何以 .wh. 开头的文件都可以被删除。 继续我们的例子，压缩文件将包含： 文件 内容 layer1.tar.gz 空文件 layer2.tar.gz 包含 /work/message.txt layer3.tar.gz 包含 /work/content.txt （因为 message.txt 文件没有修改） layer4.tar.gz 包含 /work/.wh.message.txt （因为 message.txt 删除了） 文件 content.txt 没有被修改，所以没有被包含在内。 以这种方式构建大量镜像会导致大量的 layer1 目录。为了确保名称的唯一性，压缩文件的命名基于内容的摘要。这类似于 Git 的工作方式。它的好处是在识别文件下载过程中任何损坏的同时，还能识别相同的内容。如果内容的摘要（哈希值）与文件名不匹配，则文件已损坏。 为了使结果可重复，还需要一个文件来解释如何对层进行排序（清单）。清单会标识要下载哪些文件以及解包它们的顺序。这使得能够重新创建目录结构。它还提供了一个重要的好处：层可以在镜像之间重复使用和共享。这最大限度地减少了本地存储需求。 在实践中，还有更多可用的优化。例如，FROM scratch 实际上意味着没有父层，所以我们的示例实际上是从 layer2 的内容开始的。引擎还可以查看构建中使用的文件，以确定是否需要重新创建层。这是层缓存的基础，它最大限度地减少了构建或重新创建层的需要。作为额外的优化，不依赖于前一层的层可以使用 COPY --link 来指示该层不需要删除或修改前一层中的任何文件。这允许压缩层文件与其他步骤并行创建。 快照在容器可以运行之前，它需要一个文件系统来挂载。本质上，它需要一个包含所有需要可用的文件的目录。压缩的层文件包含文件系统的组件，但它们不能直接挂载和使用。相反，它们需要被解包并组织成一个文件系统。这个解包后的目录被称为快照（好吧，它是具有该名称的几样东西之一 😄）。 创建快照的过程与镜像构建相反。它首先下载清单并构建要下载的层列表。对于每一层，都会创建一个包含该层父层内容的目录。此目录称为活动快照。接下来，差异应用器负责解压缩压缩的层文件并将更改应用于活动快照。然后，生成的目录称为已提交快照。最终提交的快照是作为容器文件系统挂载的快照。 使用我们之前的例子： 初始层 FROM scratch 意味着我们可以从下一层和一个空目录开始。没有父层。 创建一个 layer2 的目录。这个空目录现在是一个活动快照。下载文件 layer2.tar.gz，验证（通过将摘要与文件名进行比较），并解压缩到目录中。结果是一个包含 /work/message.txt 的目录。这是第一个提交的快照。 创建一个 layer3 的目录，并将 layer2 的内容复制到其中。这是一个新的活动快照。下载文件 layer3.tar.gz，验证并解压缩。结果是一个包含 /work/message.txt 和 /work/content.txt 的目录。这是第二个提交的快照。 创建一个 layer4 的目录，并将 layer3 的内容复制到其中。下载文件 layer4.tar.gz，验证并解压缩。差异应用器识别出删除文件 /work/.wh.message.txt，并删除 /work/message.txt。只剩下 /work/content.txt。这是第三个提交的快照。 由于 layer4 是最后一层，因此它是容器的基础。为了使其支持读写操作，会创建一个新的快照目录，并将 layer4 的内容复制到其中。此目录作为容器的文件系统挂载。运行中的容器所做的任何更改都将发生在此目录中。 如果这些目录中的任何一个已经存在，则表明另一个镜像具有相同的依赖项。因此，引擎可以跳过下载和差异应用器。它可以按原样使用该层。在实践中，这些目录和文件中的每一个都根据内容的摘要进行命名，以便更容易识别。例如，一组快照可能如下所示： 1/var/path/to/snapshots/blobs 2└─ sha256 3 ├─ 635944d2044d0a54d01385271ebe96ec18b26791eb8b85790974da36a452cc5c 4 ├─ 9de59f6b211510bd59d745a5e49d7aa0db263deedc822005ed388f8d55227fc1 5 ├─ fb0624e7b7cb9c912f952dd30833fb2fe1109ffdbcc80d995781f47bd1b4017f 6 └─ fb124ec4f943662ecf7aac45a43b096d316f1a6833548ec802226c7b406154e9 或者，换句话说: 镜像 父镜像 sha256:635944d2044d0a54d01385271ebe96ec18b26791eb8b85790974da36a452cc5c sha256:9de59f6b211510bd59d745a5e49d7aa0db263deedc822005ed388f8d55227fc1 sha256:635944d2044d0a54d01385271ebe96ec18b26791eb8b85790974da36a452cc5c sha256:fb0624e7b7cb9c912f952dd30833fb2fe1109ffdbcc80d995781f47bd1b4017f sha256:9de59f6b211510bd59d745a5e49d7aa0db263deedc822005ed388f8d55227fc1 sha256:fb124ec4f943662ecf7aac45a43b096d316f1a6833548ec802226c7b406154e9 sha256:fb0624e7b7cb9c912f952dd30833fb2fe1109ffdbcc80d995781f47bd1b4017f 实际的快照系统支持插件，可以改善其中一些行为。例如，它可以允许预先组合和解压缩快照，从而加快进程。这允许将快照存储在远程。它还允许进行特殊优化，例如按需下载所需的文件和层。 覆盖层虽然挂载很容易，但我们刚才描述的快照方法会创建大量文件变更和重复文件。这会减慢第一次启动容器的速度并浪费空间。值得庆幸的是，这是容器化过程中可以通过文件系统处理的众多方面之一。Linux 本身支持将目录挂载为覆盖层，为我们实现了大部分过程。 在 Linux 中（或以 --privileged 或 --cap-add=SYS_ADMIN 运行的 Linux 容器中）： 创建一个 tmpfs 挂载点（基于内存的文件系统，将用于探索覆盖过程） mkdir /tmp/overlay mount -t tmpfs tmpfs /tmp/overlay 创建我们流程所需的目录。我们将使用 lower 作为下层（父层），upper 作为上层（子层），work 作为文件系统的工作目录，merged 包含合并后的文件系统。 mkdir /tmp/overlay/{lower,upper,work,merged} 为实验创建一些文件。你也可以选择在 upper 中添加文件。 cd /tmp/overlay echo hello &gt; lower/hello.txt echo \"I'm only here for a moment\" &gt; lower/delete-me.txt echo message &gt; upper/upper-message.txt 将这些目录挂载为 overlay 类型的文件系统。这将在 merged 目录中创建一个新的文件系统，其中包含 lower 和 upper 目录的组合内容。 work 目录将用于跟踪文件系统的更改。 mount -t overlay overlay -o lowerdir=lower,upperdir=upper,workdir=work merged 探索文件系统。你会注意到 merged 包含 upper 和 lower 的组合内容。然后，进行一些更改： rm -rf merged/delete-me.txt echo \"I'm new\" &gt; merged/new.txt echo world &gt;&gt; merged/hello.txt 正如预期的那样，delete-me.txt 已从 merged 中删除，并在同一目录中创建了一个新文件 new.txt。如果你对这些目录执行 tree 命令，你会发现一些有趣的事情： |-- lower | |-- delete-me.txt | `-- hello.txt |-- merged | |-- hello.txt | |-- new.txt | `-- upper-message.txt |-- upper | |-- delete-me.txt | |-- hello.txt | |-- new.txt | `-- upper-message.txt 运行 ls -l upper 显示： total 12 c--------- 2 root root 0, 0 Jan 20 00:17 delete-me.txt -rw-r--r-- 1 root root 12 Jan 20 00:20 hello.txt -rw-r--r-- 1 root root 8 Jan 20 00:17 new.txt -rw-r--r-- 1 root root 8 Jan 20 00:17 upper-message.txt 虽然 merged 显示了我们更改的效果，但 upper（作为父层）存储的更改类似于我们手动过程中的示例。它包含新文件 new.txt 和修改后的 hello.txt。它还创建了一个 whiteout 文件。对于 overlay 文件系统，这涉及将文件替换为字符设备（以及设备号 0，0）。简而言之，它拥有打包目录所需的一切！ 你可以看到这种方法如何也可以用于实现快照系统。 mount 命令本身可以接受一个以冒号 (:) 分隔的 lowerdir 路径列表，所有这些路径都合并到一个文件系统中。这是现代容器本质的一部分——容器是使用原生操作系统特性组成的。 这就是创建一个基本系统的全部内容。事实上，Kubernetes（以及最近发布的 Docker Desktop 4.27.0）使用的 containerd 运行时使用类似的方法来构建和管理其镜像（更详细的内容在 Content Flow 中介绍）。希望这有助于揭开容器镜像工作方式的神秘面纱！","link":"/article/translation/understanding-container-image-layers/"},{"title":"家庭实验室新手指南（硬件）","text":"3 月 8 号, 2024 by Hayden James, in Blog Linux 直到最近，并且超过过去十年的大部分时间，我和我的妻子都是数字游民。我们从加勒比海搬到了迈阿密、纽约、拉斯维加斯、温哥华，现在又回到了家乡。这意味着在过去的许多年里，我的家庭办公室基本上由几台笔记本电脑和屏幕组成。 如今，我们的生活更加安定；我的妻子完成了学业，从事全职工作，而我的全职工作仍然是远程办公，通过支持 Linux 服务器 的家庭办公室和托管它们。 短暂的安提瓜之行后，我与我的一位技术朋友 Yves Ephraim 进行了简短的会面。他曾在 Cable &amp; Wireless 公司 担任工程师长达 20 年（直到 2003 年）。伊夫在我 2004 年入职前不久离开了 C&amp;W。他支持了安提瓜和巴布达互联网和技术发展。 我们坐在他家的办公室里，他向我介绍了一些他目前的项目，以及他在 IPv6、虚拟主机、邮件、BGP4等方面的涉猎。他的大部分工作都是通过他的家庭实验室完成的。 什么是家庭实验室?截至 2020 年 5 月，我家庭实验室位于一个 12u 机架中 把家庭实验室看成是一个可以让你在家中个人环境中尝试失败的地方。正如托马斯-爱迪生所说 我没有失败。我认为自己是失败专家。不过说真的，我还想失败得更多一些，而家庭实验室将为我创造无穷无尽的失败机会。当然，在追求成功的同时，你已经得到了成功。 一般来说，实验室是一个可以安全进行实验的地方。阅读本文的大多数人都是技术人员和系统管理员。正如你们所知，在生产设备上尝试新东西从来都不会有好结果。嘘……没关系，我知道，我知道，你不会想到一个命令就能让所有东西都离线。正因为存在这种风险，我们才要为自己构建一个沙盒环境，让自己在舒适的环境中进行尝试、测试和失败。 迄今为止，我的测试实验室设在北美和欧洲的服务器上。我正在创建一个定制的网络和服务器家庭实验室，让我更加熟悉的相关领域。我还将使用家庭实验室进行远程备份、远程服务器的网络监控和警报以及有线 UAP 接入点等。 愿我们相互激励，共同创建伟大的家庭实验室正如我告诉 Yves 的那样，我们的聊天让我重新审视了这个想法。事实上，我想我的原话是：”Yves，我看到了你的家庭实验室，我会把我的也提出来。和往常一样，我确信通过讨论还能学到很多东西。有鉴于此，我想从我的家庭实验室的硬件选择过程开始，与大家分享我的心路历程。 当然，这些年来，我一直在四处闲置设备，但今天这一切都停止了。算是吧。所以，如果你曾经有兴趣建立一个家庭实验室，或者你已经有了一个，那么让我们一起交流、分享和探索。 我们该从哪里开始呢？为了避免听起来陈词滥调，让我们从头做起，或者说是向前推进。我想说的是，我们需要存储空间，物理上的存储空间，为我们的新家庭实验室服务。 家庭实验室的位置，一切都与位置有关位置、位置、位置。一切都与位置有关！请原谅我缺乏新意。我是系统管理员，不是作家。我会尽力让你读完这篇文章。 位置至关重要，原因有几个。在家庭办公室、起居室、壁橱、阁楼、地下室或车库之间做出选择，取决于一系列重要的变量。这些变量包括室温和通风、设备周围的工作空间、网线铺设的方便程度和距离、人流量、24 小时进出的方便程度、电源、家庭实验室的噪音水平等等。 这里是一个优点与缺点速选对比表，我整理出来以帮助我们思考所有可能的家居实验室位置。请明智地选择： 家庭办公室 优点：靠近工作区域、办公桌或设备，减少电缆铺设，整天观看指示灯闪烁。 缺点：占用空间或者你会在家里的办公花费了太多时间。 客厅 优点：通常很酷，空间大且布局灵活，适合晚上一起看科幻电影，融入家庭生活。 缺点：可能造成离婚、人多可能损坏，或者在离婚过程中受损。 衣柜 优点：容易接近，隐蔽，你可以说： “看看我衣柜里藏了什么” 缺点：通风不良（热量过高），空间不足，少了一个衣柜=妻子不开心。 地下室 优点：通常温度较低，并且自愿洗衣服（可能也是缺点？）。 缺点：你真的有地下室？洪水泛滥、蜘蛛出没或受伤时无法进入。 阁楼 优点： 噪音小，电缆铺设方便。 缺点：不同地区，可能会面临阳光太强烈温度高、屋顶漏水、潮湿结露，造成电路损坏、设备噪音，夜间令人毛骨悚然。 车库 优点： 室内噪音小，完全隐蔽，妻子甚至不会注意到。 缺点：有虫子，过热（如果没有空调），灰尘，可能需要更长的电缆，或者在停车时被弄坏。 对于我的实验室，我打算把它建在家里的办公室里。我的办公室里有笔记本电脑、台式机、服务器和其他设备，因此这个位置需要的电缆线较短。在选择位置时，应考虑房间/空间中最凉爽的区域，避免阳光直射，并考虑为将来的扩展预留空间。 最好能画出家庭网络图或 使用网络设计软件。请牢记你的楼层平面图以及如何完成电缆铺设。例如，岛上大多数住宅都有 8 英寸的混凝土内墙。这些都要事先考虑，而不是事后。换句话说，把所有事情都规划好，做好笔记并列出清单。 网络与服务器机架与机柜？ 接下来，我们需要决定如何存放设备（调制解调器、路由器、交换机、服务器、配线架、UPS 系统、电源插座、冷却风扇等）。 网络机柜和机架经常与服务器机柜和机架混淆。路由器、交换机、配线架等通常比服务器浅得多。因此，网络机柜和机架通常没有服务器机柜和机架那么深。此外，网络设备产生的热量通常比服务器要少。你会发现有些网络机柜有玻璃门，可能无法为服务器留出足够的通风空间。 在决定了家庭实验室的深度和通风要求后，还需要考虑其他一些事项。机柜是一个带门和/或可移动侧面的封闭空间，而机架则是一个半开放或完全开放（四面开放）的框架。为了帮助你决定使用柜还是架，请考虑以下几点： 如果要安装大型、重型服务器，则应考虑机柜或四面机架的额外稳定性。 如果你需要经常接触设备的侧面或后部，那么开放式机架或侧面可拆卸的机柜会很合适。 如果你的设备需要额外的冷却，那么封闭式机柜需要更加注意冷却和通风。 如果房间容易积尘，机柜的额外保护将大大有助于防止灰尘进入设备。 如果安装在有客人经常光顾的一般生活区域，可以考虑使用封闭式机柜，这种机柜在上锁后通常会显得更加整洁。不过，维护良好的开放式机架以及整齐的电源和网线走线看起来也同样整洁！ 如果需要限制访问/安全，许多封闭式机柜通常提供锁和钥匙访问控制，以提高安全性。 推荐的家庭实验室硬件更新： 我已经更新了这篇文章。其中提到的一些设备已经停产或不再容易买到。我已经更新了我所做的升级以及其他推荐的硬件和配件。从我最初建立家庭实验室到现在，已经将近四年了。 现在，你已经测量了设备的最大深度，并考虑了上述所有建议，是时候购买你的第一件硬件了。或者不买。如果你喜欢用更有创意的方法来搭建家庭实验室，或许可以跳过本节。不过，即使你打算把家庭实验室设在客厅现有的柜子里、书架上、书桌下或纸箱里，上述大部分建议也适用。不，说真的… Image: 精美的纸板箱橱柜. 注： 在某些国家，你可以通过 Craigslist、Universities 和其他本地二手商家获得以下列出的大部分设备。本页面上的价格反映的是亚马逊当前的定价，可能会有变动。作为亚马逊准会员，我提供了付费商品链接，并因此获得报酬。对于亚马逊未列出的所有其他商品，如果链接随着时间的推移而不可访问，请告诉我，因为这种情况似乎总是经常发生，这也是使用亚马逊链接的另一个好处。下面我们来看看推荐的家庭实验室硬件。 换还是不换 网络运营商的调制解调器 在我们深入探讨我的家庭实验室建议之前，如果你是交换机和路由的初学者，那么下面的许多硬件可能看起来有点矫枉过正。你只需更换网络运营商的调制解调器就能轻松上手，你知道的，就是那个闪烁着各种指示灯的东西，你经常需要拔下插头重新设置才能重新访问互联网。对，就是那个，你客厅里的迷你加热器。 大多数美国网络运营商都会收取月租。购买一台自己的网络设备在经济上更有意义。而且还能提供更好的性能、可靠性和安全性。我敢打赌，你已经被财务方面的优势所吸引了，对吧？但还有更好的办法；网络运营商提供的这些调制解调器通常质量很差，都是二手货，缺乏功能。最后，网络运营商的调制解调器/路由器组合通常无法根据新出现的漏洞独立更新固件版本。这意味着你只能听从网络运营商推送新的修补固件。 如果你有一个很好的网络运营商，而且这种情况对你不适用，请继续使用你的调制解调器。在这种情况下，更换调制解调器的唯一原因是为了获得更多的网络功能，并创建一个家庭实验室进行测试！我从 ISP 更换了调制解调器/路由器组合。我选择了 Motorola MB7420 16×4 Cable Modem。更新：3 年后，有了更快的型号，例如 Motorola MB7621 32×8。 如果你希望一切从简，那就选择 Modem + Wi-Fi 路由器组合。否则，如果你想建立一个家庭实验室来管理防火墙、NAS 存储、VPN、VLAN、PoE（以太网供电）、虚拟化、远程网络基础设施监控/警报、有线 AP、网络服务器、备份服务器等，请继续。 *更新： 这款调制解调器与我使用过的大多数调制解调器类似，都会发出大量热量。在决定放置位置时，我建议放在顶部，或者在下面和上面留出空间。尽管如此，我还是很喜欢这款调制解调器！与网络运营商的调制解调器不同，它可以显示你的连接质量，包括频率（MHz）、功率（dBmV）、信噪比（dB）、校正和未校正，如果网络运营商需要，甚至可以手动设置下行频率。 选择你的家用实验室机架机架单位（缩写为 U 或 _RU_）是一种测量单位，定义为 1 3⁄4 英寸（或 44.45 毫米）。它是 19 英寸和 23 英寸机架框架高度和设备高度的测量单位。机架/设备的高度以机架单位的倍数表示。典型的全尺寸机架高度为 42U。机架和机柜则以 1U、2U、3U、4U 等单位表示。 下面是一个 6U 机架的示例（已标注）： StarTech 12U 壁挂式机架 - 13.5 英寸深/19 英寸宽/125 磅承重 - $158 （规格）- 在寻找壁挂式机架的过程中，我几乎买了这款机架的 6U 版本，但在最后一刻，我改买了 12U 版本，以便将来可能进行扩展。 Samson SRK-12 通用设备架支架 - 230 美元（规格）- 这是我的首选；这是一款完全兼容浅安装设备的音频设备架。它的一个优点是有轮子支撑，因此不必固定在墙上或地板上。不过，我的身高是 6 英尺 2 英寸，我想把机架安装在离地面约 4 英尺的地方，所以正如你所看到的，我还购买了一个 2U 的冷却风扇（进气口），我将把它放在设备的底部。如果你的房间全天候都有空调，而且你不介意安装在离地面较低的位置，那么这个机架可能会适合你。下面是一个很好的例子，说明这种机架在安装时可以看起来多么整洁。 NavePoint 9U 基本 IT 壁挂式网络机架（玻璃门锁定） - 235 美元（规格）–这是一款外观非常漂亮的网络机柜。对我来说，问题在于我只在夏天使用办公室的空调，我不希望热量成为问题；因此，对于我的家庭设置来说，封闭式机柜并不适合我。 更新： 这是一个非常坚固的壁挂式机架。我可以确认，所见即所得。没有任何问题需要报告。它完全达到了预期的效果。 家庭实验室 UPS（不间断电源） 在家里，我们有一台使用丙烷的备用发电机。它可以运行长达一周，这在热带地区非常有用。除了飓风季节，这里很少停电。2020 年至今，我们曾因雷击附近的电线杆而停过一次电。 切换到备用发电机需要一分钟左右的时间。因此，我正在寻找的机架式不间断电源解决方案是能够支持 100W 到 200W 的功率，持续几分钟。足够长的时间来故障切换到备用发电机或干净利落地关闭所有设备。将来，我可能会用更大的电池来扩展这个方案，但由于购买的东西无法退货，我有点担心投资了更大的备用电池却发现它是个哑弹。我会先测试一年，所以我决定这样做： CyberPower OR500LCDRM1U UPS，500VA/300W，6 个插座，AVR，1U 机架式 - 220 美元（规格）–小型 1U 机架式 UPS，重 20 磅，运行时间约为 10 至 15 分钟。 最终，你必须决定是否需要在家中安装不间断电源。根据经验，不间断电源电池几乎总是让人失望，这主要是因为成本与回报的关系。如果你真的需要不间断电源，你可能要花费数千美元才能获得足够长的运行时间。如果你在家工作或在家里运行关键服务（你可能不应该这样做），那么这可能是值得的。我的建议是，购买一台运行时间足够长的 UPS，让所有设备都能干净利落地关闭，并且只将 UPS 用于家庭实验室中最重要和最高效的设备。考虑到所有因素，在推荐其他 UPS 型号之前，我还得再看看这部分内容。 更新： 令人惊讶的是，到目前为止，这款 UPS 的电池性能超出了我的预期。我将它的电量降至 50% 左右，运行时间刚好超过 30 分钟，包括为 2 个 PoE 接入点 和一台 27 英寸显示器 供电。正如本文后面提到的，请注意你的耗电量。这也是我考虑过的问题，而且到目前为止已经得到了回报。以 AP 为例，每个 AP 的最大功耗仅为 6.5W。最大负载约为 UPS 容量的 20% 至 30%。 通用家用实验室架子 你注意到 CyberPower 1U UPS 没有机架支架吗？当然，你也可以把它放在其他设备的顶部；不过，我不建议你这样做，因为我们应该尽可能保持电池的低温，并在设备之间留出空间，以减少滞留的热量。最后，对于这种设置，如果把它放在通风的 1U 机架上，会显得更专业： AC Infinity 通风悬臂式 1U 通用机架搁板，10 英寸深，适用于 19 英寸 - 30 美元（规格）- 这些搁板的深度从 6 英寸到 16 英寸不等。备用电池为 9.5 英寸。在决定你的需要之前，请注意你的机架/机柜和设备的深度。 更新： 非常坚固，由于有通风口和插槽，非常适合设备散热和线缆管理。 机架式家庭实验室电源 前面提到的 CyberPower UPS 配有六个插座 - 四个后备 /w 浪涌 + 两个浪涌。目前，在我的办公桌下，我使用了七个插座，这还是在订购替代 ISP 调制解调器、路由器、交换机和服务器之前的情况，并没有考虑未来的扩展。在 UPS 的正上方，我将安装以下设备： ADJ Products AC POWER STRIP (PC-100A) - 30 美金 (技术规格 / 购买备件) - 将其插入 1U CyberPower UPS。 更新： 这是一个非常方便的硬件。它可以直接插入不间断电源，方便地开关其他设备和装置。 机架式家庭实验室散热风扇 保持机架安装设备的最佳温度可防止过热，确保性能稳定，并延长其使用寿命。计划在机架底部安装一个进气风扇（记住热空气会上升）。测试之后，我将决定是否需要在机架顶部安装排气风扇。 AC Infinity CLOUDPLATE T7-N，机架安装风扇面板 2U，19 “机架进风口 - 130 美元（规格）–智能冷却风扇系统，提供安静的高气流冷却。 该系统安装在一个不到 4 英寸深的坚固铝制 2U 机箱中。它包括一个恒温器，可在温度变化时自动调节风扇转速。最大风量为 220 CFM，可为服务器、网络和其他设备提供有效冷却。 AC Infinity CLOUDPLATE T1-N，机架安装风扇面板 1U，19 “机架进风口 - 150 美元（规格）–更紧凑的 1U 设计，可在空闲机架设备较少的情况下减少空气流量（最多 60 CFM）。 AC Infinity CLOUDPLATE T2，1U 机架安装风扇面板，顶部排风，适用于 19 英寸机架 - 150 美元（规格） - 这款 1U 顶部排风冷却风扇的风量可达 300 CFM。它的深度为 13.5 英寸，对于我的机架来说，要么很挤，要么需要改装。因此，在仔细检查之前，我还没有订购。 更新： 风扇转速最低时，机架温度可降低约 2 至 3 华氏度。我将在夏天再次更新我的想法。 更新 2： 截至 2022 年 9 月，四个风扇中有两个出现故障。我已将其从机架上拆下，并尝试用压缩空气进行清洁。在过去两年的使用过程中，它们已经积满了灰尘！我仍然建议购买这些设备，但我也建议比我更经常地清理它们！ 更新 3： 截至 2023 年 9 月，4 个风扇中有 3 个再次出现故障。 家庭实验室路由器和交换机经过数周的研究、在线比较、阅读评论、观看 YouTube 视频以及在 /r/homelab 上花费无数个小时之后，我可以肯定地说，以下三家公司的设备将完全满足你的所有路由和交换需求： 思科 &gt; Ubiquiti &gt; TP-Link。对不起，TP，不是针对你，你只是第三名，但不是最后一名；这样更好吗？ 就我的设置而言，就设备而言，我更倾向于小型企业，而不是家庭办公室。我希望将来能够获得更多的功能。以下是我的选择，然后是亚军。 路由器 多广域网负载平衡: Peplink Balance 20X [CAT 7] | Futureproof Gigabit Dual WAN Router – 500 美金 – 双频（2.4GHz/5GHz）、Wi-Fi 5 1x WAN 端口、4 x LAN 端口、1 个带冗余 SIM 卡插槽的嵌入式蜂窝调制解调器、1 个 USB 接口， 1 Gbps（千兆）带宽。 小型企业用途: Ubiquiti EdgeRouter ER-10X, 10 Port Gigabit Router with PoE Flexibility – 220 美金 (技术规格) – 10 个千兆位 RJ45 端口，都支持 PoE 供电，双核、880 MHz、MIPS1004Kc 处理器，512 MB DDR3 内存，512 MB NAND 闪存，内部交换机，串行控制台端口。 家庭实验室: TP-Link ER7206 Multi-WAN VPN Router – 150 美金 (技术规格) – 1 个千兆 SFP WAN 端口 + 1 个千兆 WAN 端口 + 2 个千兆 WAN/LAN 端口 + 1 个千兆 LAN 端口。支持多达 100 个 LAN 到 LAN IPsec、50 个 OpenVPN、50 个 L2TP 和 50 个 PPTP VPN 连接。 交换机 企业用途: Ubiquiti EdgeSwitch ES-10XP, Managed 10-Port Gigabit Switch with PoE – 215 美金 (技术规格) – 8 个千兆位 RJ45 端口所有 RJ45 端口均有 24V 无源 PoE 输出。2 个 SFP 端口。交换机有 10 Gbps 总无阻塞吞吐量，20 Gbps 交换容量。 家庭实验室: TP-Link 8-Port Gigabit Ethernet Easy Smart Switch (TL-SG108E) – 40 美金 (技术规格) 非托管专业版。支持即插即用，屏蔽端口。 还有 Netgear、pfSense，以及很多很多其他选择，但你希望我完成这篇文章，不是吗？当然，这意味着你仍需自行研究这些推荐产品，因为并非我推荐的所有产品都符合你的要求。 更新： 正合我意。路由器运行修改过的 Debian。真酷 它包含了很多企业级功能。我很高兴能学习完整的命令行管理。 家庭实验室配线架和网线 事后看来，我应该选择 24 端口配线架。相反，我却选了 这个 16 端口配线架，因为我喜欢它居中的样子，看起来不那么忙乱。我知道。我不想听。但看看那东西！如果这 16 个端口还不明显的话，那就是上面的图片了。 我的网络运营商提供的最快上网计划是下行 160Mbps / 上行 30Mbps。对于我的家庭实验室来说，我很快就不需要 CAT8 或 CAT7 了，也不需要很大的局域网流量。因此，我购买了 250 英尺的普通 CAT6 卷轴 和 一些不同长度的 Cat6，因为我可以接受 1000Mbps 的限制。是的，我还喜欢有时间喝黑咖啡。如果你想要更流畅的网络流量，那么请至少选择 CAT6a。不过，一定要使用屏蔽配线架。如果你的 RJ45 接头和配线架不支持 CAT7 或 CAT6a，那么使用 CAT7 或 CAT6a 就是浪费钱。”保持简单，笨蛋！” 不，我不是在跟你说话；这是我在选择配线架和电缆时对自己说的话。 更新： 高质量！易于打孔。我的所有补丁连接第一次就成功了。 家庭实验室服务器 出于本文的目的，我不会推荐任何特定的服务器，因为这将根据你要托管的内容而有很大的不同。NAS 存储、虚拟机、网络服务器、备份服务器、邮件服务器、广告拦截器等等，都是如此。根据我的要求，我从 eBay 上购买了一台 ThinkCentre M73 和一台 ThinkCentre M715q；两台都是二手货。至于成熟的服务器，一些不错的选择是 戴尔、惠普、思科 和 联想。对于家庭实验室来说，最好从 Craigslist 或 eBay 购买二手服务器。你可以使用维基百科搜索老一代产品的规格，例如戴尔 PowerEdge 型号历史。 更新： AMD 提高了标准。我对 M715q 的 CPU 性能印象最深。在使用 Ubuntu Server 和 Windows 10.0 时，它们都能安静、低温运行。 总结和结论图片: 你的设置就是你的设置。传统的、定制的，随你喜欢！ 在撰写本指南时，我尽力传达我的热情、想法和整个选择过程中的考虑因素。在建造家庭实验室时，找到自己的激情非常重要。你将用它来做什么？它将如何造福于你和他人？ 如果你有计划，如果你的实验室是你乐于学习、失败和成功的地方，那么它就会以这样或那样的方式为自己带来回报。尽管如此，还是要注意耗电量！你不想最终…… _房贷 1100 美元，电费 1200 美元，走进家庭实验室的感觉……不是无价的_。 计划时要留有扩展余地，可以从小处着手。你不必从机架、机柜、接线板和所有其他设备开始。先把脚浸湿，更换 ISP 调制解调器，然后再从那里开始建设。避免贸然决定硬件，而是先做做准备。然后，在 新社区论坛 上发布一两个问题，从其他技术人员和系统管理员那里获得宝贵的反馈意见。你会发现，你研究得越多，就会发现更多的方法，让事情变得恰到好处或大错特错。更重要的是，要玩得开心！与你的配偶、同事、孩子以及街对面那位五年后仍然只会挥手的邻居分享你的家庭实验室目标。 我希望这篇文章能给你带来帮助和启发，并开启我们之间的对话。请随时 联系我。我喜欢聆听、支持和向你们学习！ 更新 1 – 2020.3.10:到今天为止，我已经基本完成了新家庭实验室的安装，现在它已经完全可以正常使用了。我对购买的所有物品都很满意。在这次更新中，我在文章中添加了一些亮点、技巧和发现，并用大写字母标注在每个硬件项目下面。 在最初的文章和家庭实验室设置中，我忽略了一件事，那就是同轴电缆。现有的电缆比要求的短了三英尺。明天，我将换上更长的电缆。如你所见，我还将 ISP 调制解调器换成了下面列出的摩托罗拉型号。 不幸的是，Ubiquiti EdgeRouter 和 EdgeSwitch 太宽了大约一英寸。我没有考虑到这一点，因为我测量了它们的总宽度，然后将其与机架的内部宽度进行了比较，而不是与机架架子的宽度进行比较。哎呀！现在，为了不让交换机一直放在路由器上，我刚刚订购了两个 Ubiquiti 机架支架。这样不仅能更好地散热和美观，而且还能将路由器和交换机放置在下图中 16 端口配线架的正下方。 一两周后再来查看更新。 我的家庭实验室，正在建设中（以下列出了所有图片） 更新 2 – 2020.3.25: 我会尽快跟进细节和反馈。以下是最新状态照片: 更新 3 – 2020.4.15:在过去几周里，我增加了一些内容。 Netgear 4G LTE 调制解调器 （和天线），用于从 ISP1（有线网络）自动故障切换到 ISP2（4G 网络）。 1U 消隐板 用于提高冷却风扇的效率。 之前的两个通风 1U 隔板现在位于机架顶部。它将用于安装显示器。(见下文待办事项) 快速访问 1U mess cover，防止意外切换电源开关。 用于 E dgeRouter ER-10X 和 EdgeSwitch ES-10XP 的 机架安装套件。 清理所有电线和电缆。给网线贴上标签，当然没有给配线架贴标签！ 添加了 VLAN，限制了访客设备和其他一些家庭设备的带宽，加固了防火墙。 安装了 Zabbix 服务器，以便对 150 多台远程服务器进行额外监控。 为静态 IP 添加了一个域，其中有几个面向公众的子域。 删除或淡化了一些标识和文字，使外观更整洁。（又名强迫症） 添加 x2 UAPs 和 x2 beacon. 插座保护器，这样我就可以使用所有可用的电源插座。 添加了 ISP1 出现故障时的推送通知，因为切换到备用 ISP2 是完全无缝的。 待办事项： 添加一个单独的 21 英寸显示器，用于显示 Zabbix 主机/仪表板。 尝试使用 pfSense。将一切重置为默认值，然后根据经验教训重新配置。 添加室内 PoE 监控摄像头（目前只有室外摄像头）。 安装 KVM 桌面切换器，以便在两台服务器和桌面之间更方便地切换。 从 6 月到 8 月检查机架温度，以确定设置的冷却效率是否与计划相符。 最新家庭实验室照片： 更新 4 – 2020.5.1: 添加了一个单独的 21 英寸显示器，通过配合 Raspberry Pi 和 Zabbix，用于显示远程主机/仪表板。 更新 5 – 2020.6.7: 添加了键盘和鼠标，以便随时访问 Zabbix 用户界面。 将网状安全罩换成有色有机玻璃。 至此，我的家庭实验室就完成了。是这样吗？） 更新 – 2021.8.19:一个月前，一位朋友问我能否为他们家安装类似的设备。他们想要一个简单的全屋 VPN 设置。下图就是结果。通过一台 700VA UPS，总耗电量不到 40 瓦。 StarTech.com 6U 壁挂式网络设备机架 - 14 英寸深 AC Infinity 通风悬臂式 1U 通用机架，10 英寸深 C2G 12 端口跳线板 VCE UL 认证的 CAT6 RJ45 Keystone Jack 内联耦合器 Vilros - Raspberry Pi 4 2GB 基本套件 - 运行 Unifi 控制器 。 Brume (GL-MV1000) - Edge Gateway + VPN (wireguard) - 正在运行 Unifi 控制器 。 Edgeswitch 10xp StarTech.com 8 个插座水平 1U 机架安装 PDU 电源条 CyberPower SL700U 备用 UPS 系统，700VA/370W，8 个插座，2 个 USB 更新 – 2022.10.7:添加了关于 AC Infinity CLOUDPLATE T7-N、机架安装风扇面板 2U（进气口）的更新。确保每隔几个月清理一次这些设备上的灰尘。在 2 年未进行任何维护的情况下，4 个风扇中有 2 个瘫痪了。如果清洁后它们能重新工作，我会及时更新。 更新 – 2022.12.13:我们二月份搬到了新家。所以我搬走了家庭实验室–电缆和所有东西。终于有时间安装了。我只做了很小的改动，因为我真的很喜欢现在的样子。 变更: 安装高度更符合人体工学。 将一些设备左右翻转（以便于拔出插头/按下电源按钮） 用新的 Peplink Balance 20x更换了 ISP 的 EdgeRouter。使用 “最快响应 “方法实现负载平衡 更新: 2023.5.3: _我购买了一台1500VA 的 CyberPower 不间断电源（UPS），并拆下三个 PC 显示器和一个游戏用电脑。这样，机架内的 1U UPS 只连接服务器和网络设备。这使得在需要时电池供电的运行时间最长可达 3 小时_。 更新: 2023.9.24: 添加了有关 AC Infinity CLOUDPLATE T7-N 机架式进气风扇故障的信息。 添加了对 Peplink Balance 20x 路由器评测的链接。 发布日期：2020 年 2 月 25 日|最后更新日期：2024 年 3 月 8 日 相关文章: 五种适用于居家办公和小企业的网络设备. 找到兼容 Linux 的打印机. 家庭实验室灵感 - 来自读者的信 在使用了十年的 Linux 之后，我切换到了 Windows。接下来会怎样？","link":"/article/translation/home-lab-beginners-guide-hardware/"},{"title":"为什么我喜欢 Nox","text":"自从我参与开源 Python 项目以来，tox 一直是跨 Python 版本（以及其他因素）测试软件包的关键。然而，最近，我越来越多地在我的项目中使用 Nox。由于我被反复问到，为什么，我将总结一下我的想法。 我再怎么强调也不为过，我不想阻止任何人使用 tox。tox 很棒。没有 tox，Python 开源生态系统就不会是现在的样子。它的作者和维护者我永远感激！ 我本能地不喜欢说 tox 的坏话，但如果不对比功能和行为就无法解释我的偏好。 这不是呼吁放弃 tox（我仍然在许多项目中使用它），而是解释为什么我在某些情况下更喜欢 Nox。Nox 和 tox 都不是绝对优于另一个，只是不同而已。 配置格式tox 和 Nox 之间最明显的区别是 tox 是基于古老的 INI 格式 (tox.ini) 的 DSL，而 Nox 使用 Python 文件 (noxfile.py)。 如果您不熟悉其中任何一个，一个简单的 tox.ini 如下所示： [tox] env_list = py310,py311 [testenv] extras = tests commands = pytest {posargs} 在 noxfile.py中会是这样： import nox @nox.session(python=[\"3.10\", \"3.11\"]) def tests(session): session.install(\".[tests]\") session.run(\"pytest\", *session.posargs) 您可能会注意到命名上的差异：tox 所称的 environments 在 Nox 中称为 sessions。 现在，如果您调用 tox 或 nox，它们都会： 为 Python 3.10 和 Python 3.11 创建虚拟环境， 在其中安装当前软件包 (.) 及其额外的依赖项 tests， 并从每个环境中运行 pytest。 {posargs} 和 *session.posargs 位允许您将命令行参数传递给测试运行器。因此，要使 pytest 在第一个错误后中止，您可以分别编写 nox -- -x 或 tox -- -x。 对一些人来说，在这里使用 Python 似乎是一种倒退。我们难道不是刚刚从 setup.py 迁移到 pyproject.toml 来摆脱 Python 用于配置吗？ 是也不是。setup.py 的问题不在于它是 Python，而在于它在安装时不受控制地运行。 按需运行命令，以及代码，是 tox 和 Nox 的存在理由；唯一的区别在于它们是如何定义的。由于 tox 使用自己的语言来定义这些命令，因此您需要在其 DSL 中使用专用功能来实现任何目标。同时，如果您想在 Nox 中做某事，您通常只需要编写一些 Python 代码。 诚然，我喜欢 Nox 的主要原因之一是，在很长一段时间后回到一个重要的 tox.ini 对我来说已经成为一个挑战。就在最近，我注意到在 environ-config 中，应该检查测试套件是否通过最旧支持版本的 attrs 的 tox 环境不再工作了。我像这样定义它： [testenv] extras = tests deps = oldestAttrs: attrs==17.4.0 commands = pytest {posargs} 但是，尽管 tox 确实首先安装了 attrs 17.4.0，但在安装项目时，它会用最新版本覆盖它。为什么？我从来没有弄清楚，但我 99.9% 确定它曾经工作过。其他依赖项都不需要更新的版本，在我看来它仍然是正确的。 INI 继承 对比 Python 函数如果你足够仔细地观察，你会发现，抛开语法不谈——这两种配置原则分别是通过子类化共享代码 与通过函数共享代码的情况。在 tox 中，你定义了一个基础 testenv，所有其他环境都继承自它，但可以覆盖任何字段。仅此行为就足以让我偶尔挠头。 在 tox 中，子环境之间的重用（例如 py37 和 py38 之间）是使用因子相关的语句（如上面的 oldestAttrs:）或替换（如 {[testenv:py37]commands}）完成的，我永远记不住它们的语法，并且总是让我在其他项目中寻找例子。 在 Nox 中，如果你想重用，你写函数。没有其他语言需要学习，只有一个 API。例如，为了在 Coverage.py 下运行最旧和最新的 Python 版本，其余的没有，另外还要运行带有固定 attrs 依赖项的最旧版本，我想出了以下内容： OLDEST = \"3.7\" def _cov(session): session.run(\"coverage\", \"run\", \"-m\", \"pytest\", *session.posargs) @nox.session(python=[OLDEST, \"3.11\"], tags=[\"tests\"]) def tests_cov(session): session.install(\".[tests]\") _cov(session) @nox.session(python=OLDEST, tags=[\"tests\"]) def tests_oldestAttrs(session): session.install(\".[tests]\", \"attrs==17.4.0\") _cov(session) @nox.session(python=[\"3.7\", \"3.8\", \"3.9\", \"3.10\"], tags=[\"tests\"]) def tests(session): session.install(\".[tests]\") session.run(\"pytest\", *session.posargs) 现在，如果有其他环境（如 Mypy 或 docs），我可以使用 nox --tags tests 只运行测试。 就代码行数而言，这比 tox 等效代码要长。但这是因为它更明确，任何对 Python 有一定了解的人都可以推断出这里发生了什么。包括我自己，在一年后回顾这段代码时。实际上，明确可能是件好事。 蟒蛇的力量当然，由于 Python 的强大功能，Nox 比 tox 开箱即用地强大得多。最终，你将拥有整个标准库供你使用！你可以读写文件、创建临时目录、格式化字符串、发出 HTTP 请求。所有这些都不依赖于平台特性。 使用 tox，这些事情你经常需要编写一个 shell 脚本（可能在 Windows 上不起作用）并从你的 tox.ini 中调用它。因为 tox 不会将它的调用包装在一个 shell 中（不像 Hatch），所以你能做的事情非常有限：没有管道、没有子命令、没有输出重定向。 Nox 唯一的（纯粹是人体工程学上的）缺点是它迫使你使用 subprocess.run() 的非 shell 版本。这有时会导致相当野蛮的命令行： @nox.session(python=\"3.10\") def docs(session: nox.Session) -&gt; None: session.install(\".[docs]\") for cmd in [\"html\", \"doctest\"]: session.run( # fmt: off \"python\", \"-m\", \"sphinx\", \"-T\", \"-E\", \"-W\", \"--keep-going\", \"-b\", cmd, \"-d\", \"docs/_build/doctrees\", \"-D\", \"language=en\", \"docs\", \"docs/_build/html\", # fmt: on ) session.run(\"python\", \"-m\", \"doctest\", \"README.md\") 但是，考虑到 shell 封装的问题（参见 Docker 或 变量名净化），这可能仍然是一个净收益。即使我不得不关闭 Black (# fmt: off) 以免它变得糟糕。 额外提示： 将 Python 版本作为一等公民，优先选择正如 James Bennett 精辟地 观察到的，Nox 的一个很酷的特性是 Python 版本是会话的第一类选择器。而对于 tox 来说，它只是像其他任何因素一样的因素。 这意味着你可以调用 nox --python 3.10，所有标记为 Python 3.10 的会话都会运行。这在 CI 中非常有用，你不需要将 setup-python 的版本号（“3.11”）映射到 tox 的环境（py311——无论是手动还是使用 tox-gh 或 tox-gh-actions）。例如，使用 GitHub Actions，你可以编写： jobs: tests: runs-on: ubuntu-latest strategy: matrix: python-version: [\"3.10\", \"3.11\", \"3.12\"] steps: - uses: actions/checkout@v3 - uses: actions/setup-python@v4 with: python-version: ${{ matrix.python-version }} allow-prereleases: true - name: Setup &amp; run Nox run: | python -Im pip install nox python -Im nox --python ${{ matrix.python-version }} 新的 allow-prereleases: true 行允许你安装预发布版本，例如撰写本文时的 3.12.0b1。 tox 4 引入了使用 -f 选择单个因素的概念；因此，你可以使用 tox -f py310 运行所有 3.10 环境。版本号并不完全匹配，但 可以进行调整，PyPy 除外。我使用以下步骤： - name: Setup &amp; run tox run: | V=${{ matrix.python-version }} if [[ \"$V\" = pypy-* ]]; then V=pypy3 else V=py$(echo $V | tr -d .) fi python -Im pip install tox python -Im tox run -f $V 然而，这并不相同！tox -f py310 只会运行以 py310 开头的环境（例如 py310 或 py310-foo），而不是所有定义为使用 Python 3.10 的环境（例如名为 docs 的环境，它设置了 base_python = py310）。 结语再次强调，这篇文章不是呼吁放弃 tox 并将所有项目迁移到 Nox。我自己没有这样做，也不打算这样做。Nox 和 tox 都没有绝对的优劣之分，但如果提到的问题引起了你的共鸣，那么你还有另一种选择！ 如果你继续使用 tox，我已经写了一篇关于如何在本地运行时使其速度提高 75% 的文章。 Hynek Schlawack一个热爱 Python 🐍、Go 🐹 和 DevOps 🔧 的代码波西米亚人。博主 📝，演讲者 📢，PSF 成员 🏆，大城市的海滩流浪汉 🏄🏻，注重实质而非浮华 🧠。 我的内容对您有帮助或乐趣吗？请考虑支持我！每一份支持都能激励我创造更多内容。","link":"/article/translation/why-i-like-nox/"},{"title":"AI 网页爬虫实验（用 GPT-4 解析 HTML）","text":"从网络搜索结果中解析数据往往是一件麻烦事。但如果有一种方法能让这一艰苦的过程变得轻而易举呢？让我们尝试一下 OpenAI 的新人工智能模型吧。 Hilman Ramadhan 我一直很惊讶 OpenAI 的 chatGPT 在回答问题方面的表现，以及 Dall-e 3 制作精美图片的能力。现在，有了新的模型，让我们看看人工智能如何处理我们的网络搜索任务，特别是解析搜索引擎结果。我们都知道，从原始 HTML 中提取解析数据通常会很麻烦。但是，如果有一种方法可以将这一艰苦的过程变得轻而易举呢？ 最近（2023 年 11 月），OpenAI 团队召开了 首次开发者大会：DevDay（欢迎先观看）。其中一个令人兴奋的公告是 GPT-4 的更大的上下文窗口。新的 GPT-4 Turbo 型号功能更强、更便宜，而且支持 128K 上下文窗口。 封面插图：OpenAI 的 AI 网络爬虫。 我们的小实验在过去，我们比较了一些开源和付费 LLM 将纯文本数据转换成简单格式的能力，并开发了一个人工智能驱动的解析器。 这一次，我们将提升挑战的难度。 直接从原始 HTML 数据中抓取。 转换成我们需要的特定 JSON 格式。 只用很少的开发时间。 我们的目标 抓取一个结构良好的网站（作为热身）。 从 Google 搜索结果页面返回自然搜索结果（organic results）。 从谷歌 SERP 返回 “人们还问（相关问题）”部分。 从 Google MAPS 返回当地搜索结果。 请记住，人工智能的任务只是解析原始 HTML 数据，而不是自己进行 网页抓取。 TLDR(简而言之)如果您不想阅读整篇文章，下面是我们使用 OpenAI API（新 GPT-4）模型进行网页抓取实验的利弊总结： 优点 新模型 gpt-4-1106-preview 能够完美地抓取原始 HTML 数据。更大的令牌窗口使得只需传递原始 HTML 数据即可进行抓取。 OpenAI 的 函数调用 可以准确返回我们需要的响应格式。 OpenAI 的 多函数调用 可以从多个数据点返回数据。 与手动解析所需的开发时间相比，能够抓取原始 HTML 绝对是一个巨大优势。 缺点 与使用其他 SERP API 提供商相比，成本很高。 在传递整个原始 HTML 时要注意成本。我们仍然需要进行修剪 HTML，以便只抓取相关部分。否则，你必须为使用 token（口令）支付高额费用。. 将其用于生产时，速度太慢。 对于通常在脚本标签、额外的 AJAX 请求或执行操作（如点击、滚动）时发现的 “隐藏数据”，我们仍然需要手动操作。 工具和准备 由于我们要使用 OpenAI 的 API，因此请务必先注册并获得您的 api_key。您可能还需要 OpenAI 组织 ID。 我在这个实验中使用的是 Python，但你也可以随意使用任何编程语言。 由于我们希望返回统一的 JSON 格式，因此我们将使用 OpenAI 的函数调用功能，在这里我们可以用顺眼的格式定义响应的键和值。 我们将使用以下模型 gpt-4-1106-preview . 基础代码确保先安装 OpenAI 库。由于我使用的是 Python，我需要 pip install openai 我还将安装 requests 包，以获取原始 HTML 代码 pip install requests 我们的代码库如下所示 import json import requests from openai import OpenAI client = OpenAI( organization='YOUR-OPENAI-ORG-ID', api_key='YOUR-OPENAI-API-KEY' ) targetUrl = 'https://books.toscrape.com/' # Target URL will always changes response = requests.get(targetUrl) html_text = response.text 注：国内用户可能要设置 base_url，来使用代理或者第三方 API。 第 1 级：使用人工智能对漂亮/简单的结构化网页进行抓取让我们先热热身。我们首先针对 https://books.toscrape.com/网站，因为它的结构非常简洁，便于阅读。 截图 toscrape books，是第一个网络抓取目标 下面是我们的代码（下面有解释） # 来自 OpenAI 的 ChatCompletion API completion = client.chat.completions.create( model=\"gpt-4-1106-preview\", # 请将模型改为 gpt-3.5-turbo-1106 messages=[ {\"role\": \"system\", \"content\": \"You are a master at scraping and parsing raw HTML.\"}, {\"role\": \"user\", \"content\": html_text} ], tools=[ { \"type\": \"function\", \"function\": { \"name\": \"parse_data\", \"description\": \"Parse raw HTML data nicely\", \"parameters\": { 'type': 'object', 'properties': { 'data': { 'type': 'array', 'items': { 'type': 'object', 'properties': { 'title': {'type': 'string'}, 'rating': {'type': 'number'}, 'price': {'type': 'number'} } } } } } } } ], tool_choice={ \"type\": \"function\", \"function\": {\"name\": \"parse_data\"} } ) # 数据结果的调用 argument_str = completion.choices[0].message.tool_calls[0].function.arguments argument_dict = json.loads(argument_str) data = argument_dict['data'] # 打印格式化 for book in data: print(book['title'], book['rating'], book['price']) 我们使用 OpenAI 的 ChatCompletion API 使用模型: gpt-4-1106-preview 使用提示语 您是抓取和解析原始 HTML 的高手，并传递要分析的 raw_html。 在 tools 参数中，我们定义了用于解析原始数据的虚函数（imaginary function）。不要忘记调整参数的属性，以准确返回您想要的格式。 结果如下我们可以抓取每本书的标题、评分和价格 _（正是我们在上述__函数参数中定义的数据）_。 运行完成时间: ~15s 比较网络抓取结果 使用 gpt-3.5当切换到 gpt-3.5-turbo-1106 时，我必须调整提示词，使其更加具体： messages: {\"role\": \"system\", \"content\": \"You are a master at scraping and parsing raw HTML. Scrape ALL the book data results\"}, # function 描述 \"function\": { \"name\": \"parse_data\", \"description\": \"Get all books data from raw HTML data\", } 如果不提及 “抓取所有图书数据”，就只能得到前几个结果。 运行完成时间: ~9s第 2 层：利用人工智能解析 Google SERP 中的自然搜索结果（Organic results）谷歌搜索结果页面与之前的网站不同。它的结构更复杂，CSS 类名不清晰，原始 HTML 中包含许多未知数据。 目标 URL: ‘https://www.google.com/search?q=coffee&amp;gl=us' 警告！起初，我只是解析 Google 原始 HTML 中的所有内容，结果发现其中包含太多字符，这意味着需要更多 token 和更多成本！ 注意您的 OpenAI 账单使用情况 因此，在尝试了几次之后，我决定只要 body 部分，并删除 style 和 script 标记的内容。 我这样调整了提示词和功能参数： import re #导入 regex response = requests.get('https://www.google.com/search?q=coffee&amp;gl=us') html_text = response.text # 删除不必要的部分，以避免巨额 TOKEN 费用！ # 删除 &lt;head&gt; 和 &lt;/head&gt; 之间的所有内容 html_text = re.sub(r'&lt;head.*?&gt;.*?&lt;/head&gt;', '', html_text, flags=re.DOTALL) # 删除 &lt;script&gt; 和 &lt;/script&gt; 之间出现的所有内容 html_text = re.sub(r'&lt;script.*?&gt;.*?&lt;/script&gt;', '', html_text, flags=re.DOTALL) # 删除 &lt;style&gt; 和 &lt;/style&gt; 之间的所有内容 html_text = re.sub(r'&lt;style.*?&gt;.*?&lt;/style&gt;', '', html_text, flags=re.DOTALL) completion = client.chat.completions.create( model=\"gpt-4-1106-preview\", messages=[ {\"role\": \"system\", \"content\": \"You are a master at scraping Google results data. Scrape top 10 organic results data from Google search result page.\"}, {\"role\": \"user\", \"content\": html_text} ], tools=[ { \"type\": \"function\", \"function\": { \"name\": \"parse_data\", \"description\": \"Parse organic results from Google SERP raw HTML data nicely\", \"parameters\": { 'type': 'object', 'properties': { 'data': { 'type': 'array', 'items': { 'type': 'object', 'properties': { 'title': {'type': 'string'}, 'original_url': {'type': 'string'}, 'snippet': {'type': 'string'}, 'position': {'type': 'integer'} } } } } } } } ], tool_choice={ \"type\": \"function\", \"function\": {\"name\": \"parse_data\"} } ) argument_str = completion.choices[0].message.tool_calls[0].function.arguments argument_dict = json.loads(argument_str) data = argument_dict['data'] for result in data: print(result['title']) print(result['original_url'] or '') print(result['snippet'] or '') print(result['position']) print('---') 首先，我们只修剪（trim）选中的部分。 将提示词调整为 您是 Google 搜索结果数据的高手。从 Google 搜索结果页面抓取前 10 条自然搜索结果数据（You are a master at scraping Google results data. Scrape top 10 organic results data from Google search result page.）。 将功能参数调整为所需的格式。 利用人工智能对谷歌 SERP 进行基本的网络抓取 哒哒哒！尽管谷歌原始 HTML 格式复杂，我们还是准确地获得了所需的数据。 运行完成时间: ~28s 备注： 我最初的提示词是 很好地解析 Google SERP 原始 HTML 数据中的自然搜索结果(Parse organic results from Google SERP raw HTML data nicely)，但只能返回前 3-5 个结果，因此我调整了提示词，以获得更多的结果。 使用 gpt-3.5 模型我无法做到这一点，因为原始 HTML 数据量超过了 token 窗口长度。 第 3 层：利用人工智能解析谷歌地图中的本地地点结果现在，让我们抓取另一个 Google 产品，即 Google 地图。这是我们的目标页面： https://www.google.com/maps/search/coffee/@40.7455096,-74.0083012,14z?hl=en&amp;entry=ttu 谷歌地图截图 如您所见，每个项目都包含许多信息。我们将进行搜索：- Name- Rating average- Total rating- Price- Address- Extras- Hours- Additional service- Thumbnail image 警告！ 原来，谷歌地图是通过 Javascript 来加载这些数据的，所以我必须改变获取原始网页的方法，从使用 requests 改为使用 selenium 来获取 代码在 Python 上安装 Selenium。更多安装说明请参阅 此处。 pip install selenium 导入 Selenium from selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.webdriver.common.by import By 创建一个无头浏览器实例来浏览网页 target_url = 'https://www.google.com/maps/search/coffee/@40.7455096,-74.0083012,14z?hl=en' op = webdriver.ChromeOptions() op.add_argument('headless') driver = webdriver.Chrome(options=op) driver.get(target_url) driver.implicitly_wait(1) # seconds # 获取的原始网页 html_text = driver.page_source # 您可以继续使用之前的方法，先只修剪 body 部分 我使用 implicitly_wait 等待 1 秒钟，以确保数据已经在那里，可以进行抓取。 下面是 OpenAI API 函数： completion = client.chat.completions.create( model=\"gpt-4-1106-preview\", messages=[ {\"role\": \"system\", \"content\": \"You are a master at scraping Google Maps results. Scrape all local places results data\"}, {\"role\": \"user\", \"content\": html_text} ], tools=[ { \"type\": \"function\", \"function\": { \"name\": \"parse_data\", \"description\": \"Parse local results detail from Google MAPS raw HTML data nicely\", \"parameters\": { 'type': 'object', 'properties': { 'data': { 'type': 'array', 'items': { 'type': 'object', 'properties': { 'position': {'type': 'integer'}, 'title': {'type': 'string'}, 'rating': {'type': 'string'}, 'total_reviews': {'type': 'string'}, 'price': {'type': 'string'}, 'type': {'type': 'string'}, 'address': {'type': 'string'}, 'phone': {'type': 'string'}, 'hours': {'type': 'string'}, 'service_options': {'type': 'string'}, 'image_url': {'type': 'string'}, } } } } } } } ], tool_choice={ \"type\": \"function\", \"function\": {\"name\": \"parse_data\"} } ) argument_str = completion.choices[0].message.tool_calls[0].function.arguments argument_dict = json.loads(argument_str) data = argument_dict['data'] print(data) 结果 利用人工智能进行本地地图 API 搜索的结果 结果很完美！我可以获得每个 local_results 的准确数据。 运行完 Selenium 时间: ~47s运行时间 (除了 Selenium ): ~34s第 4 层次： 利用人工智能解析来自 Google SERP 的两种不同数据（自然搜索结果和人们询问相关问题的部分）如您所知，谷歌 SERP 不仅显示自然搜索结果，还显示其他数据，如广告、people-also-ask（相关问题）、知识图谱等。 让我们来看看如何利用调用 OpenAI 的多个函数处理多个数据。 代码如下 completion = client.chat.completions.create( model=\"gpt-4-1106-preview\", messages=[ {\"role\": \"system\", \"content\": \"You are a master at scraping Google results data. Scrape two things: 1st. Scrape top 10 organic results data and 2nd. Scrape people_also_ask section from Google search result page.\"}, {\"role\": \"user\", \"content\": html_text} ], tools=[ { \"type\": \"function\", \"function\": { \"name\": \"parse_organic_results\", \"description\": \"Parse organic results from Google SERP raw HTML data nicely\", \"parameters\": { 'type': 'object', 'properties': { 'data': { 'type': 'array', 'items': { 'type': 'object', 'properties': { 'title': {'type': 'string'}, 'original_url': {'type': 'string'}, 'snippet': {'type': 'string'}, 'position': {'type': 'integer'} } } } } } } }, { \"type\": \"function\", \"function\": { \"name\": \"parse_people_also_ask_section\", \"description\": \"Parse `people also ask` section from Google SERP raw HTML\", \"parameters\": { 'type': 'object', 'properties': { 'data': { 'type': 'array', 'items': { 'type': 'object', 'properties': { 'question': {'type': 'string'}, 'original_url': {'type': 'string'}, 'answer': {'type': 'string'}, } } } } } } } ], tool_choice=\"auto\" ) # Organic_results（自然搜索结果） argument_str = completion.choices[0].message.tool_calls[0].function.arguments argument_dict = json.loads(argument_str) organic_results = argument_dict['data'] print('Organic results:') for result in organic_results: print(result['title']) print(result['original_url'] or '') print(result['snippet'] or '') print(result['position']) print('---') # People also ask （相关问题） argument_str = completion.choices[0].message.tool_calls[1].function.arguments argument_dict = json.loads(argument_str) people_also_ask = argument_dict['data'] print('People also ask:') for result in people_also_ask: print(result['question']) print(result['original_url'] or '') print(result['answer'] or '') print('---') 代码说明 调整提示词，使其包含关于抓取内容的具体信息： 您是搜索 Google 结果数据的高手。搜索两样东西： 第一。抓取排名前 10 的自然搜索结果数据；第二。从 Google 搜索结果页面中抓取 _the_ people_also_ask 部分（You are a master at scraping Google results data. Scrape two things: 1st. Scrape top 10 organic results data and 2nd. Scrape the _the_ people_also_ask section from the Google search result page）。 添加并分离函数（separating functions），一个用于自然搜索结果，另一个用于 people-also-ask 部分。 测试两种不同格式的输出。 结果如下: 利用人工智能获取多个数据点 成功我可以分别搜索自然搜索结果和 people_also_ask。OpenAI 功不可没！ 问题:我无法为 people_also_ask 部分提取答案和原始网址。原因是这些信息隐藏在脚本标签的某处。我们可以通过提供脚本内容的特定部分来尝试，但我认为这对本实验来说是 作弊，因为我们要传递的是原始网页内容，而不是精确定位或给出提示。 运行时间: ~30s如果您想了解如何更低代价、更快速、更准确地搜索这些数据。您可以阅读以下文章： 使用 Python 对 Google 搜索结果进行抓取 使用 Python 抓取 Google 地图的地点结果 与 SerpApi 的表格比较以下是使用 OpenAI 新的 GPT-4 模型进行网络抓取与SerpApi的时间表对比。我们使用 正常速度 进行比较；SerpApi 在使用Ludicrous Speed时速度更快（大约是正常速度的两倍）。 Subject gpt-4-1106-preview SerpApi Organic results 15s 2.4s Organic results with Related questions 30s 2.4s Maps local results 47s 2.7s 结语随着时间的推移，OpenAI 肯定会有很大改进。现在，我们可以通过应用程序接口（API）抓取网站并收集相关数据。但从所花费的时间来看，它还不能用于生产、商业目的或规模化。虽然数据的准确性和响应格式都很完美，但在成本和速度方面还远远不够。 如果您有任何想法、发现任何错误，或想补充与本文章相关的其他实验，请发送邮件至 hilman@serpapi.com。 感谢您阅读此文！","link":"/article/translation/web-scraping-and-parsing-experiment-with-ai-openai/"}],"tags":[{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Wiki","slug":"Wiki","link":"/tags/Wiki/"},{"name":"community","slug":"community","link":"/tags/community/"},{"name":"guide","slug":"guide","link":"/tags/guide/"},{"name":"university","slug":"university","link":"/tags/university/"},{"name":"开源","slug":"开源","link":"/tags/%E5%BC%80%E6%BA%90/"},{"name":"展览","slug":"展览","link":"/tags/%E5%B1%95%E8%A7%88/"},{"name":"Open-Source","slug":"Open-Source","link":"/tags/Open-Source/"},{"name":"COSCon","slug":"COSCon","link":"/tags/COSCon/"},{"name":"China","slug":"China","link":"/tags/China/"},{"name":"full-stack","slug":"full-stack","link":"/tags/full-stack/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"重庆","slug":"重庆","link":"/tags/%E9%87%8D%E5%BA%86/"},{"name":"online","slug":"online","link":"/tags/online/"},{"name":"offline","slug":"offline","link":"/tags/offline/"},{"name":"Coffee&Code","slug":"Coffee-Code","link":"/tags/Coffee-Code/"},{"name":"成都","slug":"成都","link":"/tags/%E6%88%90%E9%83%BD/"},{"name":"NGO","slug":"NGO","link":"/tags/NGO/"},{"name":"公益","slug":"公益","link":"/tags/%E5%85%AC%E7%9B%8A/"},{"name":"官网","slug":"官网","link":"/tags/%E5%AE%98%E7%BD%91/"},{"name":"会务","slug":"会务","link":"/tags/%E4%BC%9A%E5%8A%A1/"},{"name":"结对编程","slug":"结对编程","link":"/tags/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B/"},{"name":"Deno","slug":"Deno","link":"/tags/Deno/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"performance","slug":"performance","link":"/tags/performance/"},{"name":"pair-programming","slug":"pair-programming","link":"/tags/pair-programming/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"editor","slug":"editor","link":"/tags/editor/"},{"name":"product","slug":"product","link":"/tags/product/"},{"name":"design","slug":"design","link":"/tags/design/"},{"name":"computer","slug":"computer","link":"/tags/computer/"},{"name":"science","slug":"science","link":"/tags/science/"},{"name":"W3C","slug":"W3C","link":"/tags/W3C/"},{"name":"development","slug":"development","link":"/tags/development/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"copilot","slug":"copilot","link":"/tags/copilot/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"functional-programming","slug":"functional-programming","link":"/tags/functional-programming/"},{"name":"AI实战","slug":"AI实战","link":"/tags/AI%E5%AE%9E%E6%88%98/"},{"name":"Agent","slug":"Agent","link":"/tags/Agent/"},{"name":"DeepSeek","slug":"DeepSeek","link":"/tags/DeepSeek/"},{"name":"AI时代编程教育","slug":"AI时代编程教育","link":"/tags/AI%E6%97%B6%E4%BB%A3%E7%BC%96%E7%A8%8B%E6%95%99%E8%82%B2/"},{"name":"front-end","slug":"front-end","link":"/tags/front-end/"},{"name":"teenager","slug":"teenager","link":"/tags/teenager/"},{"name":"freeCodeCamp","slug":"freeCodeCamp","link":"/tags/freeCodeCamp/"},{"name":"translation","slug":"translation","link":"/tags/translation/"},{"name":"english","slug":"english","link":"/tags/english/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"Node.JS","slug":"Node-JS","link":"/tags/Node-JS/"},{"name":"crawler","slug":"crawler","link":"/tags/crawler/"},{"name":"Puppeteer","slug":"Puppeteer","link":"/tags/Puppeteer/"},{"name":"cooperation","slug":"cooperation","link":"/tags/cooperation/"},{"name":"WeChat","slug":"WeChat","link":"/tags/WeChat/"},{"name":"robot","slug":"robot","link":"/tags/robot/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"component","slug":"component","link":"/tags/component/"},{"name":"WebCell","slug":"WebCell","link":"/tags/WebCell/"},{"name":"BootStrap","slug":"BootStrap","link":"/tags/BootStrap/"},{"name":"文言","slug":"文言","link":"/tags/%E6%96%87%E8%A8%80/"},{"name":"automation","slug":"automation","link":"/tags/automation/"},{"name":"脚手架","slug":"脚手架","link":"/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"name":"TDD","slug":"TDD","link":"/tags/TDD/"},{"name":"Agile","slug":"Agile","link":"/tags/Agile/"},{"name":"Vibe Coding","slug":"Vibe-Coding","link":"/tags/Vibe-Coding/"},{"name":"理财","slug":"理财","link":"/tags/%E7%90%86%E8%B4%A2/"},{"name":"黑客松","slug":"黑客松","link":"/tags/%E9%BB%91%E5%AE%A2%E6%9D%BE/"},{"name":"开源市集","slug":"开源市集","link":"/tags/%E5%BC%80%E6%BA%90%E5%B8%82%E9%9B%86/"},{"name":"图书馆","slug":"图书馆","link":"/tags/%E5%9B%BE%E4%B9%A6%E9%A6%86/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Bronze-3","slug":"Bronze-3","link":"/tags/Bronze-3/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"堆栈","slug":"堆栈","link":"/tags/%E5%A0%86%E6%A0%88/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"内网","slug":"内网","link":"/tags/%E5%86%85%E7%BD%91/"},{"name":"DevOps","slug":"DevOps","link":"/tags/DevOps/"},{"name":"ECMAScript","slug":"ECMAScript","link":"/tags/ECMAScript/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"BOM","slug":"BOM","link":"/tags/BOM/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"Codespaces","slug":"Codespaces","link":"/tags/Codespaces/"},{"name":"GraphQL","slug":"GraphQL","link":"/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","link":"/tags/Apollo/"},{"name":"Koa","slug":"Koa","link":"/tags/Koa/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"Caddy","slug":"Caddy","link":"/tags/Caddy/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"bundle","slug":"bundle","link":"/tags/bundle/"},{"name":"RESTful","slug":"RESTful","link":"/tags/RESTful/"},{"name":"Strapi","slug":"Strapi","link":"/tags/Strapi/"},{"name":"mentor","slug":"mentor","link":"/tags/mentor/"},{"name":"workshop","slug":"workshop","link":"/tags/workshop/"},{"name":"college","slug":"college","link":"/tags/college/"},{"name":"PWA","slug":"PWA","link":"/tags/PWA/"},{"name":"Conference","slug":"Conference","link":"/tags/Conference/"},{"name":"conference","slug":"conference","link":"/tags/conference/"},{"name":"binary","slug":"binary","link":"/tags/binary/"},{"name":"logic","slug":"logic","link":"/tags/logic/"},{"name":"circuit","slug":"circuit","link":"/tags/circuit/"},{"name":"hardware","slug":"hardware","link":"/tags/hardware/"},{"name":"history","slug":"history","link":"/tags/history/"},{"name":"state","slug":"state","link":"/tags/state/"},{"name":"MobX","slug":"MobX","link":"/tags/MobX/"}],"categories":[{"name":"Open-Source","slug":"Open-Source","link":"/categories/Open-Source/"},{"name":"Partner","slug":"Partner","link":"/categories/Partner/"},{"name":"Profile","slug":"Profile","link":"/categories/Profile/"},{"name":"Activity","slug":"Activity","link":"/categories/Activity/"},{"name":"Conference","slug":"Activity/Conference","link":"/categories/Activity/Conference/"},{"name":"Salon","slug":"Activity/Salon","link":"/categories/Activity/Salon/"},{"name":"Workshop","slug":"Activity/Workshop","link":"/categories/Activity/Workshop/"},{"name":"Article","slug":"Article","link":"/categories/Article/"},{"name":"Translation","slug":"Article/Translation","link":"/categories/Article/Translation/"},{"name":"Algorithm","slug":"Article/Algorithm","link":"/categories/Article/Algorithm/"},{"name":"Engineering","slug":"Article/Engineering","link":"/categories/Article/Engineering/"},{"name":"Propaganda","slug":"Article/Propaganda","link":"/categories/Article/Propaganda/"},{"name":"Summary","slug":"Article/Summary","link":"/categories/Article/Summary/"},{"name":"Theory","slug":"Article/Theory","link":"/categories/Article/Theory/"}]}